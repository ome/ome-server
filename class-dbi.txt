i've replaced the old DBObject class with a Class::DBI implementation,
and committed the changes to CVS.  i've also changed all of the
references i could find to DBObjects i could find to the new API.
what's different about the API, you ask?  not much, but here goes:

also, once Class::DBI is installed, you can get the module
documentation using the command "perldoc Class::DBI", just as with any
other module.

1) Obtaining objects
--------------------

right now you still use the factory, which you get from your session.
the method names are the same.  newObject now takes an extra
parameter, allowing you to assign values to the fields right away upon
creating the object.  note that Class::DBI creates the appropriate row
in the DB table immediately, so NOT NULL columns _must_ be supplied in
this data parameter.

# loads project #42 from the DB
my $project = $factory->loadObject("OME::Project",42);

# create a new image
my $imageData = {
    name => "A great image",
    # etc for other not-null columns
};
my $image = $factory->newObject("OME::Image",$imageData);

there is a new method called findObjects which allows you to grab
objects by equality on a single field, soon i will add a method to
allow you to use any arbitrary where clause.  this should be a simple
delegation to Class::DBI, and therefore implemented soon.  note that
this can return either an array or an iterator, in either case it
assumes that more than one object will be returned.  i might also
create a helper method for the case when you expect a single object.

# find a bunch of images
my @images = $factory->findObjects("OME::Image",'experimenter',$session->User());
foreach my $image (@images) {
    # do something to the image
}

# similarly with an iterator
my $images = $factory->findObjects("OME::Image",'experimenter',$session->User());
while (my $image = $images->next()) {
    # do something to the image
}

the only difference in the two snippets above is that the first loads
all of the objects at once, the second only keeps one in memory at a
time.


2) Reading object fields
------------------------

there are a couple of changes here.  first, there is a separate
accessor method for each field.  i really like this feature.  it
rocks.

# the old way:
my $project = <one of the above methods>;
print $project->Field("name");

# the new way:
my $project = <one of the above methods>;
print $project->name();

second, Class::DBI enforces a one table per class paradigm, which
DBObject didn't require.  this meant in the old system, the Image
object could pull its fields from multiple tables (namely, IMAGES and
ATTRIBUTES_IMAGES_XYZWT).  now, however, this is done with two
classes.

# the old way:
my $image = <whatever>;
print $image->Field("name");
print $image->Field("sizeX");
print $image->Field("sizeW");

# the new way:
my $image = <whatever>;                       # data from IMAGES
my $attributes = $images->ImageAttributes();  # ATTRIBUTES_IMAGE_XYZWT
print $image->name();
print $attributes->size_x();
print $attributes->num_waves();

third, note above that the field names changed a bit.  i decided that
while i was at it, i'd try to adopt a convention that the class's
field names match the lowercased version of the table's column names.
this should make it easier to know exactly how to get which pieces of
information from where.  the only time this is violated is in the case
of foreign keys; instead of an integer Image field called
experimenter_id, there is an OME::Experimenter field called
experimenter.  the mapping for the database from object to integer ID
is performed automatically by Class::DBI.


3) Writing object fields
------------------------

the accessors above are also the mutators, just pass in the new value
as a parameter.

$image->name("A new name");
$image->experimenter($session->User());

these changes are automatically written to the DB (to limit the number
of UPDATE statements).  to flush the changes to the DB:

$image->commit();

note that this is not commit in the sense of a DB transaction.  to
make things slightly confusing, Class::DBI turns off AutoCommit by
default, so you _also_ have to commit the DB transaction to actually
make the changes show up.  two ways to do that (i've been using the
latter form):

# in our case, these two statements are completely equivalent.
# note for a future discussion that this is not true in general.
$image->DBH()->commit();
$image->dbi_commit();

to put all this together, an example from the image importer:

# this does not need a commit, since newObject writes to the database.
# it does not a dbi_commit, since we're in the middle of a transaction.
my $imageData = {
    name => "image name",
    # etc.
};
my $image = $factory->newObject("OME::Image",$imageData);

# ditto.
my $attributeData = {
    image => $image,
    size_x => 1,
    # etc.
};
my $attributes = $factory->newObject("OME::Image::Attributes",$attributeData);

# these _do_ need a commit, since modified fields aren't
# automatically flushed.
$image->description("This image is weird.");
$attributes->bits_per_pixel(17);  # a weird image indeed

$image->commit();

$image->dbi_commit();
