<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; I; Linux 2.2.18-4hpmac ppc) [Netscape]">
   <meta name="Author" content="Ilya Goldberg">
   <title>OME xmlrpc Documentation</title>
</head>
<body>

<center>
<h1>
OME xmlrpc Documentation</h1></center>

<h3>
Introduction</h3>
XMLRPC is an XML protocol that implements remote procedure calls.&nbsp;
Essentially, it allows calling a procedure, sub-routine or a method for
an object on a remote machine by sending and receiving a message in XML.&nbsp;
The message is transported via http.&nbsp; Utility libraries are available
to help form the XML message and interpret the response.&nbsp; These libraries
are available for almost any form of computing language including C, C++,
Perl, Java, Python, PHP, Visual Basic, COM, AppleScript, etc.&nbsp; It
is immaterial what languages are used to implement the caller (client)
or the call-ee (server), as long as they communicate via xmlrpc.&nbsp;
Another advantage of xmlrpc is that http is used to transport the message.&nbsp;
This means that one can implement a server using CGI, and use any of a
number of available web servers to allow clients to connect to your methods.&nbsp;
Although xmlrpc allows the servers and clients to be on separate machines,
they may also co-exist on the same machine, and xmlrpc can simply be used
as a language-neutral way to make local procedure calls.
<p>More information is available on xmlrpc, and links to libraries for
different languages at <a href="http://www.xmlrpc.com">www.xmlrpc.com</a>.
<p>OME makes several methods available via xmlrpc:
<ul>
<li>
<b>OME.Login</b> - Establishes a connection to a server.&nbsp; The caller
must provide a username and a password which is valid on the server.&nbsp;
In the future, authentication information may be provided through the use
of X509 certificates.&nbsp; To avoid passing usernames and passwords in
the clear, it is recommended that this call be made over SSL through https
rather than http.&nbsp; The string returned by this method is a session
key.&nbsp; The session key must be passed as the first parameter in all
other calls to OME.</li>

<li>
<b>OME.Connect</b> - The parameter to this method is a session key, and
the return value is also a session key, but not necessarily the same key
as was passed in.&nbsp; This method can be used to "refresh" the connection
to a server, or to share a single connection to the server among several
clients without passing username/password between clients.</li>

<li>
<b>OME.GetSelectedDatasets</b> - Returns an array of dataset IDs selected
by the user in the current session.&nbsp; Note that the current user session
is different from the session key.&nbsp; The session key is used primarily
as an authentication token (hence the key designation), and is intended
for a single client or for several closely related client calls.&nbsp;
The user session may span several unrelated clients and is used to keep
track of user preferences, selections, etc.</li>

<li>
<b>OME.SetSelectedDatasets</b> - Parameters are an array of dataset IDs.&nbsp;
Sets the dataset selection for the current user session.</li>

<li>
<b>OME.RegisterAnalysis</b> - This call must be made to register a new
analysis with OME.&nbsp; The parameter is a structure that contains the
program name (programName) or program ID (programID), the dataset ID (datasetID),
and any additional parameters that the program needs to run.&nbsp; The
program's parameter names are as defined for this program in OME.</li>

<li>
<b>OME.GetFeatures</b> - Parameters are a structure containing the local
feature representation, and a structure (DbMap) containing a map between
the local representation and the database representation (tables and columns).&nbsp;
The DbMap is discussed further below.&nbsp; The return value is an array
of feature structures containing datamembers as specified in the local
representation - all filled in with values from OME.&nbsp; Required datamembers
in the local feature representation are at least one of the following:&nbsp;
AnalysisID, DatasetID, FeatureID.&nbsp; The value assigned to AnalysisID,
DatasetID, or FeatureID determines what features are returned - all features
from a given analysis, belonging to a given dataset, or just a single feature.</li>

<li>
<b>OME.WriteFeatures</b> - Writes features to OME.&nbsp; The parameters
are an array of feature structures, and the DbMap structure specifying
which of the fields in the local structure are to written to the database.</li>

<li>
<b>OME.Finish</b> - Commits work from the registered analysis to OME, and
invalidates the session key.&nbsp; If Finish is not called, OME reverts
to a state prior to the Login call.</li>
</ul>

<h3>
Examples</h3>
Tracking segmented objects as they move through time (in Perl):
<pre><tt><i># This package allows us to make xmlrpc calls.
</i>use Frontier::Client;

<i># Our local feature representation.&nbsp; This hash is what our algorithm uses to compute trajectories.
</i></tt>my %featureHash = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DatasetID&nbsp;&nbsp;&nbsp;&nbsp; => $datasetID,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xPix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yPix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; zPix&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trajectory_ID => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movedTo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => undef
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>

<pre><i><tt># inputAttributes and outputAttributes are DbMap structures as described above.
# The hash keys (structure field names) are the field names of the local feature structure.
# The hash values (structure field values) are arrays where the first element is the OME table name
# and the second element is the column name.</tt></i></pre>

<pre><i><tt># The things we want to read from OME are the X, Y, Z coordinates of the centers of volume
# and the timepoint for each segmented feature.
</tt></i>my %inputAttributes = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X => ['LOCATION', 'X'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y => ['LOCATION', 'Y'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Z => ['LOCATION', 'Z'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t => ['TIMEPOINT','TIMEPOINT']
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>

<pre><i><tt># The things we want to write back to OME are trajectory information.
# for those same segmented features.
</tt></i>my %outputAttributes = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; trajectory_ID => ['DELTA','TRAJECTORY_ID'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; movedTo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => ['DELTA','MOVED_TO'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => ['DELTA','DELTA_X'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => ['DELTA','DELTA_Y'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; deltaZ&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => ['DELTA','DELTA_Z'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; distance&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => ['DELTA','DISTANCE']&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );</pre>

<pre><i><tt># Get a secure (SSL) and an insecure server connection
</tt></i>my $serverSSL = Frontier::Client->new( 'url' => "https://ome1-sorger.mit.edu/OMErpc" );
my $server&nbsp;&nbsp;&nbsp; = Frontier::Client->new( 'url' =>&nbsp; "http://ome1-sorger.mit.edu/OMErpc" );</pre>

<pre><i><tt># Login to OME securely.&nbsp; We could also do it insecurely, but then our login information would
# be transmitted in clear text.&nbsp; We make all other calls un-encrypted (we could encrypt them as well).
</tt></i>my $sessionKey = $serverSSL->call ('OME.Login', $username, $password);
&nbsp;
<i><tt># Register an analysis.&nbsp; This program doesn't have parameters, but if it did, their names and values
# would go into the hash we're passing in.
</tt></i>my $analysisID = $server->call ('OME.RegisterAnalysis', $sessionKey, {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; programName => 'SampleSpotTracker',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datasetID&nbsp;&nbsp; => $datasetID
<i>#i.e.&nbsp;&nbsp; param1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; => $paramVal1
</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; });</pre>

<pre><i><tt># Read the segmented objects from OME.
</tt></i>my $features = $server->call ('OME.GetFeatures', $sessionKey, \%featureHash, \%inputAttributes);</pre>

<pre><i># Call our local feature tracking subroutine
</i>TrackFeatures ($features);</pre>

<pre><i># Write our results back to OME
</i>$server->call ('OME.WriteFeatures', $sessionKey, $analysisID, $features, \%outputAttributes);</pre>

<pre><i># We're done!
</i>$server->call ('OME.Finish', $sessionKey);</pre>

</body>
</html>
