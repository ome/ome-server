%
% Copyright (C) 2003 Open Microscopy Environment
%       Massachusetts Institue of Technology,
%       National Institutes of Health,
%       University of Dundee
%
%
%
%    This library is free software; you can redistribute it and/or
%    modify it under the terms of the GNU Lesser General Public
%    License as published by the Free Software Foundation; either
%    version 2.1 of the License, or (at your option) any later version.
%
%    This library is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
%    Lesser General Public License for more details.
%
%    You should have received a copy of the GNU Lesser General Public
%    License along with this library; if not, write to the Free Software
%    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
%
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% Written by:  Nikita Orlov <norlov@nih.gov>
%~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
% Signatures on the basis of first four moments (mean, std, skewness, kurtosis)
% for data generated by vertical, horizontal, diagonal and alternative
% diagonal 'combs'. 
% Each column of the comb results in 4 scalars [mean,std,skewness,kurtosis], 
% we have as many of those [...] as 20. So, 20 go to a 3-bin histogram,
% producing 1x48 vector.
%
% Nikita Orlov
% Computational Biology Unit, LG, NIA/NIH
% :: revision :: 03-14-2005
%
% Input:  Im (input image; or a matrix)
% Output: hr (3-bin histograms from all 4 moments and 4 comb orientations form {3x4x4} 48 vector)
%
% Example: hr = CombFirst4Moments(im2double(imread(filename)));
%
function vec = CombFirst4Moments(a),
	[m,n] = size(a);
	if min(m,n)<=10
		vec = zeros(1,16); 
		mvec = zeros(1,16); 
		return; 
	end;
	I = (1:m)'*ones(1,n); 
	J = ones(m,1)*(1:n); 
	n2 = round(n/2); 
	m2 = round(m/2);
	z4 = [0 0 0 0];

	% major diag ...
	matr4moments = [];
	for ii=(1-m):(round(m/10)):m
		tmp = a(abs((I+ii)-J)<1);
		if isempty(tmp)
			matr4moments = [matr4moments; z4]; 
		else
			matr4moments = [matr4moments; get4scalMoments(tmp)];
		end;
	end;
	vec = matr4moments_to_hist(matr4moments); matr4moments = [];

	% alternative diag ...
	J1=fliplr(J);
	for ii=(1-m):(round(m/10)):m
		tmp = a(abs((I+ii)-J1)<1);
		if isempty(tmp)
			matr4moments = [matr4moments; z4]; 
		else
			matr4moments = [matr4moments; get4scalMoments(tmp)];
		end;
	end;
	vec = [vec matr4moments_to_hist(matr4moments)];
	matr4moments = [];

	% vertical comb ...
	for ii=(1-n):(round(n/10)):n, tmp = a(abs((J+ii)-n2)<1);
		if isempty(tmp)
			matr4moments = [matr4moments; z4];
		else
			matr4moments = [matr4moments; get4scalMoments(tmp)];
		end;
	end;
	vec = [vec matr4moments_to_hist(matr4moments)];
	matr4moments = [];

	% horizontal comb ...
	for ii=(1-m):(round(m/10)):m, tmp = a(abs((I+ii)-m2)<1);
		if isempty(tmp)
			matr4moments = [matr4moments; z4]; 
		else
			matr4moments = [matr4moments; get4scalMoments(tmp)];
		end
	end
	vec = [vec matr4moments_to_hist(matr4moments)];
	vec = uint16(vec);
return;

%:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% Convert a 4-column-wise data into 4 histograms as following:
% [ meanHist stdHist skewHist kurtHist ]
% So, each column results in 3-bin hist, totaling in 1x12 vector
function vec = matr4moments_to_hist(matr4moments),
	nbins = 3;
	vec = [];
	for ii = 1:size(matr4moments,2)
		vec = [vec hist(matr4moments(:,ii),nbins)];
	end;
return;

%:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
% compute mean, std, skewness, kurtosis of a vector
function m4 = get4scalMoments(vec),
	ss = std(vec); 
	if ~ss
		m4 = [mean(vec) ss 0 0]; 
	else
		m4 = [mean(vec) ss skewness(vec) kurtosis(vec)];
	end
return;
