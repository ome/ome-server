/*
	Translated from ImageJ Java Pluging into MATLAB MEX c code by
	Tom Macura <tmacura@nih.gov>
	July 21st, 2006
*/

/* G.Landini at bham ac uk
   30/Mar/2004 released
   03/Apr/2004 resolved ROI exiting
   07/Apr/2004 added Methyl Green DAB vectors
   08/Jul/2004 shortened the code
   01/Aug/2005 added fast red/blue/DAB vectors
   02/Nov/2005 changed code to work with image stacks (DLC - dchao at fhcrc org)
   02/Nov/2005 changed field names so user-defined colours can be set within 
               macros (DLC - dchao at fhcrc org)

   This plugin implements stain separation using the colour deconvolution
   method described in:

       Ruifrok AC, Johnston DA. Quantification of histological
       staining by color deconvolution. Analytical & Quantitative
       Cytology & Histology 2001; 23: 291-299.

   The code is based on "Color separation-30", a macro for NIH Image kindly provided
   by A.C. Ruifrok. Thanks Arnout!

   The plugin assumes images generated by color subtraction (i.e. light-absorbing dyes
   such as those used in bright field histology or ink on printed paper) but the dyes
   should not be neutral grey.

   I strongly suggest to read the paper reference above to understand how to determine
   new vectors and how the whole procedure works.

   The plugin works correctly when the background is neutral (white to light grey), 
   so background subtraction and colour correction must be applied to the images before 
   processing.
 
   The plugin provides a number of "bulit in" stain vectors some of which were determined
   experimentally in our lab (marked GL), but you may have to determine your own vectors to
   provide a more accurate stain separation, depending on the stains and methods you use.
   Ideally, vector determination should be done on slides stained with only one colour
   at a time (using the "From ROI" interactive option).
 
   The plugin takes an RGB image and returns three 8-bit images. If the specimen is
   stained with a 2 colour scheme (such as H & E) the 3rd image represents the
   complimentary of the first two colours (i.e. green).
  
   Please be *very* careful about how to interpret the results of colour deconvolution
   when analysing histological images.
   Most staining methods are not stochiometric and so intensity of the chromogen
   may not correlate well with the quantity of the reactants.
   This means that intensity of the colour may not be a good indicator of
   the amount of material stained.

   Read the paper!
*/

#include "mex.h"
#include "matrix.h"
#include <math.h>
#include <sys/types.h>
#include <string.h>

void mexFunction(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])
{
	const int* dims;
	const mxArray*  img_mxArray;
	const u_int8_t* img;
	u_int8_t* img_stain1;
	u_int8_t* img_stain2;
	u_int8_t* img_stain3;
	
	char* myStain;
	if (nrhs != 2)
		mexErrMsgTxt("\n [stain1, stain2, stain3] = colour_deconvolution (im, StainingUsed),\n\n"
		"This function takes an RGB image and returns three uint8 images with separated stains\n"
		"if the specimen is stained with a 2 colour scheme (such as H & E) the 3rd image\n"
		"represents the complimentary of the first two colours (i.e. green).\n"
		"StainingUsed can be a string equal to 'H&E', 'H DAB', 'H&E DAB', 'H AEC'\n"
		"'FastRed FastBlue DAB', 'Methyl Green DAB', 'Azan-Mallory','Alcian blue & H'\n"
		"'H PAS','RGB','CMY'");
	else if (nlhs < 1)
		mexErrMsgTxt ("colour_deconvolution returns at-least a single output.\n");
	
	if (!mxIsUint8(prhs[0]))
		mexErrMsgTxt("mb_texture requires the first input be uint8\n");
	
	img = (u_int8_t*) mxGetData(prhs[0]);
	dims = mxGetDimensions(prhs[0]);
	if (!(dims[0] > 1) || !(dims[1] > 1) || !(dims[2] == 3))
		mexErrMsgTxt("mb_texture requires an RGB input image, not a scalar.\n") ;
	
	/*
	  String [] stain={"From ROI", "H&E", "H DAB","FastRed FastBlue DAB","Methyl Green DAB", "H&E DAB", "H AEC","Azan-Mallory","Alcian blue & H","H PAS","RGB","CMY", "User values"};
	*/
	myStain = mxArrayToString(prhs[1]);
	
	double leng, A, V, C, min, log255=log(255.0);
	int i,j;
	double MODx[3];
	double MODy[3];
	double MODz[3];
	double cosx[3];
	double cosy[3];
	double cosz[3];
	double len[3];
	double q[9];
	int rLUT[255];
	int gLUT[255];
	int bLUT[255];

	if (!strcmp(myStain,"H&E")){
		/* GL Haem matrix */
		MODx[0]= 0.644211; /* 0.650; */
		MODy[0]= 0.716556; /* 0.704; */
		MODz[0]= 0.266844; /* 0.286; */
		/* GL Eos matrix */
		MODx[1]= 0.092789; /* 0.072; */
		MODy[1]= 0.954111; /* 0.990; */
		MODz[1]= 0.283111; /* 0.105; */
		/*  Zero matrix */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"H DAB")){
		/* 3,3-diamino-benzidine tetrahydrochloride
		   Haem matrix */
		MODx[0]= 0.650;
		MODy[0]= 0.704;
		MODz[0]= 0.286;
		/* DAB matrix */
		MODx[1]= 0.268;
		MODy[1]= 0.570;
		MODz[1]= 0.776;
		/* Zero matrix */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"FastRed FastBlue DAB")){
		/* fast red */
		MODx[0]= 0.21393921;
		MODy[0]= 0.85112669;
		MODz[0]= 0.47794022;
		/* fast blue */
		MODx[1]= 0.74890292;
		MODy[1]= 0.60624161;
		MODz[1]= 0.26731082;
		/* dab */
		MODx[2]= 0.268;
		MODy[2]= 0.570;
		MODz[2]= 0.776;
	} else if (!strcmp(myStain,"Methyl Green DAB")){
		/* MG matrix (GL) */
		MODx[0]= 0.98003;
		MODy[0]= 0.144316;
		MODz[0]= 0.133146;
		/* DAB matrix */
		MODx[1]= 0.268;
		MODy[1]= 0.570;
		MODz[1]= 0.776;
		/* Zero matrix */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"H&E DAB")){
		/* Haem matrix */
		MODx[0]= 0.650;
		MODy[0]= 0.704;
		MODz[0]= 0.286;
		/* Eos matrix */
		MODx[1]= 0.072;
		MODy[1]= 0.990;
		MODz[1]= 0.105;
		/* DAB matrix */
		MODx[2]= 0.268;
		MODy[2]= 0.570;
		MODz[2]= 0.776;
	} else if (!strcmp(myStain,"H AEC")){
		/* 3-amino-9-ethylcarbazole
	     	   Haem matrix */
		MODx[0]= 0.650;
		MODy[0]= 0.704;
		MODz[0]= 0.286;
		/* AEC matrix */
		MODx[1]= 0.2743;
		MODy[1]= 0.6796;
		MODz[1]= 0.6803;
		/* Zero matrix */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"Azan-Mallory")){
		/* Azocarmine and Aniline Blue (AZAN)
		   GL Blue matrix */
		MODx[0]= .853033;
		MODy[0]= .508733;
		MODz[0]= .112656;
		/* GL Red matrix */
		MODx[1]= 0.070933;
		MODy[1]= 0.977311;
		MODz[1]= 0.198067;
		/* Orange matrix (not set yet, currently zero) */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"Alcian blue & H")){
		/* GL Alcian Blue matrix */
		MODx[0]= 0.874622;
		MODy[0]= 0.457711;
		MODz[0]= 0.158256;
		/* GL Haematox after PAS matrix */
		MODx[1]= 0.552556;
		MODy[1]= 0.7544;
		MODz[1]= 0.353744;
		/* Zero matrix */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"H PAS")){
		/* GL Haem matrix */
		MODx[0]= 0.644211; /* 0.650; */
		MODy[0]= 0.716556; /* 0.704; */
		MODz[0]= 0.266844; /* 0.286; */
		/* GL PAS matrix */
		MODx[1]= 0.175411;
		MODy[1]= 0.972178;
		MODz[1]= 0.154589;
		/* Zero matrix */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"RGB")){
		/* R */
		MODx[0]= 0.0;
		MODy[0]= 1.0;
		MODz[0]= 1.0;
		/* G */
		MODx[1]= 1.0;
		MODy[1]= 0.0;
		MODz[1]= 1.0;
		/* B */
		MODx[2]= 1.0;
		MODy[2]= 1.0;
		MODz[2]= 0.0;
	} else if (!strcmp(myStain,"CMY")){
		/* C */
		MODx[0]= 1.0;
		MODy[0]= 0.0;
		MODz[0]= 0.0;
		/* M */
		MODx[1]= 0.0;
		MODy[1]= 1.0;
		MODz[1]= 0.0;
		/* Y */
		MODx[2]= 0.0;
		MODy[2]= 0.0;
		MODz[2]= 1.0;
	} else {
		char err_str[128];
		sprintf(err_str, "colour_deconvolution doesn't support the stain %s", myStain);
		mexErrMsgTxt(err_str);
	}
	
	/**********************************************************************
	*  Convert the vectors into LUTs
	***********************************************************************/
	for (i=0; i<3; i++){
		/* normalise vector length */
		cosx[i]=cosy[i]=cosz[i]=0.0;
		len[i]=sqrt(MODx[i]*MODx[i] + MODy[i]*MODy[i] + MODz[i]*MODz[i]);
		if (len[i] != 0.0){
			cosx[i]= MODx[i]/len[i];
			cosy[i]= MODy[i]/len[i];
			cosz[i]= MODz[i]/len[i];
		}
	}

	/* translation matrix */
	if (cosx[1]==0.0){ /* 2nd colour is unspecified */
		if (cosy[1]==0.0){
			if (cosz[1]==0.0){
				cosx[1]=cosz[0];
				cosy[1]=cosx[0];
				cosz[1]=cosy[0];
			}	
		}
	}

	if (cosx[2]==0.0){ /* 3rd colour is unspecified */
		if (cosy[2]==0.0){
			if (cosz[2]==0.0){
				if ((cosx[0]*cosx[0] + cosx[1]*cosx[1])> 1)
					cosx[2]=0.0;
				else
					cosx[2]=sqrt(1.0-(cosx[0]*cosx[0])-(cosx[1]*cosx[1]));

				if ((cosy[0]*cosy[0] + cosy[1]*cosy[1])> 1)
					cosy[2]=0.0;
				else
					cosy[2]=sqrt(1.0-(cosy[0]*cosy[0])-(cosy[1]*cosy[1]));

				if ((cosz[0]*cosz[0] + cosz[1]*cosz[1])> 1)
					cosz[2]=0.0;
				else
					cosz[2]=sqrt(1.0-(cosz[0]*cosz[0])-(cosz[1]*cosz[1]));
			}
		}
	}

	leng= sqrt(cosx[2]*cosx[2] + cosy[2]*cosy[2] + cosz[2]*cosz[2]);

	cosx[2]= cosx[2]/leng;
	cosy[2]= cosy[2]/leng;
	cosz[2]= cosz[2]/leng;

	/* matrix inversion */
	A = cosy[1] - cosx[1] * cosy[0] / cosx[0];
	V = cosz[1] - cosx[1] * cosz[0] / cosx[0];
	C = cosz[2] - cosy[2] * V/A + cosx[2] * (V/A * cosy[0] / cosx[0] - cosz[0] / cosx[0]);
	q[2] = (-cosx[2] / cosx[0] - cosx[2] / A * cosx[1] / cosx[0] * cosy[0] / cosx[0] + cosy[2] / A * cosx[1] / cosx[0]) / C;
	q[1] = -q[2] * V / A - cosx[1] / (cosx[0] * A);
	q[0] = 1.0 / cosx[0] - q[1] * cosy[0] / cosx[0] - q[2] * cosz[0] / cosx[0];
	q[5] = (-cosy[2] / A + cosx[2] / A * cosy[0] / cosx[0]) / C;
	q[4] = -q[5] * V / A + 1.0 / A;
	q[3] = -q[4] * cosy[0] / cosx[0] - q[5] * cosz[0] / cosx[0];
	q[8] = 1.0 / C;
	q[7] = -q[8] * V / A;
	q[6] = -q[7] * cosy[0] / cosx[0] - q[8] * cosz[0] / cosx[0];

	for (i=0; i<3; i++) {
		for (j=0; j<256; j++) {
			rLUT[255-j]=(int)(255.0 - (double)j * cosx[i]);
			gLUT[255-j]=(int)(255.0 - (double)j * cosy[i]);
			bLUT[255-j]=(int)(255.0 - (double)j * cosz[i]);
		}
	}
	
	/************************************************************************
	* Apply the LUTs to the original RGB image to make some new stain images
	*************************************************************************/
	plhs[0] = mxCreateNumericMatrix(dims[0], dims[1], mxUINT8_CLASS, mxREAL);
	img_stain1 = (u_int8_t*) mxGetData(plhs[0]);
	plhs[1] = mxCreateNumericMatrix(dims[0], dims[1], mxUINT8_CLASS, mxREAL);
	img_stain2 = (u_int8_t*) mxGetData(plhs[1]);
	plhs[2] = mxCreateNumericMatrix(dims[0], dims[1], mxUINT8_CLASS, mxREAL);
	img_stain3 = (u_int8_t*) mxGetData(plhs[2]);
	
	int imagesize = dims[0] * dims[1];
	for (i=0; i<imagesize;i++){
		/* log transform the RGB data */
		int R = img[i];
		int G = img[i+imagesize];
		int B = img[i+2*imagesize];
		double Rlog = -((255.0*log(((double)R+1)/255.0))/log255);
		double Glog = -((255.0*log(((double)G+1)/255.0))/log255);
		double Blog = -((255.0*log(((double)B+1)/255.0))/log255);
		
		for (j=0; j<3; j++){
			/* rescale to match original paper values */
			double Rscaled = Rlog * q[j*3];
			double Gscaled = Glog * q[j*3+1];
			double Bscaled = Blog * q[j*3+2];
			
			double output = exp(-((Rscaled + Gscaled + Bscaled) - 255.0) * log255 / 255.0);
			if(output>255) output=255;
		
			if (j==0) {
				img_stain1[i] = (u_int8_t)(floor(output+.5));
			} else if (j==1) {
				img_stain2[i] = (u_int8_t)(floor(output+.5));
			} else {
				img_stain3[i] = (u_int8_t)(floor(output+.5));
			}
		}
	}
}
