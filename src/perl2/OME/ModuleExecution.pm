# OME/Analysis.pm

# Copyright (C) 2002 Open Microscopy Environment, MIT
# Author:  Douglas Creager <dcreager@alum.mit.edu>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


package OME::Analysis;

=head1 NAME

OME::Analysis - execution of an analysis module

OME::Analysis::ActualInput - how an input to an analysis module was
satisfied

=head1 DESCRIPTION

The C<Analysis> class represents an execution of an OME analysis
module against a dataset of images.  Each actual execution of a module
is represented by exactly one C<Analysis>.  If the results of a module
execution are reused during the future execution of an analysis chain,
no new C<Analysis> is created (although a new
C<AnalysisExecution::NodeExecution> is created).

C<Analyses> have a notion of <i>dependence</i> which help the analysis
engine determine when analysis results are eligible for reuse.  Each
C<Analysis> has a dependence of Global, Dataset, or Image.

An dependence of Image signifies that the results produced by an
analysis module for a given image are independent of which other
images are in the dataset being analyzed.  This allows the results of
this C<Analysis> to be reused, even if the dataset being executed in
the future is different.

A dependence of Dataset, on the other hand, signifies that the results
are not independent on a per-image basis.  Attributes created by a
dataset-dependent C<Analysis> could only be reused if the future
analysis is being performed against the exact same dataset.

A dependence of Global is rarely seen, and is only possible if the
module generates global outputs.  In this case, the distinction
between image- and dataset-dependence has no meaning.

=head2 C<OME::Analysis::ActualInput>

The C<ActualInput> class specifies where the values for an analysis
module's inputs came from.  Each of the module's formal inputs has a
single C<ActualInput> for each execution of the module.

The module's input is specified by the C<Analysis> that "feeds" it.
All of the attributes of the formal input's semantic type generated by
the input analysis are collected and presented as input to the current
analysis.

=cut

use strict;
our $VERSION = '1.0';

use OME::DBObject;
use base qw(OME::DBObject);

__PACKAGE__->AccessorNames({
    program_id => 'program',
    dataset_id => 'dataset'
    });

__PACKAGE__->table('analyses');
__PACKAGE__->sequence('analysis_seq');
__PACKAGE__->columns(Primary => qw(analysis_id));
__PACKAGE__->columns(Essential => qw(program_id dependence
				     dataset_id));
__PACKAGE__->columns(Timing => qw(timestamp status total_time
                                  attribute_create_time attribute_db_time
                                  attribute_sort_time));
__PACKAGE__->hasa('OME::Program' => qw(program_id));
__PACKAGE__->hasa('OME::Dataset' => qw(dataset_id));
__PACKAGE__->has_many('inputs','OME::Analysis::ActualInput' => qw(analysis_id));
#__PACKAGE__->has_many('outputs','OME::Analysis::ActualOutput' => qw(analysis_id));

=head1 METHODS (C<Analysis>)

The following methods are available to C<Analysis> in addition to
those defined by L<OME::DBObject>.

=head2 program

	my $module = $analysis->program();
	$analysis->program($module);

Returns or sets the analysis module that was executed.

=head2 dataset

	my $dataset = $analysis->dataset();
	$analysis->dataset($dataset);

Returns or sets the dataset that was analyzed.

=head2 dependence

	my $dependence = $analysis->dependence();
	$analysis->dependence($dependence);

Returns or sets the dependence of this analysis.  This will be either
'G', 'D', or 'I'.

=head2 timestamp

	my $timestamp = $analysis->timestamp();
	$analysis->timestamp($timestamp);

Returns or sets when the analysis was completed.

=head2 status

	my $status = $analysis->status();
	$analysis->status($status);

Returns or sets the analysis's status.  Current possible values are:

=over

=item C<RUNNING>

The module is still executing.

=item C<FINISHED>

The module has finished, and all results are in the database.

=item Anything else

There was an error executing the module.  The return value is the
error string generated.

=back

=head2 inputs

	my @inputs = $analysis->inputs();
	my $input_iterator = $analysis->inputs();

Returns or iterates, depending on context, a list of all of the
C<ActualInputs> associated with this analysis.

=cut


package OME::Analysis::ActualInput;

use strict;
our $VERSION = '1.0';

use OME::DBObject;
require OME::Program;
use base qw(OME::DBObject);

use fields qw(_attribute);

__PACKAGE__->AccessorNames({
    analysis_id       => 'analysis',
    formal_input_id   => 'formal_input',
    input_analysis_id => 'input_analysis'
    });

__PACKAGE__->table('actual_inputs');
__PACKAGE__->sequence('actual_input_seq');
__PACKAGE__->columns(Primary => qw(actual_input_id));
__PACKAGE__->columns(Essential => qw(input_analysis_id analysis_id formal_input_id));
__PACKAGE__->hasa('OME::Analysis' => qw(analysis_id));
__PACKAGE__->hasa('OME::Program::FormalInput' => qw(formal_input_id));
__PACKAGE__->hasa('OME::Analysis' => qw(input_analysis_id));

=head1 METHODS (C<ActualInput>)

The following methods are available to C<ActualInput> in addition to
those defined by L<OME::DBObject>.

=head2 analysis

	my $analysis = $input->analysis();
	$input->analysis($analysis);

Returns the analysis that this actual input is associated with.

=head2 input_analysis

	my $input_analysis = $input->input_analysis();
	$input->input_analysis($input_analysis);

Returns the analysis that provides this actual input with data.

=head2 formal_input

	my $formal_input = $input->formal_input();
	$input->formal_input($formal_input);

Returns the formal input that this actual input provides data for.

=cut

sub attribute {
    my $self = shift;
    my $formalInput = $self->formal_input();
    my $columnType = $formalInput->column_type();
    my $dataType = $columnType->datatype();
    my $attributePackage = $dataType->getAttributePackage();

    if (@_) {
       	# We are setting the attribute; make sure it is of the
	# appropriate data type, and that it has an ID.

	my $result = $self->{_attribute};
	my $attribute = shift;
	die "This attribute is not of the correct type."
	    unless ($attribute->isa($attributePackage));
	die "This attribute does not have an ID."
	    unless (defined $attribute->ID());
	$self->attribute_id($attribute->ID());
	$self->{_attribute} = $attribute;
	return $result;
    } else {
	my $attribute = $self->{_attribute};
	if (!defined $attribute) {
	  $attribute = $self->Session()->Factory()->loadObject($attributePackage,
						    $self->attribute_id());
	  $self->{_attribute} = $attribute;
	}
	return $attribute;
    }
}


# package OME::Analysis::ActualOutput;

# use strict;
# our $VERSION = '1.0';

# use OME::DBObject;
# require OME::Program;
# use base qw(OME::DBObject);

# __PACKAGE__->AccessorNames({
#     analysis_id      => 'analysis',
#     formal_output_id => 'formal_output'
#     });

# __PACKAGE__->table('actual_outputs');
# __PACKAGE__->sequence('actual_output_seq');
# __PACKAGE__->columns(Primary => qw(actual_output_id));
# __PACKAGE__->columns(Essential => qw(analysis_id formal_output_id));
# __PACKAGE__->hasa('OME::Analysis' => qw(analysis_id));
# __PACKAGE__->hasa('OME::Program::FormalOutput' => qw(formal_output_id));



1;

__END__

=head1 AUTHOR

Douglas Creager <dcreager@alum.mit.edu>,
Open Microscopy Environment, MIT

=cut

