# OME/module_execution.pm

# Copyright (C) 2002 Open Microscopy Environment, MIT
# Author:  Douglas Creager <dcreager@alum.mit.edu>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


package OME::ModuleExecution;

=head1 NAME

OME::ModuleExecution - execution of an module_execution module

OME::ModuleExecution::ActualInput - how an input to an module_execution module was
satisfied

=head1 DESCRIPTION

The C<module_execution> class represents an execution of an OME module_execution
module against a dataset of images.  Each actual execution of a module
is represented by exactly one C<module_execution>.  If the results of a module
execution are reused during the future execution of an module_execution chain,
no new C<module_execution> is created (although a new
C<AnalysisExecution::NodeExecution> is created).

C<Analyses> have a notion of <i>dependence</i> which help the module_execution
engine determine when module_execution results are eligible for reuse.  Each
C<module_execution> has a dependence of Global, Dataset, or Image.

An dependence of Image signifies that the results produced by an
analysis module for a given image are independent of which other
images are in the dataset being analyzed.  This allows the results of
this C<module_execution> to be reused, even if the dataset being executed in
the future is different.

A dependence of Dataset, on the other hand, signifies that the results
are not independent on a per-image basis.  Attributes created by a
dataset-dependent C<module_execution> could only be reused if the future
analysis is being performed against the exact same dataset.

A dependence of Global is rarely seen, and is only possible if the
module generates global outputs.  In this case, the distinction
between image- and dataset-dependence has no meaning.

=head2 C<OME::ModuleExecution::ActualInput>

The C<ActualInput> class specifies where the values for an module_execution
module's inputs came from.  Each of the module's formal inputs has a
single C<ActualInput> for each execution of the module.

The module's input is specified by the C<module_execution> that "feeds" it.
All of the attributes of the formal input's semantic type generated by
the input module_execution are collected and presented as input to the current
analysis.

=cut

use strict;
our $VERSION = '1.0';

use OME::DBObject;
use base qw(OME::DBObject);

__PACKAGE__->AccessorNames({
    module_id => 'module',
    dataset_id => 'dataset'
    });

__PACKAGE__->table('module_executions');
__PACKAGE__->sequence('module_execution_seq');
__PACKAGE__->columns(Primary => qw(module_execution_id));
__PACKAGE__->columns(Essential => qw(module_id dependence
				     dataset_id));
__PACKAGE__->columns(Timing => qw(timestamp status total_time
                                  attribute_create_time attribute_db_time
                                  attribute_sort_time));
__PACKAGE__->hasa('OME::Module' => qw(module_id));
__PACKAGE__->hasa('OME::Dataset' => qw(dataset_id));
__PACKAGE__->has_many('inputs','OME::ModuleExecution::ActualInput' => qw(module_execution_id));

=head1 METHODS (C<module_execution>)

The following methods are available to C<module_execution> in addition to
those defined by L<OME::DBObject>.

=head2 module

	my $module = $module_execution->module();
	$module_execution->module($module);

Returns or sets the module_execution module that was executed.

=head2 dataset

	my $dataset = $module_execution->dataset();
	$module_execution->dataset($dataset);

Returns or sets the dataset that was analyzed.

=head2 dependence

	my $dependence = $module_execution->dependence();
	$module_execution->dependence($dependence);

Returns or sets the dependence of this module_execution.  This will be either
'G', 'D', or 'I'.

=head2 timestamp

	my $timestamp = $module_execution->timestamp();
	$module_execution->timestamp($timestamp);

Returns or sets when the module_execution was completed.

=head2 status

	my $status = $module_execution->status();
	$module_execution->status($status);

Returns or sets the module_execution's status.  Current possible values are:

=over

=item C<RUNNING>

The module is still executing.

=item C<FINISHED>

The module has finished, and all results are in the database.

=item Anything else

There was an error executing the module.  The return value is the
error string generated.

=back

=head2 inputs

	my @inputs = $module_execution->inputs();
	my $input_iterator = $module_execution->inputs();

Returns or iterates, depending on context, a list of all of the
C<ActualInputs> associated with this module_execution.

=cut


package OME::ModuleExecution::ActualInput;

use strict;
our $VERSION = '1.0';

use OME::DBObject;
require OME::Module;
use base qw(OME::DBObject);

use fields qw(_attribute);

__PACKAGE__->AccessorNames({
    module_execution_id       => 'module_execution',
    formal_input_id   => 'formal_input',
    input_module_execution_id => 'input_module_execution'
    });

__PACKAGE__->table('actual_inputs');
__PACKAGE__->sequence('actual_input_seq');
__PACKAGE__->columns(Primary => qw(actual_input_id));
__PACKAGE__->columns(Essential => qw(input_module_execution_id module_execution_id formal_input_id));
__PACKAGE__->hasa('OME::ModuleExecution' => qw(module_execution_id));
__PACKAGE__->hasa('OME::Module::FormalInput' => qw(formal_input_id));
__PACKAGE__->hasa('OME::ModuleExecution' => qw(input_module_execution_id));

=head1 METHODS (C<ActualInput>)

The following methods are available to C<ActualInput> in addition to
those defined by L<OME::DBObject>.

=head2 module_execution

	my $module_execution = $input->module_execution();
	$input->module_execution($module_execution);

Returns the module_execution that this actual input is associated with.

=head2 input_module_execution

	my $input_module_execution = $input->input_module_execution();
	$input->input_module_execution($input_module_execution);

Returns the module_execution that provides this actual input with data.

=head2 formal_input

	my $formal_input = $input->formal_input();
	$input->formal_input($formal_input);

Returns the formal input that this actual input provides data for.

=cut

sub attribute {
    my $self = shift;
    my $formalInput = $self->formal_input();
    my $columnType = $formalInput->column_type();
    my $dataType = $columnType->datatype();
    my $attributePackage = $dataType->getAttributePackage();

    if (@_) {
       	# We are setting the attribute; make sure it is of the
	# appropriate data type, and that it has an ID.

	my $result = $self->{_attribute};
	my $attribute = shift;
	die "This attribute is not of the correct type."
	    unless ($attribute->isa($attributePackage));
	die "This attribute does not have an ID."
	    unless (defined $attribute->ID());
	$self->attribute_id($attribute->ID());
	$self->{_attribute} = $attribute;
	return $result;
    } else {
	my $attribute = $self->{_attribute};
	if (!defined $attribute) {
	  $attribute = $self->Session()->Factory()->loadObject($attributePackage,
						    $self->attribute_id());
	  $self->{_attribute} = $attribute;
	}
	return $attribute;
    }
}


1;

__END__

=head1 AUTHOR

Douglas Creager <dcreager@alum.mit.edu>,
Open Microscopy Environment, MIT

=cut

