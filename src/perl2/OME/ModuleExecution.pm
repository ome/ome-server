# OME/module_execution.pm

# Copyright (C) 2003 Open Microscopy Environment
# Author:  Douglas Creager <dcreager@alum.mit.edu>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


package OME::ModuleExecution;

=head1 NAME

OME::ModuleExecution - execution of an module_execution module

OME::ModuleExecution::ActualInput - how an input to an module_execution module was
satisfied

=head1 DESCRIPTION

The C<module_execution> class represents an execution of an OME module_execution
module against a dataset of images.  Each actual execution of a module
is represented by exactly one C<module_execution>.  If the results of a module
execution are reused during the future execution of an module_execution chain,
no new C<module_execution> is created (although a new
C<AnalysisExecution::NodeExecution> is created).

C<Analyses> have a notion of <i>dependence</i> which help the module_execution
engine determine when module_execution results are eligible for reuse.  Each
C<module_execution> has a dependence of Global, Dataset, or Image.

An dependence of Image signifies that the results produced by an
analysis module for a given image are independent of which other
images are in the dataset being analyzed.  This allows the results of
this C<module_execution> to be reused, even if the dataset being executed in
the future is different.

A dependence of Dataset, on the other hand, signifies that the results
are not independent on a per-image basis.  Attributes created by a
dataset-dependent C<module_execution> could only be reused if the future
analysis is being performed against the exact same dataset.

A dependence of Global is rarely seen, and is only possible if the
module generates global outputs.  In this case, the distinction
between image- and dataset-dependence has no meaning.

=head2 C<OME::ModuleExecution::ActualInput>

The C<ActualInput> class specifies where the values for an module_execution
module's inputs came from.  Each of the module's formal inputs has a
single C<ActualInput> for each execution of the module.

The module's input is specified by the C<module_execution> that "feeds" it.
All of the attributes of the formal input's semantic type generated by
the input module_execution are collected and presented as input to the current
analysis.

=cut

use strict;
our $VERSION = 2.000_000;

use OME::DBObject;
use base qw(OME::DBObject);

__PACKAGE__->newClass();
__PACKAGE__->setDefaultTable('module_executions');
__PACKAGE__->setSequence('module_execution_seq');
__PACKAGE__->addPrimaryKey('module_execution_id');
__PACKAGE__->addColumn(module_id => 'module_id');
__PACKAGE__->addColumn(module => 'module_id','OME::Module',
                       {
                        SQLType => 'integer',
                        Indexed => 1,
                        ForeignKey => 'modules',
                       });
__PACKAGE__->addColumn(dependence => 'dependence',
                       {
                        SQLType => 'char(1)',
                        NotNull => 1,
                        Check   => "(dependence in ('G','D','I'))",
                       });
__PACKAGE__->addColumn(dataset_id => 'dataset_id');
__PACKAGE__->addColumn(dataset => 'dataset_id','OME::Dataset',
                       {
                        SQLType => 'integer',
                        NotNull => 1,
                        Indexed => 1,
                        ForeignKey => 'datasets',
                       });
__PACKAGE__->addColumn(timestamp => 'timestamp',
                       {
                        SQLType => 'timestamp',
                        Default => 'now',
                       });
__PACKAGE__->addColumn(total_time => 'total_time',
                       {SQLType => 'float'});
__PACKAGE__->addColumn(attribute_sort_time => 'attribute_sort_time',
                       {SQLType => 'float'});
__PACKAGE__->addColumn(attribute_db_time => 'attribute_db_time',
                       {SQLType => 'float'});
__PACKAGE__->addColumn(attribute_create_time => 'attribute_create_time',
                       {SQLType => 'float'});
__PACKAGE__->addColumn(status => 'status',{SQLType => 'varchar(16)'});
__PACKAGE__->hasMany('inputs','OME::ModuleExecution::ActualInput' =>
                     'module_execution');

=head1 METHODS (C<module_execution>)

The following methods are available to C<module_execution> in addition to
those defined by L<OME::DBObject>.

=head2 module

	my $module = $module_execution->module();
	$module_execution->module($module);

Returns or sets the module_execution module that was executed.

=head2 dataset

	my $dataset = $module_execution->dataset();
	$module_execution->dataset($dataset);

Returns or sets the dataset that was analyzed.

=head2 dependence

	my $dependence = $module_execution->dependence();
	$module_execution->dependence($dependence);

Returns or sets the dependence of this module_execution.  This will be either
'G', 'D', or 'I'.

=head2 timestamp

	my $timestamp = $module_execution->timestamp();
	$module_execution->timestamp($timestamp);

Returns or sets when the module_execution was completed.

=head2 status

	my $status = $module_execution->status();
	$module_execution->status($status);

Returns or sets the module_execution's status.  Current possible values are:

=over

=item C<RUNNING>

The module is still executing.

=item C<FINISHED>

The module has finished, and all results are in the database.

=item Anything else

There was an error executing the module.  The return value is the
error string generated.

=back

=head2 inputs

	my @inputs = $module_execution->inputs();
	my $input_iterator = $module_execution->inputs();

Returns or iterates, depending on context, a list of all of the
C<ActualInputs> associated with this module_execution.

=cut


package OME::ModuleExecution::ActualInput;

use strict;
our $VERSION = 2.000_000;

use OME::DBObject;
require OME::Module;
use base qw(OME::DBObject);

use fields qw(_attribute);

__PACKAGE__->newClass();
__PACKAGE__->setDefaultTable('actual_inputs');
__PACKAGE__->setSequence('actual_input_seq');
__PACKAGE__->addPrimaryKey('actual_input_id');
__PACKAGE__->addColumn(module_execution_id => 'module_execution_id');
__PACKAGE__->addColumn(module_execution => 'module_execution_id',
                       'OME::ModuleExecution',
                       {
                        SQLType => 'integer',
                        NotNull => 1,
                        Indexed => 1,
                        ForeignKey => 'module_executions',
                       });
__PACKAGE__->addColumn(formal_input_id => 'formal_input_id');
__PACKAGE__->addColumn(formal_input => 'formal_input_id',
                       'OME::Module::FormalInput',
                       {
                        SQLType => 'integer',
                        NotNull => 1,
                        Indexed => 1,
                        ForeignKey => 'formal_inputs',
                       });
__PACKAGE__->addColumn(input_module_execution_id => 'input_module_execution_id');
__PACKAGE__->addColumn(input_module_execution => 'input_module_execution_id',
                       'OME::ModuleExecution',
                       {
                        SQLType => 'integer',
                        NotNull => 1,
                        Indexed => 1,
                        ForeignKey => 'module_executions',
                       });

=head1 METHODS (C<ActualInput>)

The following methods are available to C<ActualInput> in addition to
those defined by L<OME::DBObject>.

=head2 module_execution

	my $module_execution = $input->module_execution();
	$input->module_execution($module_execution);

Returns the module_execution that this actual input is associated with.

=head2 input_module_execution

	my $input_module_execution = $input->input_module_execution();
	$input->input_module_execution($input_module_execution);

Returns the module_execution that provides this actual input with data.

=head2 formal_input

	my $formal_input = $input->formal_input();
	$input->formal_input($formal_input);

Returns the formal input that this actual input provides data for.

=cut


package OME::ModuleExecution::SemanticTypeOutput;

use strict;
our $VERSION = 2.000_000;

use OME::DBObject;
use base qw(OME::DBObject);

__PACKAGE__->newClass();
__PACKAGE__->setDefaultTable('semantic_type_outputs');
__PACKAGE__->setSequence('semantic_type_output_seq');
__PACKAGE__->addPrimaryKey('semantic_type_output_id');
__PACKAGE__->addColumn(module_execution_id => 'module_execution_id');
__PACKAGE__->addColumn(module_execution => 'module_execution_id',
                       'OME::ModuleExecution',
                       {
                        SQLType => 'integer',
                        NotNull => 1,
                        ForeignKey => 'module_executions',
                       });
__PACKAGE__->addColumn(semantic_type_id => 'semantic_type_id');
__PACKAGE__->addColumn(semantic_type => 'semantic_type_id',
                       'OME::SemanticType',
                       {
                        SQLType => 'integer',
                        NotNull => 1,
                        ForeignKey => 'module_executions',
                       });


1;

__END__

=head1 AUTHOR

Douglas Creager <dcreager@alum.mit.edu>,
Open Microscopy Environment, MIT

=cut

