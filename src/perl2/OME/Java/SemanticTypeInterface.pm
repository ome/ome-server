# OME/Java/SemanticTypeInterface.pm

#-------------------------------------------------------------------------------
#
# Copyright (C) 2003 Open Microscopy Environment
#       Massachusetts Institute of Technology,
#       National Institutes of Health,
#       University of Dundee
#
#
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#-------------------------------------------------------------------------------




#-------------------------------------------------------------------------------
#
# Written by:    Douglas Creager <dcreager@alum.mit.edu>
#
#-------------------------------------------------------------------------------


package OME::Java::SemanticTypeInterface;

=head1 NAME

OME::Analysis::Engine - OME analysis subsystem

=cut

use strict;
use OME;
our $VERSION = $OME::VERSION;

use File::Spec;
use File::Path;
use IO::Handle;
use IO::File;

use OME::Session;
use OME::SemanticType;
use OME::LSID;
use OME::Tasks::LSIDManager;

use OME::Java::DTOInterface;

=head1 SYNOPSIS

	OME::Java::SemanticTypeInterface->
	    writeInterfaces(\@semantic_types,%options);

=head1 DESCRIPTION

This class contains methods for auto-generating Java interfaces for
OME semantic types.  Java client code can then be written and compiled
against these interfaces.  B<TODO>: We will include in the new remote
interface the ability to use Java dynamic proxies to automatically
generate data objects which conform to these interfaces.

=head1 SEMANTIC TYPE INTERFACES

The Java interface generated by this class is very straightforward.
It will contain accessor and mutator methods for each of the elements
defined by the semantic type.  The names of the elements should be
standard alphanumeric characters, but if they do contain other
characters, those will be mapped into underscores.

Convention dictates that semantic type and element names be
hypercapitalized (e.g., Name, Address, PhoneNumber).  Since this is
the same convention for Java class names, the interface will be named
C<org.openmicroscopy.st.I<[semantic type name]>>.  It also allows the
method names to be formed trivially by prepending "get", "set", or
"is" as appropriate.  If the element is of boolean type, any leading
"Is" is stripped from the name (to prevent accessors named, for
instance, "isIsLocal").

=head2 Semantic type conflicts

There is, of course, the possibility that two different OME
installations will define logically distinct semantic types with the
same name.  Unfortunately, that means that the Java interfaces created
by this class will have the same name, but different definitions.

Code written against one of the interfaces will compile correctly, but
might generate incorrect results when connected to an OME database
with a different definition of the corresponding semantic type.

(B<NOTE>: This list is hypothetical, and based on a presumed
Map-backed view proxy implementation of the ST interfaces.)

=over

=item 1.

Elements in the Java interface but not in the semantic type would seem
to be populated with null values when read from the database.  Changes
to these elements would work within the context of the active Java
application (since it would just be modifying an in-memory Map), but
an error would be generated if the code tried to write these changes
back to the database.  (The underlying DBObject implementation would
complain about the unknown keys in the hash.)

=item 2.

For elements that happened to have the same name and type in both ST
definitions, both the accessors and mutators would work correctly.

=item 3.

Elements in the semantic type but not in the Java interface would be
inaccessible from the Java code.

=back

Luckily, the XML representation of a semantic type has an LSID, which
is guaranteed to be unique.  Therefore, the writeInterfaces method
will create additional Java interfaces for each LSID.  An ST's LSID
has the form

	urn:lsid:[LSID authority]:SemanticType:[number]:[db instance]

The LSID authority looks like a hostname, and has the same function as
a package name in Java -- it just defines a namespace.  The number is
supposed to be a positive integer unique within the purview of the
LSID authority.  The database instance is an alphanumeric string that
is supposed to be unique between different OME installations on the
same computer.  Given this, each LSID corresponds to a unique Java
fully-qualified name (FQN):

	org.openmicroscopy.st.lsid.[LSID authority].db[db instance].LSID[number]

Therefore, the writeInterfaces method will create two interfaces for
each semantic type -- one for its LSID (which declares no methods),
and one for the type itself (which declares methods for its elements,
as described above).  The semantic type interface is declared to be a
subinterface of the LSID interface.

This setup allows Java client code to worry about the uniqueness of
semantic types only as necessary.  If desired, the code can be written
to the semantic type interfaces, without worrying about type
conflicts.  If the code happens to connect to a conflicting OME
installation, the code (or the user) must be prepared to deal with the
error conditions described above.

On the other hand, if the code is intended to connect to widely
varying OME installations, the Java code can use the standard Java
type-checking operator to enforce the use of a specific semantic type.
For instance, you can verify that an attribute is an instance of the
core Repository semantic type (and not a different type which happens
to also be named "Repository") with the following code:

	import org.openmicroscopy.st.Repository;
	import org.openmicroscopy.st.lsid.openmicroscopy.org.LSID1;

	[ snip ]

	Repository repository = (Repository) factory.
	    loadAttribute(Repository.class,1);

	if (!repostory instanceof LSID1)
	    throw new Exception("Conflicting semantic types!");

=cut

my %options;
my $username = getpwuid($<);
my $now;

sub openHandle ($$) {
    my ($subdir,$filename) = @_;
    my $fh;

    if (exists $options{OutputDirectory}) {
        my $outdir = $options{OutputDirectory};
        my $fulldir = File::Spec->catdir($outdir,$subdir);
        mkpath($fulldir);
        my $path = File::Spec->catfile($fulldir,$filename);
        $fh = IO::File->new($path,'w');
    } else {
        $fh = IO::Handle->new_from_fd('STDOUT','a');
        my $path = File::Spec->catfile($subdir,$filename);
        print $fh "\n*****\n$path\n\n";
    }

    return $fh;
}

my %JAVA_TYPES = (
                  boolean => 'boolean',
                  string  => 'String',
                  float   => 'float',
                  double  => 'double',
                  integer => 'int',
                 );

my %MDTO_ACCESSORS = (
                      boolean => 'getBooleanElement',
                      string  => 'getStringElement',
                      float   => 'getFloatElement',
                      double  => 'getDoubleElement',
                      integer => 'getIntElement',
                     );

my %MDTO_VALUES = (
                   boolean => 'new Boolean(value)',
                   string  => 'value',
                   float   => 'new Float(value)',
                   double  => 'new Double(value)',
                   integer => 'new Integer(value)',
                  );

sub writeOneSemanticElement ($$) {
    my ($class_desc,$element) = @_;

    my $element_name = $element->name();
    my $data_column = $element->data_column();
    my $sql_type = $data_column->sql_type();

    $element_name =~ s/^Is// if $sql_type eq 'boolean';

    my $java_type;
    if ($sql_type eq 'reference') {
        $java_type = $data_column->reference_type();
    } else {
        $java_type = $JAVA_TYPES{$sql_type};
    }

    push @{$class_desc->{Fields}},
      $element_name, [$java_type, $element_name];
}

sub writeOneHasManyType ($$$) {
    my ($class_desc,$hasmany_type_name,$element_hash) = @_;
    my @element_names = sort keys %$element_hash;

    my $accessor_name = $hasmany_type_name;

    # Attempt to make the pluralization look somewhat correct
    $accessor_name =~ s/y$/ies/ or
    $accessor_name =~ s/s$/ses/ or
    $accessor_name =~ s/x$/xes/ or
    $accessor_name =~ s/$/s/;

    if (scalar(@element_names) == 1) {
        # If there's only one element in the has-many type which points
        # to this type, then we can give the accessor a simple name
        # (get[TypeName]s).

        push @{$class_desc->{Fields}},
          $accessor_name, ["List:${hasmany_type_name}", $accessor_name];
    } else {
        # Otherwise, we have to give the List accessors more complicated
        # names, so that the different has-many elements can be
        # distinguished. (get[TypeName]sBy[ElementName])

        foreach my $element_name (@element_names) {
            push @{$class_desc->{Fields}},
              "${accessor_name}By${element_name}",
              ["List:${hasmany_type_name}",
               "${accessor_name}By${element_name}"];
        }
    }
}

sub writeOneSemanticType ($) {
    my ($type) = @_;
    my $factory = OME::Session->instance()->Factory();

    # Generate the package, class, and file names for the type interface
    my $type_name = $type->name();
    my $type_classname = $type_name;
    $type_classname =~ s/\W/_/g;

    # Generate the package, class, and file names for the LSID interface
    #my $lsid_string = OME::Tasks::LSIDManager->getLSID($type);
    #my $lsid = OME::LSID->parseLSID($lsid_string);
    #my $lsid_classname = "LSID".$lsid->{local_id};
    #my $authority = lc($lsid->{authority});
    #$authority =~ s/[^\w\.]/_/g;
    #my $lsid_pkg = "org.openmicroscopy.lsid.${authority}.db".
    #  $lsid->{db_instance};
    #my $lsid_dir = $lsid_pkg;
    #$lsid_dir =~ s:\.:/:g;
    #my $lsid_fqclassname = "$lsid_pkg.${lsid_classname}";
    #my $lsid_filename = "${lsid_classname}.java";

    # Start the class definition hash

    my %class_desc;
    $class_desc{Package} = 'org.openmicroscopy.ds.st';
    $class_desc{Class} = $type_classname;

    # Look for reference elements, and if there are any, add them to the
    # list of ST's to import.

    my %import_types;

    foreach my $element ($type->semantic_elements()) {
        next if $element->data_column()->sql_type() ne 'reference';
        my $reftype = $element->data_column()->reference_type();
        $import_types{$reftype} = undef;
    }

    # Import any types which have reference elements to this type.
    # Also, sort these has-many elements by the semantic type which
    # contains them.

    my @hasmany_elements = $factory->
      findObjects('OME::SemanticType::Element',
                  {
                   'data_column.sql_type'       => 'reference',
                   'data_column.reference_type' => $type_name,
                  });
    my %hasmany_types;

    foreach my $element (@hasmany_elements) {
        my $hasmany_type = $element->semantic_type();
        my $hasmany_type_name = $hasmany_type->name();
        $import_types{$hasmany_type_name} = undef;
        $hasmany_types{$hasmany_type_name}->{$element->name()} = $element;
    }

    # Add import clauses for any types that are used by this interface

    if (scalar(keys %import_types) > 0) {
        my @imports = sort keys %import_types;
        $class_desc{ImportPackages}->{'org.openmicroscopy.ds.st'} = \@imports;
    }

    $class_desc{ImportPackages}->{'org.openmicroscopy.ds.dto'} =
      ['Attribute'];

    $class_desc{Superclass} = ['org.openmicroscopy.ds.dto','AttributeDTO'];

    $class_desc{Superinterfaces} =
      ['Attribute'];  #, $lsid_fqclassname];

    # Output an accessor and mutator for each semantic element

    foreach my $element ($type->semantic_elements()) {
        writeOneSemanticElement(\%class_desc,$element);
    }

    # Output a List accessor for each has-many element

    foreach my $hasmany_type_name (sort keys %hasmany_types) {
        writeOneHasManyType(\%class_desc,$hasmany_type_name,
                            $hasmany_types{$hasmany_type_name});
    }

    OME::Java::DTOInterface::writeOneClass(\%class_desc,\%options);

    # Output the entire LSID interface (it's very simple)

    #my $fh = openHandle($lsid_dir,$lsid_filename);
    #OME::Java::DTOInterface::writePreamble($fh,$lsid_fqclassname);

    #print $fh <<"JAVA";
#package ${lsid_pkg};
#
#public interface ${lsid_classname} { }
#JAVA

    #$fh->close();
}

sub writeInterfaces {
    my $proto = shift;

    my $semantic_types;
    my $param = shift;
    if (!ref($param)) {
        $semantic_types = [$param];
    } elsif (ref($param) eq 'ARRAY') {
        $semantic_types = $param;
    } else {
        die "writeInterfaces expects a semantic type or arrayref of semantic types";
    }

    $now = localtime();
    %options = @_;
    #OME::Tasks::LSIDManager->new();

    writeOneSemanticType($_) foreach @$semantic_types;
}

1;

__END__

=head1 AUTHOR

Douglas Creager <dcreager@alum.mit.edu>,
Open Microscopy Environment, MIT

=head1 SEE ALSO

L<OME>, http://www.openmicroscopy.org/

=cut


