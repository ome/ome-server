#!/usr/bin/perl -w
#-------------------------------------------------------------------------------
#
# Copyright (C) 2003 Open Microscopy Environment
#       Massachusetts Institute of Technology,
#       National Institutes of Health,
#       University of Dundee
#
#
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#-------------------------------------------------------------------------------




#-------------------------------------------------------------------------------
#
# Written by:  
#	Josiah Johnston <siah@nih.gov>
#
#-------------------------------------------------------------------------------


package OME::Web::GetGraphics;

use strict;
use vars qw($VERSION);
use OME;
$VERSION = $OME::VERSION;
use CGI;
use base qw{ OME::Web };

use Benchmark;

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self  = $class->SUPER::new(@_);

#    $self->{RequireLogin} = 0;

    return $self;
}

sub createOMEPage {
	my $self  = shift;
	my $cgi   = $self->CGI();
	my @params = $cgi->url_param();

	# Does this image ID exist? If it doesn't and we trap the error now, then we can display error message.
	my $ImageID   = $cgi->url_param('ImageID');
	my $DatasetID = $cgi->url_param('DatasetID');
	if( !defined $ImageID and !defined $DatasetID ) {
		die "Package needs either ImageID or DatasetID as url parameters. Neither was supplied. This message generated by ".(ref $self)."->createOMEpage().";
	}
	if( defined $ImageID ) {
		my $image = $self->Session->Factory()->loadObject("OME::Image",$ImageID);
		die "Could not load Image (ID=$ImageID) from database. This message generated by ".(ref $self)."->createOMEpage()."
			unless defined $image;
	}
	if( defined $DatasetID ) {
		my $dataset = $self->Session()->Factory()->loadObject("OME::Dataset",$DatasetID);
		die "Could not load Dataset (ID=$DatasetID) from database. This message generated by ".(ref $self)."->createOMEpage()."
			unless defined $dataset;
	}

	if ( $cgi->url_param('BuildSVGviewer') ) {
		return('SVG', $self->BuildSVGviewer());
	} elsif ( $cgi->url_param('DrawDatasetControl')) {
		return('HTML', $self->DrawDatasetControl());
	} elsif ( $cgi->url_param('ImageID')) {
		return('HTML', $self->DrawMainWindowSVGimage());
	} elsif ( $cgi->url_param('DatasetID')) {
		return('HTML', $self->DrawMainWindowSVGdataset());
	}
}


sub getPageTitle {
    return "OME - SVG viewer";
}

sub contentType {
my $self = shift;
	return $self->{contentType};
}

sub DrawMainWindowSVGimage {
my $self      = shift;
my $cgi       = $self->CGI();
my $ImageID   = $cgi->url_param("ImageID")  || die "\nImage id not supplied to GetGraphics.pm ";
my $DatasetID = $cgi->url_param("DatasetID");
my $HTML='';

	$self->{contentType} = 'text/html';
#	$HTML = $cgi->start_html(-title=>'OME SVG 2D Viewer');
# Add controls to change the displayed image. e.g. switch to previous or next image in a set.
# Embedding in frames instead of object allows Mozilla > v1 to run it. Keep if no problems w/ it.
	$HTML .= <<ENDHTML;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<title>OME SVG 2D Viewer</title>
	<frameset rows="*">
		<frame src="serve.pl?Page=OME::Web::GetGraphics&BuildSVGviewer=1&ImageID=$ImageID
ENDHTML
$HTML .= "&DatasetID=$DatasetID"
	if defined $DatasetID;
$HTML .= <<ENDHTML;
">
	</frameset>
</html>
ENDHTML

	return ($HTML);
}


sub DrawMainWindowSVGdataset {
my $self = shift;
my $cgi   = $self->CGI();
my $DatasetID = $cgi->url_param('DatasetID') || die "\nDataset id not supplied to GetGraphics.pm ";
my $HTML='';

	$self->{contentType} = 'text/html';
	$HTML .= <<ENDHTML;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<title>OME Dataset Viewer</title>
	<frameset rows="80,*" border="0">
		<frame name="controls" src="serve.pl?Page=OME::Web::GetGraphics&DrawDatasetControl=1&DatasetID=$DatasetID">
		<frame name="viewer" src="">
	</frameset>
</html>
ENDHTML

	return ($HTML);
}



sub DrawDatasetControl {
	my $self = shift;
	my $cgi   = $self->CGI();
	my $DatasetID = $cgi->url_param('DatasetID') || die "\nDataset id not supplied to GetGraphics.pm ";
	my $Dataset = $self->Session()->Factory()->loadObject("OME::Dataset",$DatasetID) || die "\nInvalide dataset id provided to GetGraphics.pm\n";
	my $imageMaps = $Dataset->image_links();
	my ($imageMap, @ImageIDs, $JSimageIDs, %ImagePaths, $JS_SetImagePathArray, $HTML);
	my $numImages = 0;
	my $datasetName = $Dataset->name();
	
    while (my $imageMap = $imageMaps->next()) {
		$numImages++;
		push (@ImageIDs, $imageMap->image()->image_id());
		$ImagePaths{ $imageMap->image()->image_id() } = $imageMap->image()->name();#getFullPath( $imageMap->image()->DefaultPixels() );
	}	
	$JSimageIDs = '['.join(',',@ImageIDs).']';
	$JS_SetImagePathArray = join( "\n", map( "imagePaths[$_] = '".$ImagePaths{$_}."';", keys %ImagePaths) );
	

	$self->{contentType} = 'text/html';
	$HTML = <<ENDHTML;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Select Image from Dataset</title>
<script language="JavaScript">
<!--

var imageIDs   = $JSimageIDs;
var imagePaths = new Array();
$JS_SetImagePathArray
var currentIndex;
var imageNumTextBox;
var imageInfoTextBox;

// have to initialize pointer variables after document loads
function init() {
	imageNumTextBox  = document.forms[0].num;
	imageInfoTextBox = document.forms[0].ImageInfo;
	currentIndex = 0;
}

function previousImage() {
	if(currentIndex > 0) {
		currentIndex--;
		update();
	}
}

function nextImage() {
	if(currentIndex + 1 < imageIDs.length) {
		currentIndex++;
		update();
	}
}

function isInteger(data) {
	var inputStr = data.toString()
	var flag = true;
	for (var i = 0; i < inputStr.length; i++)
		{
		var oneChar = inputStr.charAt(i)
		if ((oneChar < "0" || oneChar > "9") && oneChar != "/")
				{
					flag = false;
				}
		}
	return flag;
}

function changeImage(i) {
	if( !isInteger(i) ) {
		imageNumTextBox.value = currentIndex+1;
		return;
	}
	i--;
	if( i != Math.round(i) ) i = Math.round(i);
	if( i<0 ) i=0;
	if( i>imageIDs.length-1 ) i=imageIDs.length-1;
	if(currentIndex != i) {
		currentIndex = i;
		update();
	}
}

function update() {
	imageNumTextBox.value  = currentIndex+1;
	imageInfoTextBox.value = imagePaths[ imageIDs[currentIndex] ];
	var str = "serve.pl?Page=OME::Web::GetGraphics&DatasetID=$DatasetID&ImageID=" + imageIDs[currentIndex];
	parent.viewer.location.href = str;
}

//-->
</script>
</head>
<body onload="init(); update();">
<table width="100%">
<form onsubmit="return false;">
<tr><td align="left">
	<input type="button" name="prev" value="<" onclick="previousImage()">
	<input type="text" name="num" size="5" onchange="changeImage(parseInt(this.value))" maxlength="5">
	<input type="button" name="next" value=">" onclick="nextImage()">
</td><td align="right">
	Image Name: <input type="text" name="ImageInfo" size="40" disabled>
</form>
</td></tr><tr><td colspan='2'>
Displaying dataset "$datasetName". It contains $numImages images.
</td></tr></table>
</html>
ENDHTML

	return ($HTML);

}


sub getImage {
	my $self = shift;
	#FIXME: local caching of $image in $self->{image} ?
	my $cgi     = $self->CGI();
    my $ImageID = $cgi->url_param('ImageID') || die "ImageID not supplied to GetGraphics.pm";
	my $image = $self->Session()->Factory()->loadObject("OME::Image",$ImageID)
		or die "Could not retreive Image from ImageID=$ImageID\n";
	return $image;
}

sub SVGgetDataJS {
	my $self    = shift;
	my $cgi     = $self->CGI();
	my $JSinfo  = {};
	my $session = $self->Session();
	my $factory = $session->Factory();

    my $ImageID = $cgi->url_param('ImageID') || die "ImageID not supplied to GetGraphics.pm";

	$JSinfo->{ ImagedID } = $ImageID;

	my $image = $self->Session()->Factory()->loadObject("OME::Image",$ImageID)
		or die "Could not retreive Image from ImageID=$ImageID\n";

	# get Dimensions from image and make them readable
	my $pixels = $image->DefaultPixels()
		or die "Could not a primary set of Pixels for this image\n";
	my $dims = [ $pixels->SizeX,
	             $pixels->SizeY,
	             $pixels->SizeZ,
	             $pixels->SizeC,
	             $pixels->SizeT,
	             $pixels->BitsPerPixel/8
	            ];
	
	# get wavelengths from image and make them JavaScript readable
	my @ccs = $factory->findAttributes( "PixelChannelComponent", $image )
		or die "Image has no PixelChannelComponent attributes! Cannot display!\n";
	my @channelComponents = grep{ $_->Pixels()->id() eq $pixels->id() } @ccs;
	die "Image has no channel components for default Pixels!" if( scalar( @channelComponents ) eq 0 );
	my @JSwavelengths;
	foreach my $cc (@channelComponents) {
		my $ChannelNum = $cc->Index();
		my $Label = undef;
		$Label = $cc->LogicalChannel()->Name()  || 
		         $cc->LogicalChannel()->Fluor() || 
		         $cc->LogicalChannel()->EmissionWavelength();
		my @overlap = grep( $cc->LogicalChannel()->id() eq $_->LogicalChannel()->id(), @channelComponents );
		$Label .= $cc->Index()
			if( scalar( @overlap ) > 1 || not defined $Label );
		push @JSwavelengths, "{WaveNum:$ChannelNum,Label:\"$Label\"}";
	}
	
	###########################################################################
	#
	#	Get Stack Statistics
	#
	my $stackStats = $factory->findObject( "OME::Module", name => 'Stack statistics' )
		or die "Stack statistics must be installed for this viewer to work!\n";
	my $pixelsFI = $factory->findObject( "OME::Module::FormalInput", 
		module_id => $stackStats->id(),
		name       => 'Pixels' )
		or die "Cannot find 'Pixels' formal input for Module 'Stack Statistics'.\n";
	my $actualInput = $factory->findObject( "OME::ModuleExecution::ActualInput",
		formal_input_id   => $pixelsFI->id(),
		input_module_execution_id => $pixels->module_execution()->id() )
		or die "Stack Statistics has not been run on the Pixels to be displayed.\n";
	my $stackStatsAnalysisID = $actualInput->module_execution()->id();

	# FIXME: update this method call when method accepts search parameters
	my @mins   = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackMinimum", $image ) );
	my @maxes  = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackMaximum", $image ) );
	my @means  = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackMean", $image ) );
	my @gmeans = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackGeometricMean", $image ) );
	my @sigma  = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackSigma", $image ) );
	my @geosigma  = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackGeometricSigma", $image ) );
	my $sh; # stats hash
	foreach( @mins ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{min} = $_->Minimum(); }
	foreach( @maxes ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{max} = $_->Maximum(); }
	foreach( @means ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{mean} = $_->Mean(); }
	foreach( @gmeans ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{geomean} = $_->GeometricMean(); }
	foreach( @sigma ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{sigma} = $_->Sigma(); }
	foreach( @geosigma ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{geosigma} = $_->GeometricSigma(); }



	die "Could not find Stack Statistics for image (id=$ImageID).\n"
		unless defined $sh;
	my @ar1; # array 1
	for( my $i = 0;$i<scalar(@$sh);$i++) {
		my @ar2; # array 2
		for( my $j = 0; $j<scalar(@{$sh->[$i]}); $j++) {
			my $str = '{ '.join( ',', map( $_.': '.$sh->[$i][$j]->{$_}, keys %{ $sh->[$i][$j] } ) ).' }';
			push @ar2, $str;
		}
		push @ar1, '['.join( ',', @ar2 ).']';
	}
	my $JSstats = '['.join( ',', @ar1 ).']';
	#
	#	END 'Get Stack Statistics'
	#
	###########################################################################

	# get display settings
	my $displayOptions    = [$factory->findAttributes( 'DisplayOptions', $image )]->[0];
	my $viewerPreferences = $factory->findObject( 'OME::ViewerPreferences', experimenter_id => $session->User()->id() );
	
	# compile info
	$JSinfo->{ ImageID }            = $ImageID;
	$JSinfo->{ Stats }              = $JSstats;
	$JSinfo->{ Wavelengths }        = '['.join(',',@JSwavelengths).']';
	$JSinfo->{ Dims }               = '['.join (',', @$dims).']';
	$JSinfo->{ CGI_URL }            = '/cgi-bin/OME_JPEG';
	$JSinfo->{ CGI_optionStr }      = '&Path='.$image->getFullPath( $pixels );
	$JSinfo->{ SaveDisplayCGI_URL } = '/perl2/serve.pl?Page=OME::Web::SaveViewerSettings';
	$JSinfo->{ theZ }               = $cgi->url_param('theZ') || sprintf "%d",$dims->[2] / 2;
	$JSinfo->{ theT }               = $cgi->url_param('theT') || 0;
	$JSinfo->{ isRGB }              = 'null';
	$JSinfo->{ CBW }                = 'null'; # ChannelNumber, BlackLevel, WhiteLevel
	$JSinfo->{ RGBon }              = 'null';
	$JSinfo->{ toolBoxScale }       = 1;

	#	Set Defaults
	if( defined $displayOptions ) {
		$JSinfo->{ theZ }      = sprintf( "%d", ( $displayOptions->ZStart() + $displayOptions->ZStop() ) / 2 )
			if( not defined $cgi->url_param('theZ') );
		$JSinfo->{ theT }      = sprintf( "%d", ( $displayOptions->TStart() + $displayOptions->TStop() ) / 2 )
			if( not defined $cgi->url_param('theT') );
		$JSinfo->{ isRGB }     = $displayOptions->DisplayRGB();
		
		my @CBW; # CBW means Channel-BlackLevel-WhiteLevel
		@CBW = (
			$displayOptions->RedChannel()->ChannelNumber(),
			$displayOptions->RedChannel()->BlackLevel(),
			$displayOptions->RedChannel()->WhiteLevel(),
			$displayOptions->GreenChannel()->ChannelNumber(),
			$displayOptions->GreenChannel()->BlackLevel(),
			$displayOptions->GreenChannel()->WhiteLevel(),
			$displayOptions->BlueChannel()->ChannelNumber(),
			$displayOptions->BlueChannel()->BlackLevel(),
			$displayOptions->BlueChannel()->WhiteLevel(),
			$displayOptions->GreyChannel()->ChannelNumber(),
			$displayOptions->GreyChannel()->BlackLevel(),
			$displayOptions->GreyChannel()->WhiteLevel(),
		) if $displayOptions;
		$JSinfo->{ CBW } = '[' . join( ',', @CBW ) . ']'
			if( @CBW );
		$JSinfo->{ RGBon } = '[' . $displayOptions->RedChannelOn() . ',' . $displayOptions->GreenChannelOn() . ',' . $displayOptions->BlueChannelOn() . ']';
	}

	if( defined $viewerPreferences ) {
		$JSinfo->{ toolBoxScale } = $viewerPreferences->toolbox_scale();
	}

	return $JSinfo;
}



# Build the SVG viewer.
sub BuildSVGviewer {
	# A server link needs to be made to src/JavaScript/ for the SVG JavaScript references to function
my $self      = shift;
my $cgi       = $self->CGI();
my $SVG;

my $JSinfo = $self->SVGgetDataJS();

my $DatasetID          = $cgi->url_param('DatasetID') || 'null';
my $ImageID            = $JSinfo->{ ImageID };
my $Stats              = $JSinfo->{ Stats };
my $Wavelengths        = $JSinfo->{ Wavelengths };
my $Dims               = $JSinfo->{ Dims };
my $CGI_URL            = $JSinfo->{ CGI_URL };
my $CGI_optionStr      = $JSinfo->{ CGI_optionStr };
my $SaveDisplayCGI_URL = $JSinfo->{ SaveDisplayCGI_URL };
my $theZ               = $JSinfo->{ theZ };
my $theT               = $JSinfo->{ theT };
my $isRGB              = $JSinfo->{ isRGB };
my $CBW                = $JSinfo->{ CBW };	# known to the svg viewer as WBW - when the svg viewer was developed, ChannelNumber was called Wavenumber. the svg hasn't been updated to reflect this change in nomenclature.
my $RGBon              = $JSinfo->{ RGBon };
my $toolBoxScale       = $JSinfo->{ toolBoxScale };

my $overlayData        = $self->getOverlayJS();
my $centroidData       = $overlayData->{ centroids };
my $featureData        = $overlayData->{ features };

	$self->{contentType} = "image/svg+xml";
	$SVG = <<'ENDSVG';
<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
	"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd" [
	<!ATTLIST svg
		xmlns:a3 CDATA #IMPLIED
		a3:scriptImplementation CDATA #IMPLIED>
	<!ATTLIST script
		a3:scriptImplementation CDATA #IMPLIED>
]>
<svg xml:space="preserve" onload="init(evt)"
	xmlns="http://www.w3.org/2000/svg"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:a3="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
	a3:scriptImplementation="Adobe">
	<!--            GUI classes             -->
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/widget.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/toolBox.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/multipaneToolBox.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/multipaneToolBox.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/slider.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/popupList.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/button.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/AntiZoomAndPan.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/skinLibrary.js" />
	<!--            Backend classes         -->
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/OMEimage.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/scale.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/imageControls.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/featureInfo.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/overlayManager.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/overlay.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/centroid.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/ViewerPreferences.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/stats.js" />
    <script type="text/ecmascript" a3:scriptImplementation="Adobe"><![CDATA[
ENDSVG

# dynamic initialization of JS objects goes here:
$SVG .= <<ENDSVG;
	// GUI components
		var controlsToolBox, multiToolBox;
		var panePopupList;
		var infoButton;
		var azap = new AntiZoomAndPan();

	// backend components
		var image;
		var scale;
		var stats;
		var overlayManager;
		var viewerPreferences;
		var imageControls;
		var featureInfo;
		
	// constants & references
		var Wavelengths        = $Wavelengths;
		var Stats              = $Stats;
		var Dims               = $Dims;
		var DatasetID          = $DatasetID;
		// Z and T are dims of z and t
		var Z                  = Dims[2];
		var T                  = Dims[4];
		var fluors             = new Array();
		var SaveDisplayCGI_URL = "$SaveDisplayCGI_URL";
		var toolBoxScale       = $toolBoxScale;
		
	// global variables
		// theZ & theT are current values of z & t
		var theZ = $theZ;
		var theT = $theT;

		function init(e) {
			if ( window.svgDocument == null )
				svgDocument = e.ownerDocument;
		// initialize back end
			image = new OMEimage($ImageID,$Wavelengths,$Stats,$Dims,"$CGI_URL","$CGI_optionStr", 
				SaveDisplayCGI_URL, $CBW, $RGBon, $isRGB, DatasetID);
			image.realize( svgDocument.getElementById("image") );

			// setup fluors used in this image
			for(i in Wavelengths)
				fluors[Wavelengths[i]['WaveNum']] = Wavelengths[i]['Label'];
		// initialize frontend
			controlToolBox = new toolBox(
				50, 30, 200, 150,
				skinLibrary["menuBar"],
				skinLibrary["hideControl"],
				skinLibrary["GUIbox"]
			);
 			controlToolBox.setLabel(90,12,"Image Controls")
			controlToolBox.getLabel().setAttributeNS(null, "text-anchor", "middle");
			
			
		// realize the GUI elements in the appropriate containers
            var controls  = svgDocument.getElementById("controls");
            controlToolBox.realize(controls);
            
			imageControls = new ImageControls(  );
			var functions = new Array();
			functions['zSlider']   = updateTheZ;
			functions['zUp']       = zUp;
			functions['zDown']     = zDown;
			functions['zAnimUp']   = zAnimUp;
			functions['zAnimDown'] = zAnimDown;
			functions['tSlider']   = updateTheT;
			functions['tUp']       = tUp;
			functions['tDown']     = tDown;
			functions['tAnimUp']   = tAnimUp;
			functions['tAnimDown'] = tAnimDown;
			functions['updateR']   = updateRedChannel;
			functions['updateG']   = updateGreenChannel;
			functions['updateB']   = updateBlueChannel;
			functions['updateBW']  = updateBWChannel;
			functions['OnOffR']    = turnRedOnOff;
			functions['OnOffG']    = turnGreenOnOff;
			functions['OnOffB']    = turnBlueOnOff;
			functions['Save']      = saveImageSettings;
			functions['preload']   = loadAllImages;
			functions['RGB2BW']    = switchRGB_BW;
			functions['showScale'] = showScale;
            controlToolBox.getGUIbox().appendChild( imageControls.buildControls( functions ) );
            
            
            
			// toolbox to house all other interfaces
			multiToolBox = new multipaneToolBox(
				55, 265, 200, 100,
				skinLibrary["menuBar17"],
				skinLibrary["XhideControl"],
				skinLibrary["tallGUIbox"]
			);
			multiToolBox.realize(controls);

			// set up panes in the multi toolbox
			stats = new Statistics( Stats, fluors, updateStatsWave );
			multiToolBox.addPane( stats.buildSVG(), "Stats" );
			scale = new Scale(image, updateBlackLevel, updateWhiteLevel, scaleWaveChange);
			scale.updateScale(theT);
			multiToolBox.addPane( scale.buildSVG(), "Scale");

ENDSVG

#################
# insert centroid data
if( $centroidData ) {
$SVG .= <<ENDSVG;
			var overlayBox  = svgDocument.getElementById("overlays");
			centroids = new CentroidOverlay( $centroidData );
			overlayBox.appendChild( centroids.makeOverlay() );
			overlayManager = new OverlayManager( overlayBox, turnLayerOnOff, switchOverlay, showAllZs, showAllTs );
			overlayManager.addLayer( "Spots", centroids );

			multiToolBox.addPane( overlayManager.makeControls(), "Overlay");
			setTimeout( "switchOverlay(0)", 200 );
			setTimeout( "turnLayerOnOff(true)", 200 );
ENDSVG
}

#################
# static text
$SVG .= <<ENDSVG;
			viewerPreferences = new ViewerPreferences( resizeToolBox, resizeMultiToolBox, savePreferences );
			multiToolBox.addPane( viewerPreferences.buildSVG(), "Preferences");
			// finish setup & make controller
			multiToolBox.closeOnMinimize(true);
			
			panePopupList = new popupList(
				0, 0, multiToolBox.getPaneIndexes(), updatePane, 0,
				skinLibrary["popupListAnchorUpperLeftRoundedLightslategray"],
				skinLibrary["popupListBackgroundLightskyblue"],
				skinLibrary["popupListHighlightAquamarine"]
			);
			panePopupList.realize( multiToolBox.getMenuBar() );
			
			
			// voodoo to switch which component is rendered on top
			//  this makes the popupList be drawn on top 
			multiToolBox.nodes.GUIboxContainer.setAttribute( "onmouseover", 'multiToolBox.drawGUITop()' );
			multiToolBox.getMenuBar().setAttribute( "onmouseover", 'multiToolBox.drawMenuTop()' );

ENDSVG

#################
# insert feature data
if( $featureData ) {
$SVG .= <<ENDSVG;
			// Feature Information
			featureInfo = new FeatureInfo( $featureData );
			featureInfo.buildToolBox( controls );

ENDSVG
}

$SVG .= <<ENDSVG;
			azap.appendNode(controls);
			mouseTrap = svgDocument.getElementById("mouseTrap");
			azap.appendNode(mouseTrap); 

			// Set up display. These values come from DB eventually.
			var WBS = image.getWBS();
			setTimeout( "imageControls.redPopupList.setSelectionByValue('"+ 
				imageControls.redPopupList.getItemList()[ WBS[0] ]
				+"')", 0 );
			setTimeout( "imageControls.greenPopupList.setSelectionByValue('"+ 
				imageControls.greenPopupList.getItemList()[ WBS[3] ]
				+"')", 0 );
			setTimeout( "imageControls.bluePopupList.setSelectionByValue('"+ 
				imageControls.bluePopupList.getItemList()[ WBS[6] ]
				+"')", 0 );
			setTimeout( "imageControls.bwPopupList.setSelectionByValue('"+ 
				imageControls.bwPopupList.getItemList()[ WBS[9] ]
				+"')", 0 );
			var RGBon = image.getRGBon(); 
			setTimeout( "resizeToolBox(50 * ("+toolBoxScale+" - 1 ) )", 0);
			setTimeout( "multiToolBox.hide()", 0);
			setTimeout( "resizeMultiToolBox()", 500);
			setTimeout( "imageControls.redButton.setState(" + (RGBon[0]==1 ? "true" : "false") + ")", 0 );
			setTimeout( "imageControls.greenButton.setState(" + (RGBon[1]==1 ? "true" : "false") + ")", 0 );
			setTimeout( "imageControls.blueButton.setState(" + (RGBon[2]==1 ? "true" : "false") + ")", 0 );
			setTimeout( "imageControls.RGB_BWbutton.setState("+image.getDisplayRGB_BW()+")", 0 );
			setTimeout( "imageControls.loadButton.setState(false)", 0 );
			imageControls.zSlider.setValue(theZ/Z*100,true);
			imageControls.tSlider.setValue(theT/T*100,true);

		}
		
ENDSVG

# more static stuff
$SVG .= <<'ENDSVG';
        
	// these functions connect GUI with backend
		function showAllZs( val ) {
			overlayManager._showAllZs( val );	
		}

		function showAllTs( val ) {
			overlayManager._showAllTs( val );	
		}
	
		function switchOverlay( item ) {
			overlayManager._switchOverlay( item );	
		}
	
		function turnLayerOnOff( val ) {
			overlayManager._turnLayerOnOff(val);
		}
	
		function savePreferences() {
			var tmpImg;
			tmpImg = svgDocument.createElementNS(svgns,"image");
			tmpImg.setAttribute("width",0);
			tmpImg.setAttribute("height",0);
			// The purpose of unique is to bypass any image caching
			var unique   = Math.random();
			var imageURL = SaveDisplayCGI_URL + 
				'&toolBoxScale=' + controlToolBox.getScale() +
				"&Unique=" + unique;
			tmpImg.setAttributeNS(xlinkns, "xlink:href",imageURL);
		
			controlToolBox.getGUIbox().appendChild(tmpImg);
			controlToolBox.getGUIbox().removeChild(tmpImg);
		}
	
		function resizeToolBox(data) {
			viewerPreferences.toolBoxSizeSlider.setValue(data);
			controlToolBox.setScale(1 + data/50);	// resizes the controlToolBox
		}
		function resizeMultiToolBox() {
			multiToolBox.setScale( controlToolBox.getScale() );	// resizes the multiToolBox
		}

		
		function saveImageSettings() {
			image.saveState();
		}
	
		function loadAllImages(val) {
			image.setPreload(true);
			image.setPreload(false);
		}
	
		// newZ has range of 0 to Z-1
		function setTheZ( newZ ) {
			if( Z > 1 )
				updateTheZ( newZ / (Z-1) *100 );
		}
		// this accepts a percentage (0-100)
		function updateTheZ(data) {
			data=Math.round(data/100*(Z-1));
			var sliderVal = (Z==1 ? 0 : Math.round(data/(Z-1)*100) );
			imageControls.zSlider.setValue(sliderVal);
			imageControls.zSlider.setLabel(null, null, (data + 1) + "/" + Z );
			theZ=data;
			
			if( overlayManager ) overlayManager.updateIndex( theZ, theT );
			image.updatePic(theZ,theT);
		}
		function zUp() {
			var data = (theZ< Z-1 ? theZ + 1 : theZ)
			var sliderVal = ( Z==1 ? 0 : Math.round( data/(Z-1)*100 ) );
			updateTheZ(sliderVal);
		
		}
		function zDown() {
			var data = (theZ> 0 ? theZ - 1 : theZ)
			var sliderVal = ( Z==1 ? 0 : Math.round( data/(Z-1)*100 ) );
			updateTheZ(sliderVal);
		}
		function zAnimUp() {
			if(Z > 1) {
				for(i=theZ;i<Z;i++)
					setTimeout("updateTheZ(" + (i/(Z-1)) + "*100)", (i-theZ)*100);
			}
		}
		function zAnimDown() {
			if(Z > 1) {
				for(i=theZ;i>=0;i--)
					setTimeout("updateTheZ(" + (i/(Z-1)) + "*100)", (theZ-i)*100);
			}
		}

		// newT has range of 0 to Z-1
		function setTheT( newT ) {
			if( T > 1 ) 
				updateTheT( newT / (T-1) *100 );
		}
		// this accepts a percentage (0-100)
		function updateTheT(data) {
			theT=Math.round(data/100*(T-1));
			var sliderVal = ( T==1 ? 0 : Math.round(theT/(T-1)*100) );
			imageControls.tSlider.setValue(sliderVal);
			imageControls.tSlider.setLabel(null, null, "time (" + (theT+1) + "/" + T +")" );
			
			if( overlayManager) overlayManager.updateIndex( theZ, theT );
			image.updatePic(theZ,theT);
			scale.updateScale(theT);
			stats.updateStats(theT);
		}
		function tUp() {
			var data = (theT< T-1 ? theT+1 : theT)
			var sliderVal = ( T==1 ? 0 : Math.round( data/(T-1)*100 ) );
			updateTheT(sliderVal);
		}
		function tDown() {
			var data = (theT> 0 ? theT -1 : theT)
			var sliderVal = ( T==1 ? 0 : Math.round( data/(T-1)*100 ) );
			updateTheT(sliderVal);
		}
		function tAnimUp() {
			if(T>1) {
				for(i=theT;i<T;i++)
					setTimeout("updateTheT(" + (i/(T-1)) + "*100)", (i-theT)*100);
			}
		}
		function tAnimDown() {
			if(T>1) {
				for(i=theT;i>=0;i--)
					setTimeout("updateTheT(" + (i/(T-1)) + "*100)", (theT-i)*100);
			}
		}

		// popupLists controlling channels
		function updateRedChannel(item) {
			scale.updateWBS('R', item);
		}
		function updateGreenChannel(item) {
			scale.updateWBS('G', item);
		}
		function updateBlueChannel(item) {
			scale.updateWBS('B', item);
		}
		function updateBWChannel(item) {
			scale.updateWBS('Gray', item);
			stats.changeWavenumber( item );
		}

		function updatePane(item) {
			var itemList = panePopupList.getItemList();
			multiToolBox.changePane( itemList[item] );
		}
		
		// buttons controlling channels
		function turnRedOnOff(val) {
			RGBon = image.getRGBon();
			RGBon[0] = (val ? 1 : 0);
			image.setRGBon(RGBon);
		}
		function turnGreenOnOff(val) {
			RGBon = image.getRGBon();
			RGBon[1] = (val ? 1 : 0);
			image.setRGBon(RGBon);
		}
		function turnBlueOnOff(val) {
			RGBon = image.getRGBon();
			RGBon[2] = (val ? 1 : 0);
			image.setRGBon(RGBon);
		}
		function switchRGB_BW(val) {
			//	decide which way to flip
			if(val) {	// val == true means mode = RGB
				imageControls.BWpopupListBox.setAttribute( "display", "none" );
				imageControls.RGBpopupListBox.setAttribute( "display", "inline" );
			}
			else {	// mode = BW
				imageControls.BWpopupListBox.setAttribute( "display", "inline" );
				imageControls.RGBpopupListBox.setAttribute( "display", "none" );
			}
			image.setDisplayRGB_BW(val);
		}
		
		function showOverlay() {
			panePopupList.setSelectionByValue("Overlay");
		}
		function showPreferences() {
			panePopupList.setSelectionByValue("Preferences");
		}

		// Stats stuff
		function showStats() {
			panePopupList.setSelectionByValue("Stats");
		}
		function updateStatsWave(wavenum) {
			stats.updateStats(theT);
		}

		// Scale stuff
		function updateBlackLevel(val) {
			// has scale been initialized?
			if(scale.image == null ) return;
			if(Math.round(val) == scale.blackBar.getAttribute("width")) return;

			// set up constants
			var wavenum = scale.wavePopupList.getSelection();
			var min = scale.Stats[wavenum][theT]['min'];
			var max = scale.Stats[wavenum][theT]['max'];
			var range = max-min;
			var geomean = scale.Stats[wavenum][theT]['geomean'];
			var sigma = scale.Stats[wavenum][theT]['sigma'];
			var geosigma = scale.Stats[wavenum][theT]['geosigma'];

			// correct val, crunch numbers
			if(val >= scale.whiteSlider.getValue())
				val = scale.whiteSlider.getValue() - 0.00001;
			var cBlackLevel = Math.round(val/scale.scaleWidth * range + min);
			val = (cBlackLevel-min)/range * scale.scaleWidth;

			// update backend
			//var nBlackLevel = (cBlackLevel - geomean)/sigma;
			var nBlackLevel = (cBlackLevel - geomean)/geosigma;

			nBlackLevel = Math.round(nBlackLevel * 10) / 10;
			scale.BS[wavenum]['B'] = nBlackLevel;
			scale.updateWBS();

			// update display
			scale.blackSlider.setValue(val);
			scale.blackLabel.firstChild.data = "geomean + geoSD * " + nBlackLevel;
			scale.blackBar.setAttribute("width", Math.round(val) );
		}
		function updateWhiteLevel(val) {
			// has scale been initialized?
			if(scale.image == null ) return;
			if(Math.round(val) == scale.whiteBar.getAttribute("x")) return;

			// set up constants
			var wavenum = scale.wavePopupList.getSelection();
			var min = scale.Stats[wavenum][theT]['min'];
			var max = scale.Stats[wavenum][theT]['max'];
			var range = max-min;
			var geomean = scale.Stats[wavenum][theT]['geomean'];
			var sigma = scale.Stats[wavenum][theT]['sigma'];
			var geosigma = scale.Stats[wavenum][theT]['geosigma'];

			// correct val, crunch numbers
			if(val <= scale.blackSlider.getValue())
				val = scale.blackSlider.getValue() + 0.00001;
			var cWhiteLevel = Math.round(val/scale.scaleWidth * range + min);
			if(cWhiteLevel == geomean)
				cWhiteLevel -= 0.00001;
			val = (cWhiteLevel-min)/range * scale.scaleWidth;

			// update backend
			//var nScale = (cWhiteLevel - geomean)/sigma;
			var nScale = (cWhiteLevel - geomean)/geosigma;

			nScale = Math.round(nScale*10)/10;
			scale.BS[wavenum]['S'] = nScale;
			scale.updateWBS();

			// update display
			scale.whiteSlider.setValue(val);
			scale.whiteLabel.firstChild.data = "geomean + geoSD * " + nScale;
			scale.whiteBar.setAttribute("width", scale.scaleWidth - Math.round(val) );
			scale.whiteBar.setAttribute("x", Math.round(val) );
		}
		function scaleWaveChange(val) {
			scale.updateScale(theT);
		}
		function showScale() {
			panePopupList.setSelectionByValue("Scale");
		}
		
    ]]></script>
	<g id="mouseTrap">
		<!-- The mouse only registers over elements. This rect prevents
			 loosing the mouse while moving the toolbox. It is drawn first
			 so it will be placed
			 on bottom so it will not trap mouse events unless nothing
			 else does. -->
		<rect width="100%" height="100%" fill="blue" opacity="0"/>	
	</g>
	<g id="image">
	</g>
	<g id="overlays">
	</g>
	<g id="controls">
	</g>
</svg>
ENDSVG
;

	return $SVG;
}

sub getOverlayJS {
	my $self = shift;
	my $image = $self->getImage();
	my $pixels = $image->DefaultPixels();
	
	my $factory = $self->Session()->Factory();
	
	my @spots = $factory->findObjects( "OME::Feature", image_id => $image->id(), tag => 'SPOT' );

	my $centroidDataJS;
	my @centroidData;
	my %moduleExecutions;
	my %features;
	my @featureData;
	my $featureDataJS;
	my @locations;
	
	push @locations, $factory->findAttributes( "Location", $_ ) 
		foreach ( @spots );
	
	foreach my $location( @locations ) { 

		my ($theX, $theY, $theZ) = map( sprintf( "%i", $_ + 0.5 ), ( $location->TheX, $location->TheY, $location->TheZ ) );

		my $moduleExecution = $location->module_execution();
		my $feature = $location->feature();
		$moduleExecutions{ $moduleExecution } = undef 
			unless exists $moduleExecutions{ $moduleExecution };
		$features{ $feature->id() } = $feature
			unless exists $features{ $feature->id() };

		my @timepoints = $factory->findAttributes( "Timepoint", $feature )
			or die "this spot (".$feature->id.") has no Timepoint\n";
		die "this spot (".$feature->id.")has multiple Timepoint" if @timepoints > 1;
		my $theT = $timepoints[0]->TheT();
		push ( @centroidData, 
			"{ theX: $theX, theY: $theY, theZ: $theZ, theT: $theT, moduleExecutionID: ".$moduleExecution->id().", featureID: ".$feature->id()." }" );
	}

	foreach my $feature( values %features ) {
		my ( $id, $tag, $name ) = ($feature->id(), $feature->tag(), $feature->name() );
		push ( @featureData, "{ ID: '$id', Tag: '$tag', Name: '$name' }" );
	}
	
	$featureDataJS  = '['.join( ',', @featureData ).']'
		if @featureData;
	$centroidDataJS = '['.join( ',', @centroidData ).']'
		if @centroidData;
	
	return { centroids => $centroidDataJS, features => $featureDataJS };

}

1;
