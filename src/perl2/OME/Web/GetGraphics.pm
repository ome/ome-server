#!/usr/bin/perl -w
# Copyright (C) 2002 Open Microscopy Environment
# Author:
#	Josiah Johnston <siah@nih.gov>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
package OME::Web::GetGraphics;

use strict;
use vars qw($VERSION);
$VERSION = 2.000_000;
use CGI;
use base qw{ OME::Web };

use Benchmark;

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $self  = $class->SUPER::new(@_);

#    $self->{RequireLogin} = 0;

    return $self;
}

sub createOMEPage {
	my $self  = shift;
	my $cgi   = $self->CGI();
	my @params = $cgi->url_param();

	# Does this image ID exist? If it doesn't and we trap the error now, then we can display error message.
	my $ImageID   = $cgi->url_param('ImageID');
	my $DatasetID = $cgi->url_param('DatasetID');
	if( !defined $ImageID and !defined $DatasetID ) {
		die "Package needs either ImageID or DatasetID as url parameters. Neither was supplied. This message generated by ".(ref $self)."->createOMEpage().";
	}
	if( defined $ImageID ) {
		my $image = $self->Session->Factory()->loadObject("OME::Image",$ImageID);
		die "Could not load Image (ID=$ImageID) from database. This message generated by ".(ref $self)."->createOMEpage()."
			unless defined $image;
	}
	if( defined $DatasetID ) {
		my $dataset = $self->Session()->Factory()->loadObject("OME::Dataset",$DatasetID);
		die "Could not load Dataset (ID=$DatasetID) from database. This message generated by ".(ref $self)."->createOMEpage()."
			unless defined $dataset;
	}

	if ( $cgi->url_param('BuildSVGviewer') ) {
		return('SVG', $self->BuildSVGviewer());
	} elsif ( $cgi->url_param('DrawDatasetControl')) {
		return('HTML', $self->DrawDatasetControl());
	} elsif ( $cgi->url_param('ImageID')) {
		return('HTML', $self->DrawMainWindowSVGimage());
	} elsif ( $cgi->url_param('DatasetID')) {
		return('HTML', $self->DrawMainWindowSVGdataset());
	}
}


sub getPageTitle {
    return "OME - SVG viewer";
}

sub contentType {
my $self = shift;
	return $self->{contentType};
}

sub DrawMainWindowSVGimage {
my $self      = shift;
my $cgi       = $self->CGI();
my $ImageID   = $cgi->url_param("ImageID")  || die "\nImage id not supplied to GetGraphics.pm ";
my $DatasetID = $cgi->url_param("DatasetID");
my $HTML='';

	$self->{contentType} = 'text/html';
#	$HTML = $cgi->start_html(-title=>'OME SVG 2D Viewer');
# Add controls to change the displayed image. e.g. switch to previous or next image in a set.
# Embedding in frames instead of object allows Mozilla > v1 to run it. Keep if no problems w/ it.
	$HTML .= <<ENDHTML;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<title>OME SVG 2D Viewer</title>
	<frameset rows="*">
		<frame src="serve.pl?Page=OME::Web::GetGraphics&BuildSVGviewer=1&ImageID=$ImageID
ENDHTML
$HTML .= "&DatasetID=$DatasetID"
	if defined $DatasetID;
$HTML .= <<ENDHTML;
">
	</frameset>
</html>
ENDHTML

	return ($HTML);
}


sub DrawMainWindowSVGdataset {
my $self = shift;
my $cgi   = $self->CGI();
my $DatasetID = $cgi->url_param('DatasetID') || die "\nDataset id not supplied to GetGraphics.pm ";
my $HTML='';

	$self->{contentType} = 'text/html';
	$HTML .= <<ENDHTML;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<title>OME Dataset Viewer</title>
	<frameset rows="80,*" border="0">
		<frame name="controls" src="serve.pl?Page=OME::Web::GetGraphics&DrawDatasetControl=1&DatasetID=$DatasetID">
		<frame name="viewer" src="">
	</frameset>
</html>
ENDHTML

	return ($HTML);
}



sub DrawDatasetControl {
	my $self = shift;
	my $cgi   = $self->CGI();
	my $DatasetID = $cgi->url_param('DatasetID') || die "\nDataset id not supplied to GetGraphics.pm ";
	my $Dataset = $self->Session()->Factory()->loadObject("OME::Dataset",$DatasetID) || die "\nInvalide dataset id provided to GetGraphics.pm\n";
	my $imageMaps = $Dataset->image_links();
	my ($imageMap, @ImageIDs, $JSimageIDs, %ImagePaths, $JS_SetImagePathArray, $HTML);
	my $numImages = 0;
	my $datasetName = $Dataset->name();
	
    while (my $imageMap = $imageMaps->next()) {
		$numImages++;
		push (@ImageIDs, $imageMap->image()->image_id());
		$ImagePaths{ $imageMap->image()->image_id() } = $imageMap->image()->name();#getFullPath( $imageMap->image()->DefaultPixels() );
	}	
	$JSimageIDs = '['.join(',',@ImageIDs).']';
	$JS_SetImagePathArray = join( "\n", map( "imagePaths[$_] = '".$ImagePaths{$_}."';", keys %ImagePaths) );
	

	$self->{contentType} = 'text/html';
	$HTML = <<ENDHTML;
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
<title>Select Image from Dataset</title>
<script language="JavaScript">
<!--

var imageIDs   = $JSimageIDs;
var imagePaths = new Array();
$JS_SetImagePathArray
var currentIndex;
var imageNumTextBox;
var imageInfoTextBox;

// have to initialize pointer variables after document loads
function init() {
	imageNumTextBox  = document.forms[0].num;
	imageInfoTextBox = document.forms[0].ImageInfo;
	currentIndex = 0;
}

function previousImage() {
	if(currentIndex > 0) {
		currentIndex--;
		update();
	}
}

function nextImage() {
	if(currentIndex + 1 < imageIDs.length) {
		currentIndex++;
		update();
	}
}

function isInteger(data) {
	var inputStr = data.toString()
	var flag = true;
	for (var i = 0; i < inputStr.length; i++)
		{
		var oneChar = inputStr.charAt(i)
		if ((oneChar < "0" || oneChar > "9") && oneChar != "/")
				{
					flag = false;
				}
		}
	return flag;
}

function changeImage(i) {
	if( !isInteger(i) ) {
		imageNumTextBox.value = currentIndex+1;
		return;
	}
	i--;
	if( i != Math.round(i) ) i = Math.round(i);
	if( i<0 ) i=0;
	if( i>imageIDs.length-1 ) i=imageIDs.length-1;
	if(currentIndex != i) {
		currentIndex = i;
		update();
	}
}

function update() {
	imageNumTextBox.value  = currentIndex+1;
	imageInfoTextBox.value = imagePaths[ imageIDs[currentIndex] ];
	var str = "serve.pl?Page=OME::Web::GetGraphics&DatasetID=$DatasetID&ImageID=" + imageIDs[currentIndex];
	parent.viewer.location.href = str;
}

//-->
</script>
</head>
<body onload="init(); update();">
<table width="100%">
<form onsubmit="return false;">
<tr><td align="left">
	<input type="button" name="prev" value="<" onclick="previousImage()">
	<input type="text" name="num" size="5" onchange="changeImage(parseInt(this.value))" maxlength="5">
	<input type="button" name="next" value=">" onclick="nextImage()">
</td><td align="right">
	Image Name: <input type="text" name="ImageInfo" size="40" disabled>
</form>
</td></tr><tr><td colspan='2'>
Displaying dataset "$datasetName". It contains $numImages images.
</td></tr></table>
</html>
ENDHTML

	return ($HTML);

}


sub SVGgetDataJS {
	my $self    = shift;
	my $cgi     = $self->CGI();
	my $JSinfo  = {};
	my $session = $self->Session();
	my $factory = $session->Factory();

    my $ImageID = $cgi->url_param('ImageID') || die "ImageID not supplied to GetGraphics.pm";

	$JSinfo->{ ImagedID } = $ImageID;

	my $image = $self->Session()->Factory()->loadObject("OME::Image",$ImageID)
		or die "Could not retreive Image from ImageID=$ImageID\n";

	# get Dimensions from image and make them readable
	my $pixels = $image->DefaultPixels()
		or die "Could not a primary set of Pixels for this image\n";
	my $dims = [ $pixels->SizeX,
	             $pixels->SizeY,
	             $pixels->SizeZ,
	             $pixels->SizeC,
	             $pixels->SizeT,
	             $pixels->BitsPerPixel/8
	            ];
	
	# get wavelengths from image and make them JavaScript readable
	my @ccs = $factory->findAttributes( "PixelChannelComponent", $image )
		or die "Image has no PixelChannelComponent attributes! Cannot display!\n";
	my @channelComponents = grep{ $_->Pixels()->id() eq $pixels->id() } @ccs;
	die "Image has no channel components for default Pixels!" if( scalar( @channelComponents ) eq 0 );
	my @JSwavelengths;
	foreach my $cc (@channelComponents) {
		my $ChannelNum = $cc->Index();
		my $Label = undef;
		$Label = $cc->LogicalChannel()->Name()  || 
		         $cc->LogicalChannel()->Fluor() || 
		         $cc->LogicalChannel()->EmissionWavelength();
		my @overlap = grep( $cc->LogicalChannel()->id() eq $_->LogicalChannel()->id(), @channelComponents );
		$Label .= $cc->Index()
			if( scalar( @overlap ) > 1 || not defined $Label );
		push @JSwavelengths, "{WaveNum:$ChannelNum,Label:\"$Label\"}";
	}
	
	###########################################################################
	#
	#	Get Stack Statistics
	#
	my $stackStats = $factory->findObject( "OME::Module", name => 'Stack statistics' )
		or die "Stack statistics must be installed for this viewer to work!\n";
	my $pixelsFI = $factory->findObject( "OME::Module::FormalInput", 
		module_id => $stackStats->id(),
		name       => 'Pixels' )
		or die "Cannot find 'Pixels' formal input for Module 'Stack Statistics'.\n";
	my $actualInput = $factory->findObject( "OME::ModuleExecution::ActualInput",
		formal_input_id   => $pixelsFI->id(),
		input_module_execution_id => $pixels->module_execution()->id() )
		or die "Stack Statistics has not been run on the Pixels to be displayed.\n";
	my $stackStatsAnalysisID = $actualInput->module_execution()->id();

	# FIXME: update this method call when method accepts search parameters
	my @mins   = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackMinimum", $image ) );
	my @maxes  = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackMaximum", $image ) );
	my @means  = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackMean", $image ) );
	my @gmeans = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackGeometricMean", $image ) );
	my @sigma  = grep( $_->module_execution()->id() eq $stackStatsAnalysisID, 
		$factory->findAttributes( "StackSigma", $image ) );
	
	my $sh; # stats hash
	foreach( @mins ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{min} = $_->Minimum(); }
	foreach( @maxes ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{max} = $_->Maximum(); }
	foreach( @means ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{mean} = $_->Mean(); }
	foreach( @gmeans ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{geomean} = $_->GeometricMean(); }
	foreach( @sigma ) {
		$sh->[ $_->TheC() ][ $_->TheT() ]->{sigma} = $_->Sigma(); }
	die "Could not find Stack Statistics for image (id=$ImageID).\n"
		unless defined $sh;
	my @ar1; # array 1
	for( my $i = 0;$i<scalar(@$sh);$i++) {
		my @ar2; # array 2
		for( my $j = 0; $j<scalar(@{$sh->[$i]}); $j++) {
			my $str = '{ '.join( ',', map( $_.': '.$sh->[$i][$j]->{$_}, keys %{ $sh->[$i][$j] } ) ).' }';
			push @ar2, $str;
		}
		push @ar1, '['.join( ',', @ar2 ).']';
	}
	my $JSstats = '['.join( ',', @ar1 ).']';
	#
	#	END 'Get Stack Statistics'
	#
	###########################################################################

	# get display settings
	my $displayOptions    = [$factory->findAttributes( 'DisplayOptions', $image )]->[0];
	my $viewerPreferences = $factory->findObject( 'OME::ViewerPreferences', experimenter_id => $session->User()->id() );
	
	# compile info
	$JSinfo->{ ImageID }            = $ImageID;
	$JSinfo->{ Stats }              = $JSstats;
	$JSinfo->{ Wavelengths }        = '['.join(',',@JSwavelengths).']';
	$JSinfo->{ Dims }               = '['.join (',', @$dims).']';
	$JSinfo->{ CGI_URL }            = '/cgi-bin/OME_JPEG';
	$JSinfo->{ CGI_optionStr }      = '&Path='.$image->getFullPath( $pixels );
	$JSinfo->{ SaveDisplayCGI_URL } = '/perl2/serve.pl?Page=OME::Web::SaveViewerSettings';
	$JSinfo->{ theZ }               = $cgi->url_param('theZ') || sprintf "%d",$dims->[2] / 2;
	$JSinfo->{ theT }               = $cgi->url_param('theT') || 0;
	$JSinfo->{ isRGB }              = 'null';
	$JSinfo->{ CBW }                = 'null'; # ChannelNumber, BlackLevel, WhiteLevel
	$JSinfo->{ RGBon }              = 'null';
	$JSinfo->{ toolBoxScale }       = 1;

	#	Set Defaults
	if( defined $displayOptions ) {
		$JSinfo->{ theZ }      = sprintf( "%d", ( $displayOptions->ZStart() + $displayOptions->ZStop() ) / 2 )
			if( not defined $cgi->url_param('theZ') );
		$JSinfo->{ theT }      = sprintf( "%d", ( $displayOptions->TStart() + $displayOptions->TStop() ) / 2 )
			if( not defined $cgi->url_param('theT') );
		$JSinfo->{ isRGB }     = $displayOptions->DisplayRGB();
		
		my @CBW; # CBW means Channel-BlackLevel-WhiteLevel
		@CBW = (
			$displayOptions->RedChannel()->ChannelNumber(),
			$displayOptions->RedChannel()->BlackLevel(),
			$displayOptions->RedChannel()->WhiteLevel(),
			$displayOptions->GreenChannel()->ChannelNumber(),
			$displayOptions->GreenChannel()->BlackLevel(),
			$displayOptions->GreenChannel()->WhiteLevel(),
			$displayOptions->BlueChannel()->ChannelNumber(),
			$displayOptions->BlueChannel()->BlackLevel(),
			$displayOptions->BlueChannel()->WhiteLevel(),
			$displayOptions->GreyChannel()->ChannelNumber(),
			$displayOptions->GreyChannel()->BlackLevel(),
			$displayOptions->GreyChannel()->WhiteLevel(),
		) if $displayOptions;
		$JSinfo->{ CBW } = '[' . join( ',', @CBW ) . ']'
			if( @CBW );
		$JSinfo->{ RGBon } = '[' . $displayOptions->RedChannelOn() . ',' . $displayOptions->GreenChannelOn() . ',' . $displayOptions->BlueChannelOn() . ']';
	}

	if( defined $viewerPreferences ) {
		$JSinfo->{ toolBoxScale } = $viewerPreferences->toolbox_scale();
	}

	return $JSinfo;
}



# Build the SVG viewer.
sub BuildSVGviewer {
	# A server link needs to be made to src/JavaScript/ for the SVG JavaScript references to function
my $self      = shift;
my $cgi       = $self->CGI();
my $SVG;


my $JSinfo = $self->SVGgetDataJS();

my $DatasetID          = $cgi->url_param('DatasetID') || 'null';
my $ImageID            = $JSinfo->{ ImageID };
my $Stats              = $JSinfo->{ Stats };
my $Wavelengths        = $JSinfo->{ Wavelengths };
my $Dims               = $JSinfo->{ Dims };
my $CGI_URL            = $JSinfo->{ CGI_URL };
my $CGI_optionStr      = $JSinfo->{ CGI_optionStr };
my $SaveDisplayCGI_URL = $JSinfo->{ SaveDisplayCGI_URL };
my $theZ               = $JSinfo->{ theZ };
my $theT               = $JSinfo->{ theT };
my $isRGB              = $JSinfo->{ isRGB };
my $CBW                = $JSinfo->{ CBW };	# known to the svg viewer as WBW - when the svg viewer was developed, ChannelNumber was called Wavenumber. the svg hasn't been updated to reflect this change in nomenclature.
my $RGBon              = $JSinfo->{ RGBon };
my $toolBoxScale       = $JSinfo->{ toolBoxScale };

	$self->{contentType} = "image/svg+xml";
	$SVG = <<'ENDSVG';
<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
	"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd" [
	<!ATTLIST svg
		xmlns:a3 CDATA #IMPLIED
		a3:scriptImplementation CDATA #IMPLIED>
	<!ATTLIST script
		a3:scriptImplementation CDATA #IMPLIED>
]>
<svg xml:space="preserve" onload="init(evt)"
	xmlns="http://www.w3.org/2000/svg"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:a3="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
	a3:scriptImplementation="Adobe">
	<!--            GUI classes             -->
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/widget.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/toolBox.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/multipaneToolBox.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/multipaneToolBox.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/slider.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/popupList.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/button.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/AntiZoomAndPan.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVG_GUI/skinLibrary.js" />
	<!--            Backend classes         -->
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/OMEimage.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/scale.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/overlay.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/ViewerPreferences.js" />
	<script type="text/ecmascript" a3:scriptImplementation="Adobe"
			xlink:href="/JavaScript/SVGviewer/stats.js" />
    <script type="text/ecmascript" a3:scriptImplementation="Adobe"><![CDATA[
ENDSVG

# dynamic initialization of JS objects goes here:
$SVG .= <<ENDSVG;
	// GUI components
		var controlsToolBox, multiToolBox;
		var zSlider, tSlider;
		var redPopupList, bluePopupList, greenPopupList, bwPopupList;
		var scalePopupList, panePopupList;
		var RGBpopupListBox, BWpopupListBox;
		var redButton, blueButton, greenButton, RGB_BWbutton;
		var infoButton;
		var azap = new AntiZoomAndPan();

	// backend components
		var image;
		var scale;
		var stats;
		var overlay;
		var viewerPreferences;
		
	// constants & references
		var Wavelengths        = $Wavelengths;
		var Stats              = $Stats;
		var Dims               = $Dims;
		var DatasetID          = $DatasetID;
		// Z and T are dims of z and t
		var Z                  = Dims[2];
		var T                  = Dims[4];
		var fluors             = new Array();
		var SaveDisplayCGI_URL = "$SaveDisplayCGI_URL";
		var toolBoxScale       = $toolBoxScale;
		
	// global variables
		// theZ & theT are current values of z & t
		var theZ = $theZ;
		var theT = $theT;

		function init(e) {
			if ( window.svgDocument == null )
				svgDocument = e.ownerDocument;
		// initialize back end
			image = new OMEimage($ImageID,$Wavelengths,$Stats,$Dims,"$CGI_URL","$CGI_optionStr", 
				SaveDisplayCGI_URL, $CBW, $RGBon, $isRGB, DatasetID);
			image.realize( svgDocument.getElementById("image") );

			// setup fluors used in this image
			for(i in Wavelengths)
				fluors[Wavelengths[i]['WaveNum']] = Wavelengths[i]['Label'];
		// initialize frontend
			controlToolBox = new toolBox(
				50, 30, 200, 150,
				skinLibrary["menuBar"],
				skinLibrary["hideControl"],
				skinLibrary["GUIbox"]
			);
			controlToolBox.setLabel(90,12,"Primary Controls")
			controlToolBox.getLabel().setAttributeNS(null, "text-anchor", "middle");
			
			multiToolBox = new multipaneToolBox(
				55, 265, 200, 100,
				skinLibrary["menuBar17"],
				skinLibrary["XhideControl"],
				skinLibrary["tallGUIbox"]
			);
			
			zSlider = new Slider(
				30, 120, 100, -90,
				updateTheZ,
				skinLibrary["zSliderBody"],
				skinLibrary["zSliderThumb"]
			);
			zSlider.setLabel(0,-102,"");
			zSlider.getLabel().setAttribute( "fill", "white" );
			zSlider.getLabel().setAttribute( "text-anchor", "middle" );

			tSlider = new Slider(
				60, 30, 100, 0,
				updateTheT
			);
			tSlider.setLabel(60,-13,"");
			tSlider.getLabel().setAttribute( "fill", "white" );

			// wavelength to channel popupLists
			redPopupList = new popupList(
				-50, 0, fluors, updateRedWavelength, 1,
				skinLibrary["redAnchorText"],
				skinLibrary["redItemBackgroundText"],
				skinLibrary["redItemHighlightText"]
			);

			greenPopupList = new popupList(
				0, 0, fluors, updateGreenWavelength, 0,
				skinLibrary["greenAnchorText"],
				skinLibrary["greenItemBackgroundText"],
				skinLibrary["greenItemHighlightText"]
			);

			bluePopupList = new popupList(
				50, 0, fluors, updateBlueWavelength, 0,
				skinLibrary["blueAnchorText"],
				skinLibrary["blueItemBackgroundText"],
				skinLibrary["blueItemHighlightText"]
			);
			
			bwPopupList = new popupList(
				0, 0, fluors, updateBWWavelength
			);
			
			// set up channel on/off buttons
			redButton = new button( 
				Math.round(redPopupList.x + redPopupList.width/2), -13, turnRedOnOff,
				skinLibrary["redButtonOn"],
				skinLibrary["redButtonOff"],
				skinLibrary["blankButtonRadius5Highlight"]
			);
			greenButton = new button( 
				Math.round(greenPopupList.x + greenPopupList.width/2), -13, turnGreenOnOff,
				skinLibrary["greenButtonOn"],
				skinLibrary["greenButtonOff"],
				skinLibrary["blankButtonRadius5Highlight"]
			);
			blueButton = new button(
				Math.round(bluePopupList.x + bluePopupList.width/2), -13, turnBlueOnOff,
				skinLibrary["blueButtonOn"],
				skinLibrary["blueButtonOff"],
				skinLibrary["blankButtonRadius5Highlight"]
			);
			
			// save button
			saveButton = new button(
				85, 130, saveImage,
				'<text fill="black" text-anchor="end">Save</text>',
				null,
				'<text fill="white" text-anchor="end">Save</text>'
			);
			loadButton = new button(
				85, 140, loadAllImages,
				'<text fill="black" text-anchor="end">Load All</text>',
				null,
				'<text fill="white" text-anchor="end">Load All</text>'
			);
			

			// set up RGB to grayscale button
			RGB_BWbutton = new button(
				110, 115, switchRGB_BW,
				skinLibrary["RGB_BWButtonOn"],
				skinLibrary["RGB_BWButtonOff"],
				skinLibrary["blankButtonRadius13Highlight"]
			);
			
			// buttons to access panes
			statsButton = new button(
				190, 110, showStats,
				'<text fill="black" text-anchor="end">Stats</text>',
				null,
				'<text fill="white" text-anchor="end">Stats</text>'
			);
			scaleButton = new button(
				190, 120, showScale,
				'<text fill="black" text-anchor="end">Scale</text>',
				null,
				'<text fill="white" text-anchor="end">Scale</text>'
			);
			overlayButton = new button(
				190, 130, showOverlay,
				'<text fill="black" text-anchor="end">Overlay</text>',
				null,
				'<text fill="white" text-anchor="end">Overlay</text>'
			);
			settingsButton = new button(
				190, 140, showPreferences,
				'<text fill="black" text-anchor="end">Preferences</text>',
				null,
				'<text fill="white" text-anchor="end">Preferences</text>'
			);
				
		
			// z & t increment buttons
			tUpButton = new button(
				182, 25, tUp,
				skinLibrary["triangleRightWhite"]
			);
			tDownButton = new button(
				178, 25, tDown,
				skinLibrary["triangleLeftWhite"]
			);
			zUpButton = new button(
				15, 106, zUp,
				skinLibrary["triangleUpWhite"]
			);
			zDownButton = new button(
				15, 110, zDown,
				skinLibrary["triangleDownWhite"]
			);
				
			// z & t animation buttons
			tAnimUpButton = new button(
				182, 35, tAnimUp,
				skinLibrary["triangleRightRed"],
				null,
				skinLibrary["triangleRightWhite"]
			);
			tAnimDownButton = new button(
				178, 35, tAnimDown,
				skinLibrary["triangleLeftRed"],
				null,
				skinLibrary["triangleLeftWhite"]
			);
			zAnimUpButton = new button(
				15, 86, zAnimUp,
				skinLibrary["triangleUpRed"],
				null,
				skinLibrary["triangleUpWhite"]
			);
			zAnimDownButton = new button(
				15, 90, zAnimDown,
				skinLibrary["triangleDownRed"],
				null,
				skinLibrary["triangleDownWhite"]
			);
			
		// realize the GUI elements in the appropriate containers
            var controls  = svgDocument.getElementById("controls");
            controlToolBox.realize(controls);
            
            // Z & T controls
			zSlider.realize(controlToolBox.getGUIbox());
			tSlider.realize(controlToolBox.getGUIbox());
			tUpButton.realize(controlToolBox.getGUIbox());
			tDownButton.realize(controlToolBox.getGUIbox());
			zUpButton.realize(controlToolBox.getGUIbox());
			zDownButton.realize(controlToolBox.getGUIbox());
			tAnimUpButton.realize(controlToolBox.getGUIbox());
			tAnimDownButton.realize(controlToolBox.getGUIbox());
			zAnimUpButton.realize(controlToolBox.getGUIbox());
			zAnimDownButton.realize(controlToolBox.getGUIbox());

			loadButton.realize(controlToolBox.getGUIbox());

			// RGB & BW switcheroo
			RGB_BWbutton.realize(controlToolBox.getGUIbox());
			
			// Save button
			saveButton.realize(controlToolBox.getGUIbox());

			// RGB channel controls
			RGBpopupListBox = svgDocument.createElementNS( svgns, "g" );
			RGBpopupListBox.setAttribute( "transform", "translate( 95, 70 )" );
			controlToolBox.getGUIbox().appendChild( RGBpopupListBox );
			redButton.realize( RGBpopupListBox );
			greenButton.realize( RGBpopupListBox );
			blueButton.realize( RGBpopupListBox );
			redPopupList.realize( RGBpopupListBox );
			greenPopupList.realize( RGBpopupListBox );
			bluePopupList.realize( RGBpopupListBox );

			// Grayscale controls
			BWpopupListBox = svgDocument.createElementNS( svgns, "g" );
			BWpopupListBox.setAttribute( "transform", "translate( 95, 70 )" );
			BWpopupListBox.setAttribute( "display", "none" );
			controlToolBox.getGUIbox().appendChild( BWpopupListBox );
			bwPopupList.realize( BWpopupListBox );

			statsButton.realize( controlToolBox.getGUIbox() );
			scaleButton.realize( controlToolBox.getGUIbox() );
			overlayButton.realize( controlToolBox.getGUIbox() );
			settingsButton.realize( controlToolBox.getGUIbox() );

			// toolbox to house all other interfaces
			multiToolBox.realize(controls);

			// set up panes in the multi toolbox
// These panes to come from DB eventually?
			stats = new Statistics( Stats, fluors, updateStatsWave );
			multiToolBox.addPane( stats.buildSVG(), "Stats" );
			scale = new Scale(image, updateBlackLevel, updateWhiteLevel, scaleWaveChange);
			scale.updateScale(theT);
			multiToolBox.addPane( scale.buildSVG(), "Scale");
			overlay = new Overlay();
			multiToolBox.addPane( overlay.buildSVG(), "Overlay");
			viewerPreferences = new ViewerPreferences( resizeToolBox, resizeMultiToolBox, savePreferences );
			multiToolBox.addPane( viewerPreferences.buildSVG(), "Preferences");
			// finish setup & make controller
			multiToolBox.closeOnMinimize(true);
			
			panePopupList = new popupList(
				0, 0, multiToolBox.getPaneIndexes(), updatePane, 0,
				skinLibrary["popupListAnchorUpperLeftRoundedLightslategray"],
				skinLibrary["popupListBackgroundLightskyblue"],
				skinLibrary["popupListHighlightAquamarine"]
			);
			panePopupList.realize( multiToolBox.getMenuBar() );
			
			
			// voodoo to switch which component is rendered on top
			//  this makes the popupList be drawn on top 
			multiToolBox.nodes.GUIboxContainer.setAttribute( "onmouseover", 'multiToolBox.drawGUITop()' );
			multiToolBox.getMenuBar().setAttribute( "onmouseover", 'multiToolBox.drawMenuTop()' );


			azap.appendNode(controls);
			mouseTrap = svgDocument.getElementById("mouseTrap");
			azap.appendNode(mouseTrap); 

			// Set up display. These values come from DB eventually.
			var WBS = image.getWBS();
			setTimeout( "redPopupList.setSelectionByValue('"+ 
				redPopupList.getItemList()[ WBS[0] ]
				+"')", 0 );
			setTimeout( "greenPopupList.setSelectionByValue('"+ 
				greenPopupList.getItemList()[ WBS[3] ]
				+"')", 0 );
			setTimeout( "bluePopupList.setSelectionByValue('"+ 
				bluePopupList.getItemList()[ WBS[6] ]
				+"')", 0 );
			setTimeout( "bwPopupList.setSelectionByValue('"+ 
				bwPopupList.getItemList()[ WBS[9] ]
				+"')", 0 );
			var RGBon = image.getRGBon(); 
			setTimeout( "resizeToolBox(50 * ("+toolBoxScale+" - 1 ) )", 0);
			setTimeout( "multiToolBox.hide()", 0);
			setTimeout( "resizeMultiToolBox()", 500);
			setTimeout( "redButton.setState(" + (RGBon[0]==1 ? "true" : "false") + ")", 0 );
			setTimeout( "greenButton.setState(" + (RGBon[1]==1 ? "true" : "false") + ")", 0 );
			setTimeout( "blueButton.setState(" + (RGBon[2]==1 ? "true" : "false") + ")", 0 );
			setTimeout( "RGB_BWbutton.setState("+image.getDisplayRGB_BW()+")", 0 );
			setTimeout( "loadButton.setState(false)", 0 );
			zSlider.setValue(theZ/Z*100,true);
			tSlider.setValue(theT/T*100,true);

		}
		
ENDSVG

# more static stuff
$SVG .= <<'ENDSVG';
        
		
	// these functions connect GUI with backend
		function savePreferences() {
			var tmpImg;
			tmpImg = svgDocument.createElementNS(svgns,"image");
			tmpImg.setAttribute("width",0);
			tmpImg.setAttribute("height",0);
			// The purpose of unique is to bypass any image caching
			var unique   = Math.random();
			var imageURL = SaveDisplayCGI_URL + 
				'&toolBoxScale=' + controlToolBox.getScale() +
				"&Unique=" + unique;
			tmpImg.setAttributeNS(xlinkns, "xlink:href",imageURL);
		
			controlToolBox.getGUIbox().appendChild(tmpImg);
			controlToolBox.getGUIbox().removeChild(tmpImg);
		}
	
		function resizeToolBox(data) {
			viewerPreferences.toolBoxSizeSlider.setValue(data);
			controlToolBox.setScale(1 + data/50);	// resizes the controlToolBox
		}
		function resizeMultiToolBox() {
			multiToolBox.setScale( controlToolBox.getScale() );	// resizes the multiToolBox
		}

		
		function saveImage() {
			image.saveState();
		}
	
		function loadAllImages(val) {
			image.setPreload(true);
			image.setPreload(false);
		}
	
		function updateTheZ(data) {
			data=Math.round(data/100*(Z-1));
			var sliderVal = (Z==1 ? 0 : Math.round(data/(Z-1)*100) );
			zSlider.setValue(sliderVal);
			zSlider.setLabel(null, null, (data + 1) + "/" + Z );
			theZ=data;
			
			image.updatePic(theZ,theT);
		}
		function zUp() {
			var data = (theZ< Z-1 ? theZ + 1 : theZ)
			var sliderVal = ( Z==1 ? 0 : Math.round( data/(Z-1)*100 ) );
			updateTheZ(sliderVal);
		
		}
		function zDown() {
			var data = (theZ> 0 ? theZ - 1 : theZ)
			var sliderVal = ( Z==1 ? 0 : Math.round( data/(Z-1)*100 ) );
			updateTheZ(sliderVal);
		}
		function zAnimUp() {
			if(Z > 1) {
				for(i=theZ;i<Z;i++)
					setTimeout("updateTheZ(" + (i/(Z-1)) + "*100)", (i-theZ)*100);
			}
		}
		function zAnimDown() {
			if(Z > 1) {
				for(i=theZ;i>=0;i--)
					setTimeout("updateTheZ(" + (i/(Z-1)) + "*100)", (theZ-i)*100);
			}
		}

		function updateTheT(data) {
			if(data<0) data=0;
			theT=Math.round(data/100*(T-1));
			var sliderVal = ( T==1 ? 0 : Math.round(theT/(T-1)*100) );
			tSlider.setValue(sliderVal);
			tSlider.setLabel(null, null, "time (" + (theT+1) + "/" + T +")" );
			
			image.updatePic(theZ,theT);
			scale.updateScale(theT);
			stats.updateStats(theT);
		}
		function tUp() {
			var data = (theT< T-1 ? theT+1 : theT)
			var sliderVal = ( T==1 ? 0 : Math.round( data/(T-1)*100 ) );
			updateTheT(sliderVal);
		}
		function tDown() {
			var data = (theT> 0 ? theT -1 : theT)
			var sliderVal = ( T==1 ? 0 : Math.round( data/(T-1)*100 ) );
			updateTheT(sliderVal);
		}
		function tAnimUp() {
			if(T>1) {
				for(i=theT;i<T;i++)
					setTimeout("updateTheT(" + (i/(T-1)) + "*100)", (i-theT)*100);
			}
		}
		function tAnimDown() {
			if(T>1) {
				for(i=theT;i>=0;i--)
					setTimeout("updateTheT(" + (i/(T-1)) + "*100)", (theT-i)*100);
			}
		}

		// popupLists controlling channels
		function updateRedWavelength(item) {
			scale.updateWBS('R', item);
		}
		function updateGreenWavelength(item) {
			scale.updateWBS('G', item);
		}
		function updateBlueWavelength(item) {
			scale.updateWBS('B', item);
		}
		function updateBWWavelength(item) {
			scale.updateWBS('Gray', item);
			stats.changeWavenumber( item );
		}

		function updatePane(item) {
			var itemList = panePopupList.getItemList();
			multiToolBox.changePane( itemList[item] );
		}
		
		// buttons controlling channels
		function turnRedOnOff(val) {
			RGBon = image.getRGBon();
			RGBon[0] = (val ? 1 : 0);
			image.setRGBon(RGBon);
		}
		function turnGreenOnOff(val) {
			RGBon = image.getRGBon();
			RGBon[1] = (val ? 1 : 0);
			image.setRGBon(RGBon);
		}
		function turnBlueOnOff(val) {
			RGBon = image.getRGBon();
			RGBon[2] = (val ? 1 : 0);
			image.setRGBon(RGBon);
		}
		function switchRGB_BW(val) {
			//	decide which way to flip
			if(val) {	// val == true means mode = RGB
				BWpopupListBox.setAttribute( "display", "none" );
				RGBpopupListBox.setAttribute( "display", "inline" );
			}
			else {	// mode = BW
				BWpopupListBox.setAttribute( "display", "inline" );
				RGBpopupListBox.setAttribute( "display", "none" );
			}
			image.setDisplayRGB_BW(val);
		}
		
		function showOverlay() {
			panePopupList.setSelectionByValue("Overlay");
		}
		function showPreferences() {
			panePopupList.setSelectionByValue("Preferences");
		}

		// Stats stuff
		function showStats() {
			panePopupList.setSelectionByValue("Stats");
		}
		function updateStatsWave(wavenum) {
			stats.updateStats(theT);
		}

		// Scale stuff
		function updateBlackLevel(val) {
			// has scale been initialized?
			if(scale.image == null ) return;
			if(Math.round(val) == scale.blackBar.getAttribute("width")) return;

			// set up constants
			var wavenum = scale.wavePopupList.getSelection();
			var min = scale.Stats[wavenum][theT]['min'];
			var max = scale.Stats[wavenum][theT]['max'];
			var range = max-min;
			var geomean = scale.Stats[wavenum][theT]['geomean'];
			var sigma = scale.Stats[wavenum][theT]['sigma'];
			
			// correct val, crunch numbers
			if(val >= scale.whiteSlider.getValue())
				val = scale.whiteSlider.getValue() - 0.00001;
			var cBlackLevel = Math.round(val/scale.scaleWidth * range + min);
			val = (cBlackLevel-min)/range * scale.scaleWidth;

			// update backend
			var nBlackLevel = (cBlackLevel - geomean)/sigma;
			nBlackLevel = Math.round(nBlackLevel * 10) / 10;
			scale.BS[wavenum]['B'] = nBlackLevel;
			scale.updateWBS();

			// update display
			scale.blackSlider.setValue(val);
			scale.blackLabel.firstChild.data = "geomean + SD * " + nBlackLevel;
			scale.blackBar.setAttribute("width", Math.round(val) );
		}
		function updateWhiteLevel(val) {
			// has scale been initialized?
			if(scale.image == null ) return;
			if(Math.round(val) == scale.whiteBar.getAttribute("x")) return;

			// set up constants
			var wavenum = scale.wavePopupList.getSelection();
			var min = scale.Stats[wavenum][theT]['min'];
			var max = scale.Stats[wavenum][theT]['max'];
			var range = max-min;
			var geomean = scale.Stats[wavenum][theT]['geomean'];
			var sigma = scale.Stats[wavenum][theT]['sigma'];
			
			// correct val, crunch numbers
			if(val <= scale.blackSlider.getValue())
				val = scale.blackSlider.getValue() + 0.00001;
			var cWhiteLevel = Math.round(val/scale.scaleWidth * range + min);
			if(cWhiteLevel == geomean)
				cWhiteLevel -= 0.00001;
			val = (cWhiteLevel-min)/range * scale.scaleWidth;

			// update backend
			var nScale = (cWhiteLevel - geomean)/sigma;
			nScale = Math.round(nScale*10)/10;
			scale.BS[wavenum]['S'] = nScale;
			scale.updateWBS();

			// update display
			scale.whiteSlider.setValue(val);
			scale.whiteLabel.firstChild.data = "geomean + SD * " + nScale;
			scale.whiteBar.setAttribute("width", scale.scaleWidth - Math.round(val) );
			scale.whiteBar.setAttribute("x", Math.round(val) );
		}
		function scaleWaveChange(val) {
			scale.updateScale(theT);
		}
		function showScale() {
			panePopupList.setSelectionByValue("Scale");
		}
		
    ]]></script>
	<g id="mouseTrap">
		<!-- The mouse only registers over elements. This rect prevents
			 loosing the mouse while moving the toolbox. It is drawn first
			 so it will be placed
			 on bottom so it will not trap mouse events unless nothing
			 else does. -->
		<rect width="100%" height="100%" fill="blue" opacity="0"/>	
	</g>
	<g id="image">
	</g>
	<g id="overlays">
	</g>
	<g id="controls">
	</g>
</svg>
ENDSVG
;

	return $SVG;
}

1;
