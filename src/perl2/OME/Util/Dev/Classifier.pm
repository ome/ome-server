# OME/Util/Classifier.pm

#-------------------------------------------------------------------------------
#
# Copyright (C) 2003 Open Microscopy Environment
#       Massachusetts Institute of Technology,
#       National Institutes of Health,
#       University of Dundee
#
#
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#-------------------------------------------------------------------------------




#-------------------------------------------------------------------------------
#
# Written by:    Josiah Johnston <siah@nih.gov>
#
#-------------------------------------------------------------------------------

package OME::Util::Classifier;

use strict;
use OME;
our $VERSION = $OME::VERSION;

use base qw(OME::Util::Commands);

use Carp;
use Getopt::Long;

use Log::Agent;
use XML::LibXML;
use XML::LibXSLT;
use OME::SessionManager;
use OME::Session;
use OME::Tasks::ImageTasks;
use OME::Tasks::ChainManager;
use OME::Tasks::OMEImport;
use OME::ImportExport::ChainExport;
use OME::Matlab;

use Getopt::Long;
Getopt::Long::Configure("bundling");



sub getCommands {
    return
      {
       'stitch_chain' => 'stitch_chain',
       'compile_sigs' => 'compile_sigs'
      };
}

sub compile_sigs_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

This will compile a signature matrix for a matlab Trainer. It needs a
complete signature chain (e.g. a chain generated by 'stitch_chain'), and
a dataset that has exactly one classification per image. It will execute
the signature chain if necessary. There will be one row per image in the
matrix. Each row will be formatted like so:

[ image_class sig_1 sig_2 ... ]

The original signature chain must already be imported into the database. 

Options:

  -d  dataset id
  
  -c  signature chain id
  
  -o  name of output file
  
  -f  force re-execution of chain
  
  -h  Print this help message.
  
USAGE
    CORE::exit(1);
}


sub stitch_chain_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

This will create a custom Signature Stitcher module for a signature
chain. Additionally, it will copy the chain and attach the stitcher
module to the copy. The newly created module and chain will be imported
to the database and saved to disk.

The original signature chain must already be imported into the database. 

Options:

  -x  path of xml source directory
  
  -o  output directory
  
  -c  the name of the signature chain to stitch
      
  -compress  Compress the output file. 

  -h  Print this help message.
  
USAGE
    CORE::exit(1);
}

# constants
our $OME_NS = 'http://www.openmicroscopy.org/XMLschemas/CA/RC1/CA.xsd';
our $AML_NS = 'http://www.openmicroscopy.org/XMLschemas/AnalysisModule/RC1/AnalysisModule.xsd';
our $XSI_NAMESPACE = 'http://www.w3.org/2001/XMLSchema-instance';
use constant SIG_MODULE_STDS => <<END_STDS;
<SemanticTypeDefinitions 
  xmlns=
    "http://www.openmicroscopy.org/XMLschemas/STD/RC2/STD.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation = "
    http://www.openmicroscopy.org/XMLschemas/STD/RC2/STD.xsd
      http://www.openmicroscopy.org/XMLschemas/STD/RC2/STD.xsd">
	
	<SemanticType Name="SignatureVectorEntry" AppliesTo="I">
	  <Description>A single image signature. A signature describes
	  something about the image. i.e. number of blobs, whether the
	  texture is rough or smooth, etc.</Description>
      <Element Name="Value"  DBLocation="SIGNATURE.VALUE" DataType="double"/>
      <Element Name="Legend"  DBLocation="SIGNATURE.LEGEND" DataType="reference" RefersTo="SignatureVectorLegend"/>
    </SemanticType>
    
	<SemanticType Name="SignatureVectorLegend" AppliesTo="D">
	  <Description>Describes the data derivation of a position in a
	  signature vector. I (Josiah) have been thinking about this having
	  global granularity. This isn't feasible ATM because modules that
	  accept non global inputs are not allowed to produce global
	  outputs.</Description>
      <Element Name="VectorPosition"  DBLocation="SIGNATURE_LEGEND.VECTOR_POSITION" DataType="integer">
      	<Description>Will be in the range of 1 to N, where N is the
      	number of vector positions.</Description>
      </Element>
      <Element Name="FormalInput"  DBLocation="SIGNATURE_LEGEND.FORMAL_INPUT_NAME" DataType="string">
      	<Description>The name of the formal input assigned to this
      	vector position. The function of this is to describe the data
      	history. The data history can be accurately derived because
      	the chain will have been locked by the time this is
      	produced.</Description>
      </Element>
      <Element Name="SemanticElement"  DBLocation="SIGNATURE_LEGEND.SEMANTIC_ELEMENT_NAME" DataType="string">
      	<Description>The name of the semantic element of the formal
      	input assigned to this vector position.</Description>
      </Element>
    </SemanticType>
</SemanticTypeDefinitions>
END_STDS

sub compile_sigs {
	my ($self,$commands) = @_;
	my ($dataset_id, $chain_id, $output_file_name, $show_help, $force_new_chex );
	
	GetOptions('d=i' => \$dataset_id, 'c=i' => \$chain_id, 'o=s' => \$output_file_name, 'h' => \$show_help, 'f' => \$force_new_chex );
	return $self->compile_sigs_help($commands) if $show_help;
	die "one or more options not specified"
		unless $dataset_id and $chain_id and $output_file_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	
	# load objects
	logdbg "debug", "loading chain, dataset, and signature stitcher chain node";
	my $chain = $factory->loadObject( "OME::AnalysisChain", $chain_id )
		or die "Cannot find an analysis chain with id = $chain_id";
	my $sig_stitch_node = $factory->findObject( "OME::AnalysisChain::Node",
		analysis_chain  => $chain,
		'module.name'   => [ 'like', 'Signature Stitcher%' ]
	) or die "Could not find a signature stitcher module in chain (id = $chain_id, name = '".$chain->name."')";
	logdbg "debug", "found signature stitcher module (name=".$sig_stitch_node->module->name()."), node (id=".$sig_stitch_node->id.".";
	my $dataset = $factory->loadObject( "OME::Dataset", $dataset_id )
		or die "Cannot find a dataset with id = $dataset_id";
	my @images = $dataset->images;
	@images = sort {$a->id <=> $b->id} @images;
	
	# collect image classifications.
	logdbg "debug", "collecting image classifications.";
	my %classifications;
	my $category_group;
	foreach my $image ( @images ) {
		my @classification_list = $factory->findAttributes( 'Classification', image => $image )
			or die "Could not find a classification for image id=".$image->id;
		die "More than one classification found for image id=".$image->id
			unless scalar( @classification_list ) eq 1;
		$category_group = $classification_list[0]->Category->CategoryGroup
			unless $category_group;
		die "Classification for image id=".$image->id." does not belong to the same category group as other images in this dataset."
			unless $category_group->id eq $classification_list[0]->Category->CategoryGroup->id;
		$classifications{ $image->id } = $classification_list[0];
	}
	# map categories to category numbers
	my @categories = $factory->findAttributes( "Category", CategoryGroup => $category_group );
	my %category_numbers;
	my $cn = 0;
	foreach( sort { $a->name cmp $b->name } @categories ) {
		$cn++;
		$category_numbers{ $_->id } = $cn;
	}
	
	# collect sig stitcher module execution for this chain
	logdbg "debug", "finding signature stitcher module execution.";
	my $chex;
	unless( $force_new_chex ) {
		$chex = $factory->findObject( "OME::AnalysisChainExecution",
			analysis_chain => $chain,
			dataset        => $dataset
		) unless $force_new_chex;
		unless ($chex) {
			logdbg "debug", "Could not find execution of chain (id=".$chain->id."). Executing chain";
			$chex = OME::Analysis::Engine->executeChain($chain,$dataset);
		}
	} else {
		$chex = OME::Analysis::Engine->executeChain($chain,$dataset,{}, ReuseResults => 0);
	}
	my $stitcher_nex = $factory->findObject( "OME::AnalysisChainExecution::NodeExecution",
		analysis_chain_execution => $chex,
		analysis_chain_node      => $sig_stitch_node
	) or die "Could not load a chain node execution for the signature stitcher node (id=".$sig_stitch_node->id."), chain execution (id=".$chex->id.").";
	my $stitcher_mex = $stitcher_nex->module_execution;
	die "signature stitcher (".$stitcher_mex->module->name.") module execution (id=".$stitcher_mex->id.") has 'ERROR' status!"
		if $stitcher_mex->status() eq 'ERROR';
	logdbg "debug", "found signature stitcher module execution (mex=".$stitcher_mex->id().").";
	
	# make the matlab signature array. 
	#	number of columns is the size of the signature vector plus one for the image classification.
	#	number of rows is the number of images.
	logdbg "debug", "Making the signature array.";
	my @vector_legends = $factory->findAttributes( "SignatureVectorLegend", module_execution => $stitcher_mex )
		or die "Could not load signature vector legend for mex (id=".$stitcher_mex->id.")";
	my $signature_array = OME::Matlab::Array->newDoubleMatrix(scalar( @vector_legends ) + 1, scalar( @images ));
	$signature_array->makePersistent();
	
	# load the signature outputs for each image
	my $image_number = 0;
	my @sig_array;
	foreach my $image ( @images ) {
		my $signature_entry_iterator = $factory->findAttributes( "SignatureVectorEntry", 
			module_execution => $stitcher_mex,
			image            => $image
		) or die "Could not load image signature vector for image (id=".$image->id."), mex (id=".$stitcher_mex->id.")";
		# set the image category
		$sig_array[$image_number][0] = 
			$category_numbers{ $classifications{ $image->id }->Category->id };
		# set the image's signature vector
		while (my $sig_entry = $signature_entry_iterator->next()) {
			$sig_array[$image_number][$sig_entry->Legend->VectorPosition()] = 
				$sig_entry->Value();
		}
		$signature_array->setAll( @sig_array );
		$image_number += 1;
	}

	# save the array to disk
	logdbg "debug", "Saving the array to disk.";
	my $engine = OME::Matlab::Engine->open("matlab -nodisplay -nojvm")
		or die "Cannot open a connection to Matlab!";
	$output_file_name .= '.mat' unless $output_file_name =~ m/\.mat$/;
	$engine->eval("global signature_vector");
	$engine->putVariable('signature_vector',$signature_array);
	$engine->eval( "save $output_file_name signature_vector;" );
	print "Saved signature vector to file $output_file_name.\n";
	$engine->close();
	$engine = undef;
}	

sub stitch_chain {
	my ($self,$commands) = @_;
	my ($xml_src, $outdir, $compression, $chain_name );
	
	GetOptions('x=s' => \$xml_src, 'o=s' => \$outdir, 'c=s' => \$chain_name, 'compress' => \$compression );
	$compression = ( $compression ? 7 : 0 );
	die "one or more options not specified"
		unless $xml_src and $outdir and $chain_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	
	# find modules that produce signatures
	# simple implementation of leaf nodes for now
	logdbg "debug", "Finding Signature Modules in chain $chain_name";
	my $chain = $factory->findObject( "OME::AnalysisChain", name => $chain_name )
		or die "cannot find chain named $chain_name";
	my @signature_nodes = OME::Tasks::ChainManager->findLeaves( $chain );
	logdbg "debug", "Found chain nodes. Format of output is 'module_name(node_id)'\n\t".
		join( ', ', map( $_->module->name."(".$_->id.")", @signature_nodes ) );
	
	##############
	# create signature module (xml)
	logdbg "debug", "Creating signature module";
	my $doc = XML::LibXML::Document->new();
	die "Cannot create XML document"
	  unless defined $doc;
	my $root = $doc->createElementNS($OME_NS,'OME');
	$root->setNamespace($XSI_NAMESPACE, 'xsi',0);
	$root->setAttributeNS($XSI_NAMESPACE,'schemaLocation',"$OME_NS $OME_NS");
	$doc->setDocumentElement($root);

	# Parse the STDs
	my $parser = XML::LibXML->new();
	my $STD_doc = $parser->parse_string( SIG_MODULE_STDS );
	$root->appendChild( $STD_doc->documentElement() );
	
	# add the module library
	my $module_library = $doc->createElementNS($AML_NS,'AnalysisModuleLibrary');
	$root->appendChild( $module_library );
	
	# Make the module
	my $module = $doc->createElement('AnalysisModule');
	$module->setAttribute( 'ModuleType', "OME::Analysis::Modules::Classification::SignatureStitcher");
	$module->setAttribute( 'Category', "Classifier");
	my $new_LSID = $self->get_next_LSID( $xml_src );
	$module->setAttribute( 'ID', $new_LSID );
	$new_LSID =~ m/urn:lsid:openmicroscopy.org:Module:(\d+)/;
	my $module_name = "Signature Stitcher ($1)";
	$module->setAttribute( 'ModuleName', $module_name );
	$module->setAttribute( 'ProgramID', "" );
	$module_library->appendChild( $module );
		
	# Make the description
	my $module_description = $doc->createElement('Description');
	$module_description->appendChild( XML::LibXML::Text->new( <<ENDDESCRIPTION ) );
Combines outputs from "signature modules" into a single vector that
describes the image. This stitching is very handy for classifiers.
ENDDESCRIPTION
	$module->appendChild( $module_description );
	
	# Declaration
	my $declaration = $doc->createElement('Declaration');
	$module->appendChild( $declaration );
	
	# Inputs
	my %input_links_by_ST; # values will be array of each link coming in of the same ST
	# round one: gather inputs links
	foreach my $sig_node ( @signature_nodes ) {
		foreach my $output ( $sig_node->module->outputs ) {
			my $ST_name = $output->semantic_type->name;
			push( @{ $input_links_by_ST{ $ST_name } }, {
				from_node   => $sig_node,
				from_output => $output
			} );
		}
	}
	# round two: sort links, translate them to inputs, record mapping from links to inputs
	my %input_links_by_input; # flat hash to store link info. key by input name
	foreach my $ST_name ( keys %input_links_by_ST ) {
		my $name_incrementer = 0;
		foreach my $input_link( @{ $input_links_by_ST{ $ST_name } } ) {
			$name_incrementer++;
			my $input_name;
			if( scalar( @{ $input_links_by_ST{ $ST_name } } ) eq 1 ) {
				$input_name = $ST_name;
			} else {
				$input_name = "$ST_name $name_incrementer";
			}
			my $formal_input = $doc->createElement( 'FormalInput');
			$formal_input->setAttribute( 'Name', $input_name );
			$formal_input->setAttribute( 'SemanticTypeName', $ST_name );
			$formal_input->setAttribute( 'Count', '!' );
			$declaration->appendChild( $formal_input );
			$input_links_by_input{ $input_name } = $input_link;
		}
	}
	
	# Outputs
	my $formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'SignatureVector' );
	$formal_output->setAttribute( 'SemanticTypeName', 'SignatureVectorEntry' );
	$formal_output->setAttribute( 'Count', '+' );
	$declaration->appendChild( $formal_output );
	$formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'VectorLegend' );
	$formal_output->setAttribute( 'SemanticTypeName', 'SignatureVectorLegend' );
	$formal_output->setAttribute( 'Count', '+' );
	$declaration->appendChild( $formal_output );
	
	# save to disk
	my $file_name = $module_name;
	$file_name =~ s/ //g;
	$file_name = $outdir. '/' . $file_name . ".ome";
	$doc->toFile( $file_name, 2 );
	logdbg "debug", "Saved signature module to $file_name";
	
	# import module
	logdbg "debug", "Importing module $module_name into DB";
	OME::Tasks::ImageTasks::importFiles (undef, [ $file_name ] );
	my $stitcher_module = $factory->findObject( "OME::Module", name => $module_name )
		or die "Could not load Signature Stitcher module named '$module_name'";
	
	# create new chain that includes signature module (db)
	logdbg "debug", "Creating new chain that includes the stitcher";
	my ($new_chain, $node_mapping) = OME::Tasks::ChainManager->cloneChain( $chain, undef, 'gimme node mapping!' );
	$new_chain->name( "Autogenerated Signature chain ".$new_chain->id );
	$new_chain->storeObject();
	my $stitcher_node  = $factory->newObject( 'OME::AnalysisChain::Node', {
		module         => $stitcher_module,
		analysis_chain => $new_chain
	} );
	# make links
	foreach my $input_name ( keys %input_links_by_input ) {
		my $formal_input = $factory->findObject( "OME::Module::FormalInput",
			module => $stitcher_module,
			name   => $input_name
		) or die "Couldn't load input $input_name for module $module_name";
		my $from_node = $node_mapping->{ $input_links_by_input{ $input_name }{ 'from_node' }->id };
		my $data = {
			to_node     => $stitcher_node,
			to_input    => $formal_input,
			from_node   => $from_node,
			from_output => $input_links_by_input{ $input_name }{ 'from_output' },
			analysis_chain => $new_chain
		};
		$factory->newObject( "OME::AnalysisChain::Link", $data )
			or die "Couldn't make link from ".
				$input_links_by_input{ $input_name }{ 'from_node' }->module->name.'.'.
				$input_links_by_input{ $input_name }{ 'from_output' }->name.
				" to $module_name.$input_name";
	}
	$session->commitTransaction();
	
	
	# save new chain to disk
	my $chain_file = $new_chain->name().'.'.$new_chain->id.'.ome';
	$chain_file =~ s/ //g;
	$chain_file = $outdir. '/' . $chain_file;
	logdbg "debug", "Saving new chain to $chain_file";
	my $chainExport = OME::ImportExport::ChainExport->new();
	$chainExport->buildDOM ([$new_chain]);
	$chainExport->exportFile ($chain_file, compression => 0 );
	
}

sub get_next_LSID {
	my ($self, $xml_src ) = @_;
	my $session = $self->getSession();
	my $factory = $session->Factory();
	my $high_id=7200;

	# check module LSIDs in the xml directory.
	if( $xml_src ) {
		# FIXME: use something besides backticks to get the next LSID from the xml source files.
		my @grep_results = `grep -r 'urn:lsid:openmicroscopy.org:Module:72' $xml_src/*`;
		foreach( @grep_results ) {
			if( m/urn:lsid:openmicroscopy.org:Module:(72\d\d)/ ) {
				$high_id = $1 if $1 gt $high_id;
			}
		}
	}
	
	# just for yucks, check against LSIDs from the DB
	my @LSIDs = $factory->findObjects( "OME::LSID",
		lsid => [ 'like', 'urn:lsid:openmicroscopy.org:Module:72%' ]
	);
	foreach( map( $_->lsid, @LSIDs) ) {
		if( m/urn:lsid:openmicroscopy.org:Module:(72\d\d)/ ) {
			$high_id = $1 if $1 gt $high_id;
		}		
	}

	return 'urn:lsid:openmicroscopy.org:Module:'.($high_id + 1);
}
