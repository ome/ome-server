# OME/Util/Dev/Classifier.pm

#-------------------------------------------------------------------------------
#
# Copyright (C) 2003 Open Microscopy Environment
#       Massachusetts Institute of Technology,
#       National Institutes of Health,
#       University of Dundee
#
#
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#
# Written by:    Josiah Johnston <siah@nih.gov>
#
#-------------------------------------------------------------------------------

package OME::Util::Dev::Classifier;

use strict;
use OME;
our $VERSION = $OME::VERSION;

use base qw(OME::Util::Commands);

use Carp;
use Getopt::Long;

use Log::Agent;
use XML::LibXML;
use XML::LibXSLT;
use OME::SessionManager;
use OME::Session;
use OME::Tasks::ImageManager;
use OME::Tasks::ImageTasks;
use OME::Tasks::ChainManager;
use OME::Tasks::OMEImport;
use OME::Tasks::ModuleTasks;
use OME::Tasks::ModuleExecutionManager;
use OME::ImportExport::ChainExport;
use OME::Matlab;
use OME::Session;

use Getopt::Long;
Getopt::Long::Configure("bundling");



sub getCommands {
    return
      {
       'stitch_chain' => 'stitch_chain',
       'compile_sigs' => 'compile_sigs',
       'compile_chain' => 'compile_chain',
      };
}

sub compile_sigs_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

This will compile a signature matrix for a matlab Trainer. It needs a
complete signature chain (e.g. a chain generated by 'stitch_chain'), and
a dataset that has exactly one classification per image. It will execute
the signature chain if necessary. There will be one row per image in the
matrix. Each column represents another image. Each row represents one
signature, and the last row is the image class. If the image has no
classification, the class will be 0.

	        Img 1  Img 2  ...
	Sig 1 [     x,     x, ... ]
	Sig 2 [     x,     x, ... ]
	...   [   ...,   ..., ... ]
	Sig n [     x,     x, ... ]
	Class [     x,     x, ... ]

The original signature chain must already be imported into the database. 

Options:
  -a  Signature analysis chain name or ID.

  -d  Dataset name or ID.

  -e  Analysis Chain Execution ID. This Optional parameter takes precedence over
      the -a and -d flags. If you specify this then you don't need to specify
      -a and -d. This is especially useful if the analysis chain was executed
      multiple times against the dataset.
  
  -o  Output filename.
  
  -f, --force
    Force re-execution of chain (i.e. do not reuse previous module execution 
    results).
    
USAGE
}


sub stitch_chain_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

This will create a custom Signature Stitcher module for a signature
chain. Additionally, it will copy the chain and attach the stitcher
module to the copy. The newly created module and chain will be imported
to the database and saved to disk.

The original signature chain must already be imported into the database. 

Options:
  -a  the id or name of the signature chain to stitch

  -x  path of xml source directory
  
  -o  output directory
        
  -compress  Compress the output file. 
  
USAGE
}

# constants
our $OME_NS = 'http://www.openmicroscopy.org/XMLschemas/CA/RC1/CA.xsd';
our $AML_NS = 'http://www.openmicroscopy.org/XMLschemas/AnalysisModule/RC1/AnalysisModule.xsd';
our $XSI_NAMESPACE = 'http://www.w3.org/2001/XMLSchema-instance';
use constant SIG_MODULE_STDS => <<END_STDS;
<SemanticTypeDefinitions 
  xmlns=
    "http://www.openmicroscopy.org/XMLschemas/STD/RC2/STD.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation = "
    http://www.openmicroscopy.org/XMLschemas/STD/RC2/STD.xsd
      http://www.openmicroscopy.org/XMLschemas/STD/RC2/STD.xsd">
	
	<SemanticType Name="SignatureVectorEntry" AppliesTo="F">
	  <Description>A single image signature. A signature describes
	  something about the image. i.e. number of blobs, whether the
	  texture is rough or smooth, etc.</Description>
      <Element Name="Value"  DBLocation="SIGNATURE.VALUE" DataType="double"/>
      <Element Name="Legend"  DBLocation="SIGNATURE.LEGEND" DataType="reference" RefersTo="SignatureVectorLegend"/>
    </SemanticType>
    
	<SemanticType Name="SignatureVectorLegend" AppliesTo="D">
	  <Description>Describes the data derivation of a position in a
	  signature vector. I (Josiah) have been thinking about this having
	  global granularity. This isn't feasible ATM because modules that
	  accept non global inputs are not allowed to produce global
	  outputs.</Description>
      <Element Name="VectorPosition"  DBLocation="SIGNATURE_LEGEND.VECTOR_POSITION" DataType="integer">
      	<Description>Will be in the range of 1 to N, where N is the
      	number of vector positions.</Description>
      </Element>
      <Element Name="FormalInput"  DBLocation="SIGNATURE_LEGEND.FORMAL_INPUT_NAME" DataType="string">
      	<Description>The name of the formal input assigned to this
      	vector position. The function of this is to describe the data
      	history. The data history can be accurately derived because
      	the chain will have been locked by the time this is
      	produced.</Description>
      </Element>
      <Element Name="SemanticElement"  DBLocation="SIGNATURE_LEGEND.SEMANTIC_ELEMENT_NAME" DataType="string">
      	<Description>The name of the semantic element of the formal
      	input assigned to this vector position.</Description>
      </Element>
    </SemanticType>
</SemanticTypeDefinitions>
END_STDS

sub compile_sigs {
	my ($self,$commands) = @_;
	my ($datasetStr, $chainStr, $output_file_name, $chex_id, $force_new_chex );
	
	GetOptions ('d=s' => \$datasetStr,
	            'a=s' => \$chainStr,
	            'o=s' => \$output_file_name,
	            'e=i' => \$chex_id,
	            'f|force' => \$force_new_chex );
	            
	die "one or more options not specified"
		unless (($datasetStr and $chainStr) or $chex_id) and $output_file_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	
	logdbg "debug", "loading chain, dataset, and signature stitcher chain node";
	
	# sanity check
	die "Cannot specify options -f and -e. \n" if (defined $chex_id and $force_new_chex);
	
	# get chex if appropriate
	my $chex;
	my $chain;
	my $dataset;
	
	if ($chex_id) {
		$chex = $factory->findObject( "OME::AnalysisChainExecution",
			id => $chex_id,
		);
		die "Could not find chain execution with (id=".$chex_id.")"
			unless ($chex);
		$chain   = $chex->analysis_chain();
		$dataset = $chex->dataset();
		print $chain->name()."  ".$dataset->name()."\n";
	}

	# get chain	if neccessary
	if (not defined $chain) {
		if ($chainStr =~ /^([0-9]+)$/) {
			$chain= $factory->loadObject( "OME::AnalysisChain", $chainStr )
				or die "Cannot find an analysis chain with id = $chainStr";
		} else {
			my $chainData = {name => $chainStr};
			$chain = $factory->findObject( "OME::AnalysisChain", $chainData)
				or die "Cannot find an analysis chain with name = $chainStr";
		}
	}
	
	# get signature module
	my $sig_stitch_node = $factory->findObject( "OME::AnalysisChain::Node",
		analysis_chain  => $chain,
		'module.name'   => [ 'like', 'Signature Stitcher%' ]
	) or die "Could not find a signature stitcher module in chain (id = $chainStr, name = '".$chain->name."')";
	logdbg "debug", "found signature stitcher module (name=".$sig_stitch_node->module->name()."), node (id=".$sig_stitch_node->id.".";
	
	
	# get dataset if neccesary
	if (not defined $dataset) {
		if ($datasetStr =~ /^([0-9]+)$/) {
			my $datasetID = $1;
			$dataset = $factory->loadObject ("OME::Dataset", $datasetID);
			die "Dataset with ID $datasetStr doesn't exist!" unless $dataset;
		} else {
			my $datasetData = {
								name   => $datasetStr,
								owner  => $session->User(),
							  };
			$dataset = $factory->findObject( "OME::Dataset", $datasetData);
			die "Dataset with name $datasetStr doesn't exist!" unless $dataset;
		}
	}
	
	# open MATLAB connection
	my $engine = OME::Matlab::Engine->open("matlab -nodisplay -nojvm")
	or die "Cannot open a connection to Matlab!";
	
	# Find the chain execution or re-execute the chain
	logdbg "debug", "finding signature stitcher module execution.";
	if ($force_new_chex) {
		$chex = OME::Analysis::Engine->executeChain($chain,$dataset,{}, undef, ReuseResults => 0);
	} else {
		# chex might already be loaded if chex_id was specified as program parameter
		$chex = $factory->findObject( "OME::AnalysisChainExecution",
			analysis_chain => $chain,
			dataset        => $dataset
		) unless ($chex);
		
		if (not $chex) {
			logdbg "debug", "Could not find execution of chain (id=".$chain->id."). Executing chain";
			$chex = OME::Analysis::Engine->executeChain($chain,$dataset);
		}
	}
	
	# collect sig stitcher module execution for this chain
	my $stitcher_nex = $factory->findObject( "OME::AnalysisChainExecution::NodeExecution",
		analysis_chain_execution => $chex,
		analysis_chain_node      => $sig_stitch_node
	) or die "Could not load a chain node execution for the signature stitcher node (id=".$sig_stitch_node->id."), chain execution (id=".$chex->id.").";
	my $stitcher_mex = $stitcher_nex->module_execution;
	die "signature stitcher (".$stitcher_mex->module->name.") module execution (id=".$stitcher_mex->id.") has 'ERROR' status!"
		if $stitcher_mex->status() eq 'ERROR';
	logdbg "debug", "found signature stitcher module execution (mex=".$stitcher_mex->id().").";
	
	my @images = $dataset->images( __order => ['name', 'id'] );
	
	# make an array of image_paths/feature names
	# img_path [feature name]
	# img_path [feature name]
	# ...
	my @image_paths; # this is the name of the image's original file
	foreach my $img (@images) {
		my $originalFile = OME::Tasks::ImageManager->getImageOriginalFiles($img);
		die "Image ".$_->name." doesn't have exactly one Original File"
			if( ref( $originalFile ) eq 'ARRAY' );
		
		my @features = $img->all_features();
		@features = sort {$a->id <=> $b->id} @features;
		foreach (@features) {
			push @image_paths, $originalFile->Path()." [".$_->name()."]";
		}
	}
	# sort images by image_path not image name to match MATLAB sort order
	# so /CHO/tumor.tiff will be before /Pollen/obj_198_1.tiff
	my @image_path_indices = sort{$image_paths[$a] cmp $image_paths[$b]}0..$#images;
	@images = @images[@image_path_indices];
	@image_paths = @image_paths[@image_path_indices];
	
	# make the matlab signature array and label array
	my ($category_names_array, $signature_labels_array, $signature_array) = $self->
		compile_signature_matrix( $stitcher_mex, \@images, scalar(@image_paths)); 	# last parameter is the number of image rois
																					# which is the number of columns of the sig matrix

	# save the array to disk
	logdbg "debug", "Saving the array to disk.";
	$output_file_name .= '.mat' unless $output_file_name =~ m/\.mat$/;
	
	$engine->eval("global category_names_char_array");
	$engine->putVariable('category_names_char_array',$category_names_array);
	# Convert the rectangualar string array that has null terminated strings into a cell array.
	# Cell arrays are easier to deal with for strings.
	$engine->eval( "for i=1:size( category_names_char_array, 1 ),".
	               "category_names{i} = sprintf( '%s', category_names_char_array(i,:) ); ".
	               "end;" );
	               
	$engine->eval("global signature_labels_char_array");
	$engine->putVariable('signature_labels_char_array',$signature_labels_array);
	$engine->eval( "for i=1:size( signature_labels_char_array, 1 ),".
	               "signature_labels{i} = sprintf( '%s', signature_labels_char_array(i,:) ); ".
	               "end;" );

	$engine->eval("global image_paths_char_array");
	$engine->putVariable('image_paths_char_array', OME::Matlab::Array->newStringArray(\@image_paths));
	$engine->eval( "for i=1:size( image_paths_char_array, 1 ),".
	               "image_paths{i} = sprintf( '%s', image_paths_char_array(i,:) ); ".
	               "end;" );

	$engine->eval("global signature_matrix");
	$engine->putVariable('signature_matrix',$signature_array);

	$engine->eval( "dataset_name = '".$dataset->name()."';" );
	$engine->eval( "save $output_file_name dataset_name category_names signature_labels signature_matrix image_paths;" );
	print "Saved signature matrix to file $output_file_name.\n";
	$engine->close();
	$engine = undef;
}	

sub compile_chain {
	my ($self,$commands) = @_;
	my ($datasetStr, $chainStr, $output_file_name, $chex_id);
	
	GetOptions ('d=s' => \$datasetStr,
	            'a=s' => \$chainStr,
	            'o=s' => \$output_file_name,
	            'e=i' => \$chex_id);
	            
	die "one or more options not specified"
		unless (($datasetStr and $chainStr) or $chex_id) and $output_file_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	
	logdbg "debug", "loading chain, dataset, and signature stitcher chain node";
	
	# get chex if appropriate
	my $chex;
	my $chain;
	my $dataset;
	
	if ($chex_id) {
		$chex = $factory->findObject( "OME::AnalysisChainExecution",
			id => $chex_id,
		);
		die "Could not find chain execution with (id=".$chex_id.")"
			unless ($chex);
		$chain   = $chex->analysis_chain();
		$dataset = $chex->dataset();
		print $chain->name()."  ".$dataset->name()."\n";
	}

	# get chain	if neccessary
	if (not defined $chain) {
		if ($chainStr =~ /^([0-9]+)$/) {
			$chain= $factory->loadObject( "OME::AnalysisChain", $chainStr )
				or die "Cannot find an analysis chain with id = $chainStr";
		} else {
			my $chainData = {name => $chainStr};
			$chain = $factory->findObject( "OME::AnalysisChain", $chainData)
				or die "Cannot find an analysis chain with name = $chainStr";
		}
	}
	
	# get signature module
	my $sig_stitch_node = $factory->findObject( "OME::AnalysisChain::Node",
		analysis_chain  => $chain,
		'module.name'   => [ 'like', 'Signature Stitcher%' ]
	) or die "Could not find a signature stitcher module in chain (id = $chainStr, name = '".$chain->name."')";
	logdbg "debug", "found signature stitcher module (name=".$sig_stitch_node->module->name()."), node (id=".$sig_stitch_node->id.".";
	
	
	# get dataset if neccesary
	if (not defined $dataset) {
		if ($datasetStr =~ /^([0-9]+)$/) {
			my $datasetID = $1;
			$dataset = $factory->loadObject ("OME::Dataset", $datasetID);
			die "Dataset with ID $datasetStr doesn't exist!" unless $dataset;
		} else {
			my $datasetData = {
								name   => $datasetStr,
								owner  => $session->User(),
							  };
			$dataset = $factory->findObject( "OME::Dataset", $datasetData);
			die "Dataset with name $datasetStr doesn't exist!" unless $dataset;
		}
	}
	
	# Find the chain execution
	# chex might already be loaded if chex_id was specified as program parameter
	$chex = $factory->findObject( "OME::AnalysisChainExecution",
		analysis_chain => $chain,
		dataset        => $dataset
	) unless ($chex);
	
	if (not $chex) {
		logdbg "debug", "Could not find execution of chain (id=".$chain->id."). Executing chain";
		$chex = OME::Analysis::Engine->executeChain($chain,$dataset);
	}
	
	# collect sig stitcher module execution for this chain
	my $stitcher_nex = $factory->findObject( "OME::AnalysisChainExecution::NodeExecution",
		analysis_chain_execution => $chex,
		analysis_chain_node      => $sig_stitch_node
	) or die "Could not load a chain node execution for the signature stitcher node (id=".$sig_stitch_node->id."), chain execution (id=".$chex->id.").";
	my $stitcher_mex = $stitcher_nex->module_execution;
	die "signature stitcher (".$stitcher_mex->module->name.") module execution (id=".$stitcher_mex->id.") has 'ERROR' status!"
		if $stitcher_mex->status() eq 'ERROR';
	logdbg "debug", "found signature stitcher module execution (mex=".$stitcher_mex->id().").";
	
	# get vector_legends.
	my $vector_legends_ptr = OME::Tasks::ModuleExecutionManager->
		getAttributesForMEX( $stitcher_mex, "SignatureVectorLegend" )
		or die "Could not load signature vector legend for mex (id=".$stitcher_mex->id.")";
	my @vector_legends = sort {$a->VectorPosition <=> $b->VectorPosition} @$vector_legends_ptr;
	
	
	my @signature_labels =  map( $_->FormalInput(), @vector_legends);
	
	###
	### Open file for writing
	###
	open (CHAIN, ">$output_file_name.m");
	
	# make a summary
	my %start_iterator;
	my %count_iterator;
	my $vector_position = 1;
	
	foreach(@signature_labels) {
		# remove the trailing ST
		$_ =~ s|\..*$||;
		
		# mb_zernike(FourierTransform((im)) [1-89]
		if (exists $start_iterator{$_}) {
			$count_iterator{$_} = $count_iterator{$_} + 1;
		} else {
			$start_iterator{$_} = $vector_position;
			$count_iterator{$_} = 1;
		}
		
		$vector_position++;
	}
	
	# make @signature_labels unique
    my %saw;
    @signature_labels = grep(!$saw{$_}++, @signature_labels);
    
	foreach (@signature_labels) {
		print CHAIN "% [".$start_iterator{$_}."-".($start_iterator{$_}+$count_iterator{$_}-1)."]   $_\n";
	}
	
	print CHAIN "\nfunction [signature_vector] = $output_file_name (im); \n";
	for (my $vec_count=0; $vec_count < scalar(@signature_labels); $vec_count++) {
		my $cmd = "vec_$vec_count = concat_outputs (".$signature_labels[$vec_count].")";
		
		# stick in typecaster modules as needed
		if ($cmd =~ s/\(FourierTransform/\(FrequencySpace2Pixels\(FourierTransform/) {
			$cmd = $cmd.")";
		}
		if ($cmd =~ s/\(WaveletSignatures/\(WaveletSelector\(WaveletSignatures/) {
			$cmd = $cmd.")";
		}
		print CHAIN $cmd.";\n" ;
	}
	
	print CHAIN "\nsignature_vector = [";
	for (my $vec_count=0; $vec_count < scalar(@signature_labels); $vec_count++) {
		print CHAIN "vec_$vec_count ";
	}
	print CHAIN "];\n";
	
	#write out typecaster modules;
	print CHAIN <<TYPECASTERS;
%
% MATLAB implementation of required typecaster modules
%
function pix = FrequencySpace2Pixels(fs)
pix = fs(:,:,1);
 
function wav_result = WaveletSelector(wav1, wav2)
wav_result = wav1;
TYPECASTERS

	# write out concatination function;
	print CHAIN <<CONCAT_UTILITY;
 
%
% helper function combines outputs from multiple outputs
%
function concat = concat_outputs (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)

if (nargin > 8)
    error('concat_outputs only supports up to 8 arguments');
end
 
if (nargin == 1)
    concat = [straighten(arg1)];
elseif (nargin == 2)
    concat = [straighten(arg1) straighten(arg2)];
elseif (nargin == 3)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3)];
elseif (nargin == 4)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4)];
elseif (nargin == 5)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5)];
elseif (nargin == 6)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6)];
elseif (nargin == 7)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7)];
elseif (nargin == 8)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8)];
elseif (nargin == 9)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9];
elseif (nargin == 10)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10)];
elseif (nargin == 11)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11)];
elseif (nargin == 12)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12)];
elseif (nargin == 13)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13)];
elseif (nargin == 14)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13) straighten(arg14)];
elseif (nargin == 15)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13) straighten(arg14) straighten(arg15)];
elseif (nargin == 16)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13) straighten(arg14) straighten(arg15) straighten(arg16)]; 
end
concat = double(concat);

%
% some vectors are row-oriented others are column-oriented. This fixes them all to be column oriented
%
function out = straighten (in)
[rows, columns] = size(in);
if (rows < columns)
 	out = in;
else
	out = in';
end

CONCAT_UTILITY

	close(CHAIN);
}

sub stitch_chain {
	my ($self,$commands) = @_;
	my ($xml_src, $outdir, $compression, $chain_name );
	
	GetOptions(
		'x=s' => \$xml_src, 
		'o=s' => \$outdir, 
		'a=s' => \$chain_name, 
		'compress' => \$compression 
	);
	$compression = ( $compression ? 7 : 0 );
	die "one or more options not specified"
		unless $xml_src and $outdir and $chain_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	my $manager = OME::Tasks::ChainManager->new($session);

	# find modules that produce signatures
	# simple implementation of leaf nodes for now
	logdbg "debug", "Finding Signature Modules in chain $chain_name";
	my $chain;
	$chain = $factory->loadObject( "OME::AnalysisChain", $chain_name )
		if( $chain_name =~ m/^\d+$/ );
	unless ($chain) {
		my @chains = $factory->findObjects( "OME::AnalysisChain", name => $chain_name );
		die @chains." chains found with that name ($chain_name). Expected exactly 1."
			unless( scalar( @chains ) eq 1 );
		$chain = $chains[ 0 ];
	}
	
	my @signature_nodes = $manager->findLeaves( $chain );
	@signature_nodes = sort {$a->module->name cmp $b->module->name} @signature_nodes;
	
	logdbg "debug", "Found chain nodes. Format of output is 'module_name(node_id)'\n\t".
		join( ', ', map( $_->module->name."(".$_->id.")", @signature_nodes ) );
	
	# compute FI names that are going to be used in the signature stitcher
	my @signature_nodes_FI_names;
	
	my @root_nodes = @{$manager->getRootNodes( $chain )};
	my $root_node = $root_nodes[0];
	foreach my $sig_node (@signature_nodes) {
		# create a FI Name based on the Path of Modules.
		my @node_path = $manager->findPath($root_node, $sig_node);
		my $FI_name = "im";
		
		foreach (@node_path) {
			# ignore modules based on their categories
			next unless (defined $_->module->category); # ignore no category modules
			my $cat_path = OME::Tasks::ModuleTasks::returnPathToLeafCategory ($_->module->category);
			next if ($cat_path =~ m/.*Slicers.*/);  # ignore slicer modules 
			next if ($cat_path =~ m/.*Typecasts.*/); # ignore typecaster modules 

			if (defined $_->module->location) {
				$FI_name = $_->module->location."($FI_name)"
			} else {
				$FI_name = $_->module->name."($FI_name)"
			}
		}
		push @signature_nodes_FI_names, $FI_name;
	}
	
	# make sure that $signature_nodes are all unique strings. If there are multiple
	# exact same strings, we shall enumerate them.
	my %unique_FI_names_count;
	my %unique_FI_names_ptr; # points to the first redundent string. This way we can retroactively add a _1 suffix

	for (my $i=0; $i < scalar @signature_nodes_FI_names; $i++) {
		my $FI_name = $signature_nodes_FI_names[$i];
		
		if (not exists $unique_FI_names_count{$FI_name}) {
			$unique_FI_names_count{$FI_name} = 1;
			$unique_FI_names_ptr{$FI_name} = $i;			
			next;
		}
		
		# retroactively add a _1 suffix to the first redundent string
		if ($unique_FI_names_count{$FI_name} == 1) {
#			print "was ".$signature_nodes_FI_names[$unique_FI_names_ptr{$FI_name}]."\n";
			$signature_nodes_FI_names[$unique_FI_names_ptr{$FI_name}] = 
				$signature_nodes_FI_names[$unique_FI_names_ptr{$FI_name}]."_1";
#			print "now ".$signature_nodes_FI_names[$unique_FI_names_ptr{$FI_name}]."\n";
		}
#		print "was ".$signature_nodes_FI_names[$i]."\n";
		$unique_FI_names_count{$FI_name} = $unique_FI_names_count{$FI_name} + 1;
		$signature_nodes_FI_names[$i] = 
				$signature_nodes_FI_names[$i]."_".$unique_FI_names_count{$FI_name};
#		print "now ".$signature_nodes_FI_names[$i]."\n";
	}

	##############
	# create signature module (xml)
	logdbg "debug", "Creating signature module";
	my $doc = XML::LibXML::Document->new();
	die "Cannot create XML document"
	  unless defined $doc;
	my $root = $doc->createElementNS($OME_NS,'OME');
	$root->setNamespace($XSI_NAMESPACE, 'xsi',0);
	$root->setAttributeNS($XSI_NAMESPACE,'schemaLocation',"$OME_NS $OME_NS");
	$doc->setDocumentElement($root);

	# Parse the STDs
	my $parser = XML::LibXML->new();
	my $STD_doc = $parser->parse_string( SIG_MODULE_STDS );
	$root->appendChild( $STD_doc->documentElement() );
	
	# add the module library
	my $module_library = $doc->createElementNS($AML_NS,'AnalysisModuleLibrary');
	$root->appendChild( $module_library );
	
	# Make the module
	my $module = $doc->createElement('AnalysisModule');
	$module->setAttribute( 'ModuleType', "OME::Analysis::Modules::Classification::SignatureStitcher");
	$module->setAttribute( 'Category', "Classifier");
	my $new_LSID = $self->get_next_LSID( $xml_src );
	$module->setAttribute( 'ID', $new_LSID );
	$new_LSID =~ m/urn:lsid:openmicroscopy.org:Module:(\d+)/;
	my $module_name = "Signature Stitcher ($1)";
	$module->setAttribute( 'ModuleName', $module_name );
	$module->setAttribute( 'ProgramID', "" );
	$module_library->appendChild( $module );
		
	# Make the description
	my $module_description = $doc->createElement('Description');
	$module_description->appendChild( XML::LibXML::Text->new( <<ENDDESCRIPTION ) );
Combines outputs from "signature modules" into a single vector that
describes the image. This stitching is very handy for classifiers.
ENDDESCRIPTION
	$module->appendChild( $module_description );
	
	# Declaration
	my $declaration = $doc->createElement('Declaration');
	$module->appendChild( $declaration );
	
	# Inputs
	my  @signature_nodes_FI_names_copy = @signature_nodes_FI_names;
	foreach my $sig_node ( @signature_nodes ) {
		my $FI_name = shift @signature_nodes_FI_names_copy;
		
		foreach my $output ( $sig_node->module->outputs ) {
			my $ST_name = $output->semantic_type->name;
			my $formal_input = $doc->createElement( 'FormalInput');
			$formal_input->setAttribute( 'Name', $FI_name.".".$ST_name);
			$formal_input->setAttribute( 'SemanticTypeName', $ST_name );
			$formal_input->setAttribute( 'Count', '?' );
			$declaration->appendChild( $formal_input );
		}
	}
	
	# Outputs
	my $formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'SignatureVector' );
	$formal_output->setAttribute( 'SemanticTypeName', 'SignatureVectorEntry' );
	$formal_output->setAttribute( 'Count', '+' );
	$declaration->appendChild( $formal_output );
	$formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'VectorLegend' );
	$formal_output->setAttribute( 'SemanticTypeName', 'SignatureVectorLegend' );
	$formal_output->setAttribute( 'Count', '+' );
	$declaration->appendChild( $formal_output );
	
	# save to disk
	my $file_name = $module_name;
	$file_name =~ s/ //g;
	$file_name = $outdir. '/' . $file_name . ".ome";
	$doc->toFile( $file_name, 2 );
	logdbg "debug", "Saved signature module to $file_name";
	
	# import module
	logdbg "debug", "Importing module $module_name into DB";
	OME::Tasks::ImageTasks::importFiles (undef, [ $file_name ] );
	my $stitcher_module = $factory->findObject( "OME::Module", name => $module_name )
		or die "Could not load Signature Stitcher module named '$module_name'";
	
	# create new chain that includes signature module (db)
	logdbg "debug", "Creating new chain that includes the stitcher";
	my ($new_chain, $node_mapping) = $manager->cloneChain( $chain, undef, 'gimme node mapping!' );
	$new_chain->name( "Autogenerated Signature chain ".$new_chain->id );
	$new_chain->storeObject();
	my $stitcher_node  = $factory->newObject( 'OME::AnalysisChain::Node', {
		module         => $stitcher_module,
		analysis_chain => $new_chain
	} );
	
	# make links
	foreach my $sig_node (@signature_nodes) {
		my $FI_name = shift (@signature_nodes_FI_names);
		foreach my $output ($sig_node->module->outputs) {
			my $ST_name = $output->semantic_type->name;
			
			my $formal_input;
			$formal_input = $factory->findObject( "OME::Module::FormalInput",
				module => $stitcher_module,
				name   => $FI_name.".".$ST_name
			) or die "Couldn't load input $FI_name::$ST_name for module $module_name";
			
			# use node_mapping to link the new node with the old
			my $from_node = $node_mapping->{$sig_node->id };
			
			my $data = {
				to_node     => $stitcher_node,
				to_input    => $formal_input,
				from_node   => $from_node,
				from_output => $output,
				analysis_chain => $new_chain
			};
			$factory->newObject( "OME::AnalysisChain::Link", $data )
				or die "Couldn't make link from ".
					$from_node->module->name.".". $output->mae." to ".
					$stitcher_node->name.".".$formal_input;
		}
	}
	$session->commitTransaction();
	
	
	# save new chain to disk
	my $chain_file = $new_chain->name().'.'.$new_chain->id.'.ome';
	$chain_file =~ s/ //g;
	$chain_file = $outdir. '/' . $chain_file;
	logdbg "debug", "Saving new chain to $chain_file";
	my $chainExport = OME::ImportExport::ChainExport->new();
	$chainExport->buildDOM ([$new_chain]);
	$chainExport->exportFile ($chain_file, compression => 0 );
	
}

# I'm putting this in a separate function because the implementation
# will probably change.
sub get_classifications_and_category_numbers {
	my ($proto, $images, $classification_mex) = @_;
	logdbg "debug", "collecting image classifications.";
	my $factory = OME::Session->instance()->Factory();
	my %classifications;
	my $category_group;
	foreach my $image ( @$images ) {
		# If we were given a mex or list of mexes, then use it to find classifications
		my @classification_list = ( $classification_mex ?
			@{ OME::Tasks::ModuleExecutionManager->
				getAttributesForMEX( $classification_mex, "Classification",
					{image => $image } 
				) } :
			$factory->findAttributes( 'Classification', image => $image )
		);
		if( scalar( @classification_list ) == 0 ) {
			print STDERR "Could not find a classification for image ".$image->name()." (".$image->id.")\n";
			$classifications{ $image->id } = undef;
			next;
		}
		die "More than one classification found for image id=".$image->id
			unless scalar( @classification_list ) eq 1;
		$category_group = $classification_list[0]->Category->CategoryGroup
			unless $category_group;
		die "Classification for image id=".$image->id." does not belong to the same category group as other images in this dataset."
			unless $category_group->id eq $classification_list[0]->Category->CategoryGroup->id;
		$classifications{ $image->id } = $classification_list[0];
	}
	# map categories to category numbers
	my @categories = $factory->findAttributes( "Category", CategoryGroup => $category_group );
	my %category_numbers;
	my @category_names;
	my $cn = 0;
	foreach( sort { $a->Name cmp $b->Name } @categories ) { 
		$cn++;
		$category_numbers{ $_->id } = $cn;
		push(@category_names, $_->Name);
	}
	return (\%classifications, \%category_numbers, \@category_names);
}

# returns the matlab signature array
sub compile_signature_matrix {
	my ($proto, $stitcher_mex, $images, $number_of_image_features, $classification_mex) = @_;
	my $factory = OME::Session->instance()->Factory();
	my ( $classifications, $category_numbers, $category_names) = 
		$proto->get_classifications_and_category_numbers( $images, $classification_mex );

	# get category_names
	my $category_names_array = OME::Matlab::Array->newStringArray($category_names);
	
	# get vector_legends.
	my $vector_legends_ptr = OME::Tasks::ModuleExecutionManager->
		getAttributesForMEX( $stitcher_mex, "SignatureVectorLegend" )
		or die "Could not load signature vector legend for mex (id=".$stitcher_mex->id.")";
	my @vector_legends = sort {$a->VectorPosition <=> $b->VectorPosition} @$vector_legends_ptr;
	
	# populate the signature matrix's labels
	my @signature_labels =  map( $_->FormalInput().".".$_->SemanticElement(), @vector_legends);
	my $signature_labels_array = OME::Matlab::Array->newStringArray(\@signature_labels);
	$signature_labels_array->makePersistent();

	# instantiate the matlab signature array. 
	#	number of rows is the size of the signature vector plus one for the image classification.
	#	number of columns is the number of image ROIs
	my $signature_array = OME::Matlab::Array->newDoubleMatrix(scalar( @vector_legends ) + 1, $number_of_image_features);
	$signature_array->makePersistent();
	
	# populate the signature matrix proper
	my $image_feature_number = 0;
	my $category_row_index = scalar( @vector_legends );
	foreach my $image ( @$images ) {
		my @features = $image->all_features();
		@features = sort {$a->id <=> $b->id} @features;

		foreach my $feature (@features) {
			my $signature_entry_list = OME::Tasks::ModuleExecutionManager->
				getAttributesForMEX( $stitcher_mex, "SignatureVectorEntry",
					{ feature => $feature }
				)
				or die "Could not load image signature vector for feature (id=".$feature->id."), mex (id=".( ref( $stitcher_mex ) ne 'ARRAY' ? $stitcher_mex->id : join( ', ', map( $_->id, @$stitcher_mex ) ) ).")";
			print "Compiling Sigs for Image ROI ".($image_feature_number+1)." of ".$number_of_image_features. "(Image Name: ".$image->name.")\n"; 
			# set the image category
			my $category_num = ( defined $classifications->{ $image->id } ? 
				$category_numbers->{ $classifications->{ $image->id }->Category->id } :
				0
			);
			$signature_array->set( $category_row_index, $image_feature_number, $category_num );
			# set the image's signature vector
			foreach my $sig_entry ( @$signature_entry_list ) {
				# VectorPosition is numbered 1 to n. Array positions should be 0 to (n-1).
				my $row_index = $sig_entry->Legend->VectorPosition() - 1;
				$signature_array->set( $row_index, $image_feature_number, $sig_entry->Value() );
			}
			$image_feature_number += 1;
		}
	}

	return $category_names_array, $signature_labels_array, $signature_array, 
}

sub get_next_LSID {
	my ($self, $xml_src ) = @_;
	my $session = $self->getSession();
	my $factory = $session->Factory();
	my $high_id=7200;

	# check module LSIDs in the xml directory.
	if( $xml_src ) {
		# FIXME: use something besides backticks to get the next LSID from the xml source files.
		my @grep_results = `grep -r 'urn:lsid:openmicroscopy.org:Module:72' $xml_src/*`;
		foreach( @grep_results ) {
			if( m/urn:lsid:openmicroscopy.org:Module:(72\d\d)/ ) {
				$high_id = $1 if $1 gt $high_id;
			}
		}
	}
	
	# just for yucks, check against LSIDs from the DB
	my @LSIDs = $factory->findObjects( "OME::LSID",
		lsid => [ 'like', 'urn:lsid:openmicroscopy.org:Module:72%' ]
	);
	foreach( map( $_->lsid, @LSIDs) ) {
		if( m/urn:lsid:openmicroscopy.org:Module:(72\d\d)/ ) {
			$high_id = $1 if $1 gt $high_id;
		}		
	}

	return 'urn:lsid:openmicroscopy.org:Module:'.($high_id + 1);
}

1;
