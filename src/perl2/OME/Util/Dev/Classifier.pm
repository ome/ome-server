# OME/Util/Dev/Classifier.pm

#-------------------------------------------------------------------------------
#
# Copyright (C) 2003 Open Microscopy Environment
#       Massachusetts Institute of Technology,
#       National Institutes of Health,
#       University of Dundee
#
#
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#
# Written by:   Tomasz Macura <tmacura@nih.gov>
#				Josiah Johnston <siah@nih.gov>
#
#-------------------------------------------------------------------------------

package OME::Util::Dev::Classifier;

use strict;
use OME;
our $VERSION = $OME::VERSION;

use base qw(OME::Util::Commands);

use Carp;
use Getopt::Long;
use File::Glob ':glob';

use Log::Agent;
use XML::LibXML;
use XML::LibXSLT;
use OME::SessionManager;
use OME::Session;
use OME::Tasks::ImageManager;
use OME::Tasks::ImageTasks;
use OME::Tasks::ChainManager;
use OME::Tasks::OMEImport;
use OME::Tasks::ModuleTasks;
use OME::Tasks::ModuleExecutionManager;
use OME::ImportExport::ChainExport;
use OME::Matlab;
use OME::Session;

use OME::Install::Util; # for euid()+uid()
use OME::Install::Environment;

use Getopt::Long;
Getopt::Long::Configure("bundling");



sub getCommands {
    return
      {
       'stitch_training_chain' => 'stitch_training_chain',
       'stitch_prediction_chain' => 'stitch_prediction_chain',
       'compile_sigs' => 'compile_sigs',
       'compile_chain' => 'compile_chain',
       'make_predictions' => 'make_predictions',
       'import_test_train_dataset' => 'import_test_train_dataset',
      };
}

sub compile_sigs_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

This will compile a signature matrix for a matlab Trainer. It needs a
complete signature chain (e.g. a chain generated by 'stitch_chain'), and
a dataset that has exactly one classification per image. It will execute
the signature chain if necessary. There will be one row per image in the
matrix. Each column represents another image. Each row represents one
signature, and the last row is the image class. If the image has no
classification, the class will be 0.

	        Img 1  Img 2  ...
	Sig 1 [     x,     x, ... ]
	Sig 2 [     x,     x, ... ]
	...   [   ...,   ..., ... ]
	Sig n [     x,     x, ... ]
	Class [     x,     x, ... ]

The original signature chain must already be imported into the database. 

Options:
  -a  Signature analysis chain name or ID.

  -d  Dataset name or ID.

  -e  Analysis Chain Execution ID. This Optional parameter takes precedence over
      the -a and -d flags. If you specify this then you don't need to specify
      -a and -d. This is especially useful if the analysis chain was executed
      multiple times against the dataset.
  
  -o  Output filename.
  
  -f, --force
    Force re-execution of chain (i.e. do not reuse previous module execution 
    results).
    
USAGE
}


sub stitch_training_chain_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

This will create a custom Signature Stitcher module for a signature
chain. Additionally, it will copy the chain and attach the stitcher
module to the copy. The newly created module and chain will be imported
to the database and saved to disk.

The original signature chain must already be imported into the database. 

Options:
  -a  the id or name of the signature chain to stitch

  -x  path of xml source directory
  
  -o  output directory
        
  -compress  Compress the output file. 
  
USAGE
}

sub stitch_prediction_chain_help {
	my ($self, $stuff) = @_;
	return stitch_training_chain_help($stuff);
}

# constants
our $OME_NS = 'http://www.openmicroscopy.org/XMLschemas/CA/RC1/CA.xsd';
our $AML_NS = 'http://www.openmicroscopy.org/XMLschemas/AnalysisModule/RC1/AnalysisModule.xsd';
our $XSI_NAMESPACE = 'http://www.w3.org/2001/XMLSchema-instance';

sub make_predictions_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

  -x Classifier Training Chain Execution ID
  
  -a ID/name of the Image Prediction Chain corresponding to the Classifier
  	 Training Chain with CHEX -x
 
  -d ID/name of Dataset containing images that are going to be classified

USAGE
}

sub make_predictions {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);

	my $session = $self->getSession();
	my $factory = $session->Factory();

	# parse input parameters
	my ($training_chexStr, $prediction_chainStr, $datasetStr);
	GetOptions ('x=s' => \$training_chexStr,
	            'a=s' => \$prediction_chainStr,
	            'd=s' => \$datasetStr);

	die "-x (training CHEX), -a (prediction chain), -d (dataset)"
		unless ($training_chexStr and $prediction_chainStr and $datasetStr);

	# get training_chex
	my $training_chex = $factory->findObject("OME::AnalysisChainExecution", id => $training_chexStr);
	die "Could not find chain execution with (id=".$training_chexStr.")"
			unless ($training_chex);
	
	# get the WND-TRAINER MEX
	my $trainer_node = $factory->findObject ("OME::AnalysisChain::Node",
											analysis_chain => $training_chex->analysis_chain(),
											'module.name' => ['like', 'WND-CHARM-Trainer%'])
	or die "Couldn't find WND-Trainer Node specified in chain";
	
	my $trainer_nex = $factory->findObject ("OME::AnalysisChainExecution::NodeExecution",
											analysis_chain_execution => $training_chex,
											analysis_chain_node => $trainer_node);
											
	# get prediction chain
	my $prediction_chain;
	if ($prediction_chainStr =~ /^([0-9]+)$/) {
		$prediction_chain = $factory->loadObject( "OME::AnalysisChain", $prediction_chainStr )
			or die "Cannot find an analysis chain with id = $prediction_chainStr";
	} else {
		my $chainData = {name => $prediction_chainStr};
		$prediction_chain = $factory->findObject( "OME::AnalysisChain", $chainData)
			or die "Cannot find an analysis chain with name = $prediction_chainStr";
	}
	
	# get prediction module	
	my $prediction_node = $factory->findObject ("OME::AnalysisChain::Node",
											analysis_chain => $prediction_chain,
											'module.name' => ['like', 'WND-CHARM-Prediction%']);
	
	
	# get dataset to run predictions on
	my $dataset;
	if ($datasetStr =~ /^([0-9]+)$/) {
		my $datasetID = $1;
		$dataset = $factory->loadObject ("OME::Dataset", $datasetID);
		die "Dataset with ID $datasetStr doesn't exist!" unless $dataset;
	} else {
		my $datasetData = {
							name   => $datasetStr,
							owner  => $session->User(),
						  };
		$dataset = $factory->findObject( "OME::Dataset", $datasetData);
		die "Dataset with name $datasetStr doesn't exist!" unless $dataset;
	}
	
	# connect the trainer and categories_used outputted by the trainer chain
	# as inputs to the prediction chain
	
	my $trained_classifier_input = $factory->findObject( 'OME::Module::FormalInput',
		'module' 	=> $prediction_node->module(),
		'name'      => 'Trained Classifier') or die "couldn't load Trained Classifier FI";
	
	my $categories_used_input = $factory->findObject( 'OME::Module::FormalInput',
		'module'	=> $prediction_node->module(),
		'name'      => 'Categories Used by Trained Classifier') or die "couldn't load Categories Used FI";

	my %user_inputs;
	my $mex = $trainer_nex->module_execution();

	print "Connecting TrainedClassifier FI: ". $trained_classifier_input->id().
		" to MEX: ".$mex->id()."\n";
	$user_inputs{$trained_classifier_input->id()} = [$mex];
	print "Connecting CategoriesUsed FI: ". $categories_used_input->id().
		" to MEX: ".$mex->id()."\n";
	$user_inputs{$categories_used_input->id()} = [$mex];

	my %flags;
	$flags{ReuseResults} = 1;
	my $task = undef;
	my $chain_execution = OME::Analysis::Engine->
		executeChain($prediction_chain,$dataset,\%user_inputs,$task,%flags)
		or die "Got no chex.";
	print "Chex ID is ".$chain_execution->id."\n";
}

sub import_test_train_dataset_help {
    my ($self,$commands) = @_;
    my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
    
    $self->printHeader();
    print <<"USAGE";
Usage:
    $script $command_name [<options>]

	Given a set of images, this function randomly chooses to import half of
	the images into the specified datset.
	
  -d Name of Dateset to import images into
  
  --test or --train (one of these options need to be specified)

USAGE
}

sub import_test_train_dataset {
	my ($self,$commands) = @_;
	my ($datasetName, $train, $test);
	$train=0;
	$test=0;
	GetOptions ('dataset|d=s' => \$datasetName,
				'train!' => \$train,
				'test!' => \$test);
				
	# idiot traps
    die "You must specify either --test or --train, but not both!\n"
    	if ( (not $train and not $test) or ($train and $test));

	# create a whole list of filenames
	my @file_names;
    foreach my $filename (@ARGV) {
    	$filename = Cwd::realpath($filename); # if you use absolute filenames here, OriginalFiles.Path
										 # stores absolute filenames. if you use relative paths,
										 # OriginalFiles.Path stores relative filenames
    	push (@file_names,$filename)
    		if $filename and -f $filename and -r $filename and -s $filename;
    	push (@file_names,bsd_glob("$filename/*")) if $filename and -d $filename and -r $filename;
    }
	die "No valid files or directories specified for import.\n" unless scalar @file_names;
	
	# create the random half of the filenames
	srand(42); # the seed is purposely set to make rand reproducible.

	my @random_half_file_names;
	foreach my $filename (@file_names) {
		if (rand() >= 0.25) { # 1/4 of the images are for testing and 1/4 are for training
			push @random_half_file_names, $filename
				if ($train);
		} else {
			push @random_half_file_names, $filename
				if ($test);
		}
	}
	
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	
	# make the specified dataset 
	my $datasetDescription = "These images were imported using the OME dev command-line tool: ome dev classifier import_test_train_dataset";
	my $dataset_data = {
						name        => $datasetName,
						owner       => $session->User(),
						group       => $session->User()->Group()->id(),
						locked      => 'false'
					   };

	my $dataset = $factory->findObject( "OME::Dataset", $dataset_data);
	if (not defined $dataset) {
		$dataset_data -> {'description'} = $datasetDescription;
		$dataset = $factory->newObject( "OME::Dataset", $dataset_data );
	
		# If there is a project in this session, then associate this new dataset with it
		my $project = $session->project();
		if (defined $project) {
			
			# Assign the dataset to the project
			print '- Adding Dataset "',$dataset->name(),'" to Project "',$project->name(),'"...',"\n";
			my $projectManager = new OME::Tasks::ProjectManager;
			$projectManager->addDatasets([ $dataset->id() ], $project->id());
		}
	}
	
	# do the import!
	my %opts;
	$opts{AllowDuplicates} = 1;
	
	my $task = OME::Tasks::NotificationManager->
        new('Importing images',3+scalar(@random_half_file_names));
	$task->setPID($$);
	$task->step();
	$task->setMessage('Starting import');
	
	my $images = OME::Tasks::ImageTasks::importFiles ($dataset, \@random_half_file_names, \%opts, $task);
}
sub compile_sigs {
	my ($self,$commands) = @_;
	my $script = $self->scriptName();
    my $command_name = $self->commandName($commands);
	my $environment = OME::Install::Environment->initialize();

	my ($datasetStr, $chainStr, $output_file_name, $chex_id );
	
	GetOptions ('d=s' => \$datasetStr,
	            'a=s' => \$chainStr,
	            'o=s' => \$output_file_name,
	            'e=i' => \$chex_id);
	            
	die "one or more options not specified"
		unless (($datasetStr and $chainStr) or $chex_id) and $output_file_name;
	$output_file_name .= '.mat' unless $output_file_name =~ m/\.mat$/;
	
	# open MATLAB connection
	my $engine = OME::Matlab::Engine->openEngine()
		or die "Cannot open a connection to Matlab! as user ".$environment->matlab_conf()->{USER};
	
	# check if the matlab user has write permissions in this directory 
	die "The ome matlab user `".$environment->matlab_conf()->{USER}."` lacks permissions to write $output_file_name" unless
		open (CHECK, ">$output_file_name");
		
	my $session = $self->getSession();
	my $factory = $session->Factory();
	
	# sanity check
	logdbg "debug", "loading chain and dataset";
	
	# get chex if appropriate
	my $chex;
	my $chain;
	my $dataset;
	
	if ($chex_id) {
		$chex = $factory->findObject( "OME::AnalysisChainExecution",
			id => $chex_id,
		);
		die "Could not find chain execution with (id=".$chex_id.")"
			unless ($chex);
		$chain   = $chex->analysis_chain();
		$dataset = $chex->dataset();
		print $chain->name()."  ".$dataset->name()."\n";
	}

	# get chain	if neccessary
	if (not defined $chain) {
		if ($chainStr =~ /^([0-9]+)$/) {
			$chain= $factory->loadObject( "OME::AnalysisChain", $chainStr )
				or die "Cannot find an analysis chain with id = $chainStr";
		} else {
			my $chainData = {name => $chainStr};
			$chain = $factory->findObject( "OME::AnalysisChain", $chainData)
				or die "Cannot find an analysis chain with name = $chainStr";
		}
	}
	
	# get dataset if neccesary
	if (not defined $dataset) {
		if ($datasetStr =~ /^([0-9]+)$/) {
			my $datasetID = $1;
			$dataset = $factory->loadObject ("OME::Dataset", $datasetID);
			die "Dataset with ID $datasetStr doesn't exist!" unless $dataset;
		} else {
			my $datasetData = {
								name   => $datasetStr,
								owner  => $session->User(),
							  };
			$dataset = $factory->findObject( "OME::Dataset", $datasetData);
			die "Dataset with name $datasetStr doesn't exist!" unless $dataset;
		}
	}
	
	# get chex if neccesary,
	# it might already be loaded if chex_id was specified as program parameter
	$chex = $factory->findObject( "OME::AnalysisChainExecution",
		analysis_chain => $chain,
		dataset        => $dataset
	) unless ($chex);
	
	die "debug", "Could not find execution of chain (id=".$chain->id unless $chex;
	
	############################################################################
	# Figure out the leaf nodes and from them, the signature labels
	############################################################################
	my $manager = OME::Tasks::ChainManager->new($session);

	logdbg "debug", "Computing labels for leaf-node names";
	my @signature_nodes = $manager->findLeaves( $chain );
	@signature_nodes = sort {$a->module->name cmp $b->module->name} @signature_nodes;
	my @signature_node_names = $manager->createNodeTags(@signature_nodes);
	
	# now that we have the signature_node_names, run through the signature_nodes again,
	# this time adding FO ST and SE
	logdbg "debug", "Computing labels for individual signatures";
	my @signature_labels;
	foreach my $sig_node (@signature_nodes) {
		my $signature_node_name = shift(@signature_node_names);
		
		my @formal_outputs = $factory->findObjects('OME::Module::FormalOutput', { module => $sig_node->module() });
		@formal_outputs = sort { $a->name cmp $b->name } @formal_outputs;

		foreach my $fo (@formal_outputs) {	
			my @SEs = $fo->semantic_type->semantic_elements();
			@SEs = sort { $a->name cmp $b->name } @SEs;
			
			foreach my $se ( @SEs ) {
			
				# is SE of an appropriate type i.e a double
				next if $se->data_column()->sql_type() eq 'string';
				next if $se->data_column()->sql_type() eq 'reference';
			
				push (@signature_labels, $signature_node_name.".".$fo->name().".".$se->name());
			}
		}
	}

	my $signature_labels_array = OME::Matlab::Array->newStringArray(\@signature_labels);
	$signature_labels_array->makePersistent();

	############################################################################
	# Make an array of image_paths/feature names
	############################################################################
	
	# make an array of image_paths/feature names
	# img_path [feature name]
	# img_path [feature name]
	# ...
	logdbg "debug", "Making an array of image_paths/feature names";

	my @images = $dataset->images( __order => ['name', 'id'] );
	my @features = ();
	my @image_feature_paths; # this is a 'path' to the image feature

	# find the NODE that produces ROIs
	my $ROI_node = $factory->findObject ("OME::AnalysisChain::Node",
										analysis_chain => $chain,
										'module.name' => 'Image 2D Tiled ROIs')
	or die "Couldn't find ROI producing node in chain";
	
	my $ROI_FO = $factory->findObject ("OME::Module::FormalOutput",
										module => $ROI_node->module(),
										name => "Image ROIs")
	or die "Couldn't find ROI Formal Output";
	
	foreach my $img (@images) {
		my $originalFile = OME::Tasks::ImageManager->getImageOriginalFiles($img);
		die "Image ".$_->name." doesn't have exactly one Original File"
			if( ref( $originalFile ) eq 'ARRAY' );
		
		# get ROI Node execution
		my $ROI_nex = $factory->findObject ("OME::AnalysisChainExecution::NodeExecution",
											analysis_chain_execution => $chex,
											analysis_chain_node => $ROI_node,
											'module_execution.image' => $img,
										   ) or die "couldn't load ROI NEX";

		my @img_features = $img->all_features();
		@img_features = sort {$a->id <=> $b->id} @img_features;
		foreach my $feature (@img_features) {
			# selecte the features made by this CHEX
			my @attributes = @{OME::Tasks::ModuleExecutionManager->getAttributesForMEX($ROI_nex->module_execution(),
																					   $ROI_FO->semantic_type(),
																					   {feature =>$feature})};
			my $attribute = $attributes[0];
			next unless (defined $attribute); # i.e. this ROI wasn't made by this signature chain
			
			push @features, $feature;
			push @image_feature_paths, $originalFile->Path()." [".$feature->name()."]";
		}
	}
	# sort images by image_path not image name to match MATLAB sort order
	# so /CHO/tumor.tiff will be before /Pollen/obj_198_1.tiff
	my @image_feature_path_indices = sort{$image_feature_paths[$a] cmp $image_feature_paths[$b]}0..$#image_feature_paths;
	@image_feature_paths = @image_feature_paths[@image_feature_path_indices];
	@features = @features[@image_feature_path_indices];
	
	my $image_paths_array = OME::Matlab::Array->newStringArray(\@image_feature_paths);
	$image_paths_array->makePersistent();
	
	############################################################################
	# Figure out image classifications
	############################################################################
	my ($classifications, $category_numbers, $category_names) = 
		get_classifications_and_category_numbers(\@features);
		
	my $category_names_array = OME::Matlab::Array->newStringArray($category_names);
	$category_names_array->makePersistent();
	
	############################################################################
	# Compile the signature matrix
	############################################################################

	# analyzing chain structure.
	# pre computing LUTs speeds up writing out signatures
	logdbg "debug", "analyzing chain structure";
	
	my %sig_node_id_to_FOs;
	my %FO_id_to_se_names;
	
	foreach my $sig_node (@signature_nodes) {
		my @formal_outputs = $factory->findObjects('OME::Module::FormalOutput', { module => $sig_node->module() });
		@formal_outputs = sort { $a->name cmp $b->name } @formal_outputs;
		$sig_node_id_to_FOs{$sig_node->id} = \@formal_outputs;
		
		foreach my $fo (@formal_outputs) {
			my @SEs = $fo->semantic_type->semantic_elements();
			@SEs = sort { $a->name cmp $b->name } @SEs;
	
			my @se_names;
			foreach my $se ( @SEs ) {
				# is SE of an appropriate type i.e a double
				next if $se->data_column()->sql_type() eq 'string';
				next if $se->data_column()->sql_type() eq 'reference';
				push (@se_names, $se->name());
			}

			$FO_id_to_se_names{$fo->id} = \@se_names;
		}
	}
			
	# instantiate the matlab signature array. 
	#	number of rows is the size of the signature vector plus one for the image classification.
	#	number of columns is the number of image ROIs
	my $signature_array = OME::Matlab::Array->newDoubleMatrix(scalar(@signature_labels) + 1, scalar(@image_feature_paths));
	$signature_array->makePersistent();
	
	my $image_feature_number = 0;
	my $category_row_index = scalar(@signature_labels); # what row in the signature matrix are classifications

														# written to
	foreach my $feature ( @features ) {
		print "Compiling Sigs for Image ROI ".($image_feature_number+1)." of ".scalar(@image_feature_paths)." (Image Name: ".$feature->image->name.")\n"; 

		my $sig_row = 0;
		foreach my $sig_node (@signature_nodes) {
			my $nex = $factory->findObject ("OME::AnalysisChainExecution::NodeExecution",
												analysis_chain_execution => $chex,
												analysis_chain_node => $sig_node,
												'module_execution.image' => $feature->image,
												) or die "couldn't load NEX";
			my $mex = $nex->module_execution();

			my @formal_outputs = @{$sig_node_id_to_FOs{$sig_node->id}};	
			foreach my $fo (@formal_outputs) {
				my @attributes = @{OME::Tasks::ModuleExecutionManager->getAttributesForMEX($mex, $fo->semantic_type, {feature =>$feature})};
				my $attribute = $attributes[0];
				die "wow batman no attributes" unless (defined $attribute);
				
				my @se_names = @{$FO_id_to_se_names{$fo->id}};
				foreach my $se_name ( @se_names ) {
					$signature_array->set($sig_row++, $image_feature_number, $attribute->$se_name);
				}
			}
		}
		$image_feature_number++;
	}

	############################################################################
	# Writing the MATLAB file
	############################################################################
	logdbg "debug", "Saving the array to disk.";
	
	$engine->eval("global category_names_char_array");
	$engine->putVariable('category_names_char_array',$category_names_array);
	# Convert the rectangualar string array that has null terminated strings into a cell array.
	# Cell arrays are easier to deal with for strings.
	$engine->eval( "category_names=''; ".
				   "for i=1:size( category_names_char_array, 1 ),".
	               "category_names{i} = sprintf( '%s', category_names_char_array(i,:) ); ".
	               "end;" );
	               
	$engine->eval("global signature_labels_char_array");
	$engine->putVariable('signature_labels_char_array',$signature_labels_array);
	$engine->eval( "for i=1:size( signature_labels_char_array, 1 ),".
	               "signature_labels{i} = sprintf( '%s', signature_labels_char_array(i,:) ); ".
	               "end;" );

	$engine->eval("global image_paths_char_array");
	$engine->putVariable('image_paths_char_array',$image_paths_array);
	$engine->eval( "for i=1:size( image_paths_char_array, 1 ),".
	               "image_paths{i} = sprintf( '%s', image_paths_char_array(i,:) ); ".
	               "end;" );

	$engine->eval("global signature_matrix");
	$engine->putVariable('signature_matrix',$signature_array);

	$engine->eval( "dataset_name = '".$dataset->name()."';" );
	$engine->eval( "save $output_file_name dataset_name category_names signature_labels signature_matrix image_paths;" );
	print "Saved signature matrix to file $output_file_name.\n";
	$engine->close();
	$engine = undef;
}	

sub compile_chain {
	my ($self,$commands) = @_;
	my ($datasetStr, $chainStr, $output_file_name, $chex_id);
	
	GetOptions ('d=s' => \$datasetStr,
	            'a=s' => \$chainStr,
	            'o=s' => \$output_file_name,
	            'e=i' => \$chex_id);
	            
	die "one or more options not specified"
		unless (($datasetStr and $chainStr) or $chex_id) and $output_file_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	
	logdbg "debug", "loading chain, dataset, and signature stitcher chain node";
	
	# get chex if appropriate
	my $chex;
	my $chain;
	my $dataset;
	
	if ($chex_id) {
		$chex = $factory->findObject( "OME::AnalysisChainExecution",
			id => $chex_id,
		);
		die "Could not find chain execution with (id=".$chex_id.")"
			unless ($chex);
		$chain   = $chex->analysis_chain();
		$dataset = $chex->dataset();
		print $chain->name()."  ".$dataset->name()."\n";
	}

	# get chain	if neccessary
	if (not defined $chain) {
		if ($chainStr =~ /^([0-9]+)$/) {
			$chain= $factory->loadObject( "OME::AnalysisChain", $chainStr )
				or die "Cannot find an analysis chain with id = $chainStr";
		} else {
			my $chainData = {name => $chainStr};
			$chain = $factory->findObject( "OME::AnalysisChain", $chainData)
				or die "Cannot find an analysis chain with name = $chainStr";
		}
	}
	
	# get signature module
	my $sig_stitch_node = $factory->findObject( "OME::AnalysisChain::Node",
		analysis_chain  => $chain,
		'module.name'   => [ 'like', 'Signature Stitcher%' ]
	) or die "Could not find a signature stitcher module in chain (id = $chainStr, name = '".$chain->name."')";
	logdbg "debug", "found signature stitcher module (name=".$sig_stitch_node->module->name()."), node (id=".$sig_stitch_node->id.".";
	
	
	# get dataset if neccesary
	if (not defined $dataset) {
		if ($datasetStr =~ /^([0-9]+)$/) {
			my $datasetID = $1;
			$dataset = $factory->loadObject ("OME::Dataset", $datasetID);
			die "Dataset with ID $datasetStr doesn't exist!" unless $dataset;
		} else {
			my $datasetData = {
								name   => $datasetStr,
								owner  => $session->User(),
							  };
			$dataset = $factory->findObject( "OME::Dataset", $datasetData);
			die "Dataset with name $datasetStr doesn't exist!" unless $dataset;
		}
	}
	
	# Find the chain execution
	# chex might already be loaded if chex_id was specified as program parameter
	$chex = $factory->findObject( "OME::AnalysisChainExecution",
		analysis_chain => $chain,
		dataset        => $dataset
	) unless ($chex);
	
	if (not $chex) {
		logdbg "debug", "Could not find execution of chain (id=".$chain->id."). Executing chain";
		$chex = OME::Analysis::Engine->executeChain($chain,$dataset);
	}
	
	# collect sig stitcher module execution for this chain
	my $stitcher_nex = $factory->findObject( "OME::AnalysisChainExecution::NodeExecution",
		analysis_chain_execution => $chex,
		analysis_chain_node      => $sig_stitch_node
	) or die "Could not load a chain node execution for the signature stitcher node (id=".$sig_stitch_node->id."), chain execution (id=".$chex->id.").";
	my $stitcher_mex = $stitcher_nex->module_execution;
	die "signature stitcher (".$stitcher_mex->module->name.") module execution (id=".$stitcher_mex->id.") has 'ERROR' status!"
		if $stitcher_mex->status() eq 'ERROR';
	logdbg "debug", "found signature stitcher module execution (mex=".$stitcher_mex->id().").";
	
	# get vector_legends.
	my $vector_legends_ptr = OME::Tasks::ModuleExecutionManager->
		getAttributesForMEX( $stitcher_mex, "SignatureVectorLegend" )
		or die "Could not load signature vector legend for mex (id=".$stitcher_mex->id.")";
	my @vector_legends = sort {$a->VectorPosition <=> $b->VectorPosition} @$vector_legends_ptr;
	
	
	my @signature_labels =  map( $_->FormalInput(), @vector_legends);
	
	###
	### Open file for writing
	###
	open (CHAIN, ">$output_file_name.m");
	
	# make a summary
	my %start_iterator;
	my %count_iterator;
	my $vector_position = 1;
	
	foreach(@signature_labels) {
		# remove the trailing ST
		$_ =~ s|\..*$||;
		
		# mb_zernike(FourierTransform((im)) [1-89]
		if (exists $start_iterator{$_}) {
			$count_iterator{$_} = $count_iterator{$_} + 1;
		} else {
			$start_iterator{$_} = $vector_position;
			$count_iterator{$_} = 1;
		}
		
		$vector_position++;
	}
	
	# make @signature_labels unique
    my %saw;
    @signature_labels = grep(!$saw{$_}++, @signature_labels);
    
	foreach (@signature_labels) {
		print CHAIN "% [".$start_iterator{$_}."-".($start_iterator{$_}+$count_iterator{$_}-1)."]   $_\n";
	}
	
	print CHAIN "\nfunction [signature_vector] = $output_file_name (im); \n";
	for (my $vec_count=0; $vec_count < scalar(@signature_labels); $vec_count++) {
		my $cmd = "vec_$vec_count = concat_outputs (".$signature_labels[$vec_count].")";
		
		# stick in typecaster modules as needed
		if ($cmd =~ s/\(FourierTransform/\(FrequencySpace2Pixels\(FourierTransform/) {
			$cmd = $cmd.")";
		}
		if ($cmd =~ s/\(WaveletSignatures/\(WaveletSelector\(WaveletSignatures/) {
			$cmd = $cmd.")";
		}
		print CHAIN $cmd.";\n" ;
	}
	
	print CHAIN "\nsignature_vector = [";
	for (my $vec_count=0; $vec_count < scalar(@signature_labels); $vec_count++) {
		print CHAIN "vec_$vec_count ";
	}
	print CHAIN "];\n";
	
	#write out typecaster modules;
	print CHAIN <<TYPECASTERS;
%
% MATLAB implementation of required typecaster modules
%
function pix = FrequencySpace2Pixels(fs)
pix = fs(:,:,1);
 
function wav_result = WaveletSelector(wav1, wav2)
wav_result = wav1;
TYPECASTERS

	# write out concatination function;
	print CHAIN <<CONCAT_UTILITY;
 
%
% helper function combines outputs from multiple outputs
%
function concat = concat_outputs (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16)

if (nargin > 8)
    error('concat_outputs only supports up to 8 arguments');
end
 
if (nargin == 1)
    concat = [straighten(arg1)];
elseif (nargin == 2)
    concat = [straighten(arg1) straighten(arg2)];
elseif (nargin == 3)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3)];
elseif (nargin == 4)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4)];
elseif (nargin == 5)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5)];
elseif (nargin == 6)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6)];
elseif (nargin == 7)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7)];
elseif (nargin == 8)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8)];
elseif (nargin == 9)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9];
elseif (nargin == 10)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10)];
elseif (nargin == 11)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11)];
elseif (nargin == 12)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12)];
elseif (nargin == 13)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13)];
elseif (nargin == 14)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13) straighten(arg14)];
elseif (nargin == 15)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13) straighten(arg14) straighten(arg15)];
elseif (nargin == 16)
    concat = [straighten(arg1) straighten(arg2) straighten(arg3) straighten(arg4) straighten(arg5) straighten(arg6) straighten(arg7) straighten(arg8) arg9 straighten(arg10) straighten(arg11) straighten(arg12) straighten(arg13) straighten(arg14) straighten(arg15) straighten(arg16)]; 
end
concat = double(concat);

%
% some vectors are row-oriented others are column-oriented. This fixes them all to be column oriented
%
function out = straighten (in)
[rows, columns] = size(in);
if (rows < columns)
 	out = in;
else
	out = in';
end

CONCAT_UTILITY

	close(CHAIN);
}

sub stitch_prediction_chain {
	my ($self,$commands) = @_;
	my ($xml_src, $outdir, $compression, $chain_name );
	
	GetOptions(
		'x=s' => \$xml_src, 
		'o=s' => \$outdir, 
		'a=s' => \$chain_name, 
		'compress' => \$compression 
	);
	$compression = ( $compression ? 7 : 0 );
	die "one or more options not specified"
		unless $xml_src and $outdir and $chain_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	my $manager = OME::Tasks::ChainManager->new($session);

	# find modules that produce signatures
	# simple implementation of leaf nodes for now
	logdbg "debug", "Finding Feature Extraction (leaf) Modules in chain $chain_name";
	my $chain;
	$chain = $factory->loadObject( "OME::AnalysisChain", $chain_name )
		if( $chain_name =~ m/^\d+$/ );
	unless ($chain) {
		my @chains = $factory->findObjects( "OME::AnalysisChain", name => $chain_name );
		die @chains." chains found with that name ($chain_name). Expected exactly 1."
			unless( scalar( @chains ) eq 1 );
		$chain = $chains[ 0 ];
	}
	
	my @signature_nodes = $manager->findLeaves( $chain );
	@signature_nodes = sort {$a->module->name cmp $b->module->name} @signature_nodes;

	# compute FI names that are going to be used in the prediction module
	logdbg "debug", "Computing names for Formal Inputs to the Prediction module";
	my @signature_node_names = $manager->createNodeTags (@signature_nodes);
	
	##############
	# create signature module (xml)
	logdbg "debug", "Writing Prediction module";
	my $doc = XML::LibXML::Document->new();
	die "Cannot create XML document"
	  unless defined $doc;
	my $root = $doc->createElementNS($OME_NS,'OME');
	$root->setNamespace($XSI_NAMESPACE, 'xsi',0);
	$root->setAttributeNS($XSI_NAMESPACE,'schemaLocation',"$OME_NS $OME_NS");
	$doc->setDocumentElement($root);

	# Parse the STDs
	my $parser = XML::LibXML->new();

	# add the module library
	my $module_library = $doc->createElementNS($AML_NS,'AnalysisModuleLibrary');
	$root->appendChild( $module_library );
	
	# Make the module
	my $module = $doc->createElement('AnalysisModule');
	$module->setAttribute( 'ModuleType', "OME::Analysis::Modules::Classification::WND_CHARM_Prediction");
	$module->setAttribute( 'Category', "Classification");
	my $new_LSID = $self->get_next_LSID( $xml_src );
	$module->setAttribute( 'ID', $new_LSID );
	$new_LSID =~ m/urn:lsid:openmicroscopy.org:Module:(\d+)/;
	my $module_name = "WND-CHARM-Prediction($1)";
	$module->setAttribute( 'ModuleName', $module_name );
	$module->setAttribute( 'ProgramID', "" );
	$module_library->appendChild( $module );
		
	# Make the description
	my $module_description = $doc->createElement('Description');
	$module_description->appendChild( XML::LibXML::Text->new( <<ENDDESCRIPTION ) );
Uses a classifier built with WND_CHARM_TrainerModule to make classification predictions
to input images.
ENDDESCRIPTION
	$module->appendChild( $module_description );
	
	# Declaration
	my $declaration = $doc->createElement('Declaration');
	$module->appendChild( $declaration );
	
	# Inputs
	my $formal_input = $doc->createElement( 'FormalInput');
	$formal_input->setAttribute( 'Name', 'Trained Classifier' );
	$formal_input->setAttribute( 'SemanticTypeName', 'WND_CHARM_TrainedClassifier' );
	$formal_input->setAttribute( 'Count', '!' );
	$declaration->appendChild( $formal_input );
	
	my $formal_input = $doc->createElement( 'FormalInput');
	$formal_input->setAttribute( 'Name', 'Categories Used by Trained Classifier' );
	$formal_input->setAttribute( 'SemanticTypeName', 'CategoriesUsed' );
	$formal_input->setAttribute( 'Count', '+' );
	$declaration->appendChild( $formal_input );
	
	my  @signature_node_names_copy = @signature_node_names;
	foreach my $sig_node ( @signature_nodes ) {
		my $signature_node_name = shift @signature_node_names_copy;
		
		foreach my $output ( $sig_node->module->outputs ) {
			my $ST_name = $output->semantic_type->name;
			$formal_input = $doc->createElement( 'FormalInput');
			$formal_input->setAttribute( 'Name', $signature_node_name.".".$ST_name);
			$formal_input->setAttribute( 'SemanticTypeName', $ST_name );
			$formal_input->setAttribute( 'Count', '!' );
			$declaration->appendChild( $formal_input );
		}
	}
	
	# Outputs
	my $formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'Prediction' );
	$formal_output->setAttribute( 'SemanticTypeName', 'Classification' );
	$formal_output->setAttribute( 'Count', '!' );
	$declaration->appendChild( $formal_output );
	
	# save to disk
	my $file_name = $module_name;
	$file_name =~ s/ //g;
	$file_name = $outdir. '/' . $file_name . ".ome";
	$doc->toFile( $file_name, 2 );
	logdbg "debug", "Saved WND CHARM Prediction Module to $file_name";
	
	# import module
	logdbg "debug", "Importing module $module_name into DB";
	OME::Tasks::ImageTasks::importFiles (undef, [ $file_name ] );
	my $prediction_module = $factory->findObject( "OME::Module", name => $module_name )
		or die "Could not load WND CHARM Prediction Module named '$module_name'";
	
	# create new chain that includes the prediction module (db)
	logdbg "debug", "Creating new chain that includes the prediction module";
	my ($new_chain, $node_mapping) = $manager->cloneChain( $chain, undef, 'gimme node mapping!' );
	$new_chain->name( "Image Classifier Prediction Chain ".$new_chain->id );
	$new_chain->storeObject();
	my $prediction_node  = $factory->newObject( 'OME::AnalysisChain::Node', {
		module         => $prediction_module,
		analysis_chain => $new_chain
	} );
	
	# make links
	foreach my $sig_node (@signature_nodes) {
		my $signature_node_name = shift (@signature_node_names);
		foreach my $output ($sig_node->module->outputs) {
			my $ST_name = $output->semantic_type->name;
			
			my $formal_input;
			$formal_input = $factory->findObject( "OME::Module::FormalInput",
				module => $prediction_module,
				name   => $signature_node_name.".".$ST_name
			) or die "Couldn't load input $signature_node_name::$ST_name for module $module_name";
			
			# use node_mapping to link the new node with the old
			my $from_node = $node_mapping->{$sig_node->id };
			
			my $data = {
				to_node     => $prediction_node,
				to_input    => $formal_input,
				from_node   => $from_node,
				from_output => $output,
				analysis_chain => $new_chain
			};
			$factory->newObject( "OME::AnalysisChain::Link", $data )
				or die "Couldn't make link from ".
					$from_node->module->name.".". $output->mae." to ".
					$prediction_node->name.".".$formal_input;
		}
	}
	$session->commitTransaction();
	
	
	# save new chain to disk
	my $chain_file = $new_chain->name().'.ome';
	$chain_file =~ s/ //g;
	$chain_file = $outdir. '/' . $chain_file;
	logdbg "debug", "Saving new chain to $chain_file";
	my $chainExport = OME::ImportExport::ChainExport->new();
	$chainExport->buildDOM ([$new_chain]);
	$chainExport->exportFile ($chain_file, compression => 0 );
}


sub stitch_training_chain {
	my ($self,$commands) = @_;
	my ($xml_src, $outdir, $compression, $chain_name );
	
	GetOptions(
		'x=s' => \$xml_src, 
		'o=s' => \$outdir, 
		'a=s' => \$chain_name, 
		'compress' => \$compression 
	);
	$compression = ( $compression ? 7 : 0 );
	die "one or more options not specified"
		unless $xml_src and $outdir and $chain_name;
	
	my $session = $self->getSession();
	my $factory = $session->Factory();
	my $manager = OME::Tasks::ChainManager->new($session);

	# find modules that produce signatures
	# simple implementation of leaf nodes for now
	logdbg "debug", "Finding Feature Extraction (leaf) Modules in chain $chain_name";
	my $chain;
	$chain = $factory->loadObject( "OME::AnalysisChain", $chain_name )
		if( $chain_name =~ m/^\d+$/ );
	unless ($chain) {
		my @chains = $factory->findObjects( "OME::AnalysisChain", name => $chain_name );
		die @chains." chains found with that name ($chain_name). Expected exactly 1."
			unless( scalar( @chains ) eq 1 );
		$chain = $chains[ 0 ];
	}
	
	my @signature_nodes = $manager->findLeaves( $chain );
	@signature_nodes = sort {$a->module->name cmp $b->module->name} @signature_nodes;

	# compute FI names that are going to be used in the trainer module
	logdbg "debug", "Computing names for Formal Inputs to the Trainer module";
	my @signature_node_names = $manager->createNodeTags (@signature_nodes);
	
	##############
	# create signature module (xml)
	logdbg "debug", "Writing trainer module";
	my $doc = XML::LibXML::Document->new();
	die "Cannot create XML document"
	  unless defined $doc;
	my $root = $doc->createElementNS($OME_NS,'OME');
	$root->setNamespace($XSI_NAMESPACE, 'xsi',0);
	$root->setAttributeNS($XSI_NAMESPACE,'schemaLocation',"$OME_NS $OME_NS");
	$doc->setDocumentElement($root);

	# Parse the STDs
	my $parser = XML::LibXML->new();

	# add the module library
	my $module_library = $doc->createElementNS($AML_NS,'AnalysisModuleLibrary');
	$root->appendChild( $module_library );
	
	# Make the module
	my $module = $doc->createElement('AnalysisModule');
	$module->setAttribute( 'ModuleType', "OME::Analysis::Modules::Classification::WND_CHARM_Trainer");
	$module->setAttribute( 'Category', "Classification");
	my $new_LSID = $self->get_next_LSID( $xml_src );
	$module->setAttribute( 'ID', $new_LSID );
	$new_LSID =~ m/urn:lsid:openmicroscopy.org:Module:(\d+)/;
	my $module_name = "WND-CHARM-Trainer($1)";
	$module->setAttribute( 'ModuleName', $module_name );
	$module->setAttribute( 'ProgramID', "" );
	$module_library->appendChild( $module );
		
	# Make the description
	my $module_description = $doc->createElement('Description');
	$module_description->appendChild( XML::LibXML::Text->new( <<ENDDESCRIPTION ) );
Builds a WND_CHARM_TrainerModule.
ENDDESCRIPTION
	$module->appendChild( $module_description );
	
	# Declaration
	my $declaration = $doc->createElement('Declaration');
	$module->appendChild( $declaration );
	
	# Inputs
	my  @signature_node_names_copy = @signature_node_names;
	foreach my $sig_node ( @signature_nodes ) {
		my $signature_node_name = shift @signature_node_names_copy;
		
		foreach my $output ( $sig_node->module->outputs ) {
			my $ST_name = $output->semantic_type->name;
			my $formal_input = $doc->createElement( 'FormalInput');
			$formal_input->setAttribute( 'Name', $signature_node_name.".".$ST_name);
			$formal_input->setAttribute( 'SemanticTypeName', $ST_name );
			$formal_input->setAttribute( 'Count', '+' );
			$declaration->appendChild( $formal_input );
		}
	}
	
	# Outputs
	my $formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'Trained Classifier' );
	$formal_output->setAttribute( 'SemanticTypeName', 'WND_CHARM_TrainedClassifier' );
	$formal_output->setAttribute( 'Count', '!' );
	$declaration->appendChild( $formal_output );
	$formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'Features Legend' );
	$formal_output->setAttribute( 'SemanticTypeName', 'ImageFeaturesLegend' );
	$formal_output->setAttribute( 'Count', '+' );
	$declaration->appendChild( $formal_output );
	$formal_output = $doc->createElement( 'FormalOutput');
	$formal_output->setAttribute( 'Name', 'Categories Used' );
	$formal_output->setAttribute( 'SemanticTypeName', 'CategoriesUsed' );
	$formal_output->setAttribute( 'Count', '+' );
	$declaration->appendChild( $formal_output );
	
	# save to disk
	my $file_name = $module_name;
	$file_name =~ s/ //g;
	$file_name = $outdir. '/' . $file_name . ".ome";
	$doc->toFile( $file_name, 2 );
	logdbg "debug", "Saved WND CHARM Trainer Module to $file_name";
	
	# import module
	logdbg "debug", "Importing module $module_name into DB";
	OME::Tasks::ImageTasks::importFiles (undef, [ $file_name ] );
	my $trainer_module = $factory->findObject( "OME::Module", name => $module_name )
		or die "Could not load WND CHARM Trainer Module named '$module_name'";
	
	# create new chain that includes the trainer module (db)
	logdbg "debug", "Creating new chain that includes the trainer module";
	my ($new_chain, $node_mapping) = $manager->cloneChain( $chain, undef, 'gimme node mapping!' );
	$new_chain->name( "Image Classifier Training Chain ".$new_chain->id );
	$new_chain->storeObject();
	my $trainer_node  = $factory->newObject( 'OME::AnalysisChain::Node', {
		module         => $trainer_module,
		analysis_chain => $new_chain
	} );
	
	# make links
	foreach my $sig_node (@signature_nodes) {
		my $signature_node_name = shift (@signature_node_names);
		foreach my $output ($sig_node->module->outputs) {
			my $ST_name = $output->semantic_type->name;
			
			my $formal_input;
			$formal_input = $factory->findObject( "OME::Module::FormalInput",
				module => $trainer_module,
				name   => $signature_node_name.".".$ST_name
			) or die "Couldn't load input $signature_node_name::$ST_name for module $module_name";
			
			# use node_mapping to link the new node with the old
			my $from_node = $node_mapping->{$sig_node->id };
			
			my $data = {
				to_node     => $trainer_node,
				to_input    => $formal_input,
				from_node   => $from_node,
				from_output => $output,
				analysis_chain => $new_chain
			};
			$factory->newObject( "OME::AnalysisChain::Link", $data )
				or die "Couldn't make link from ".
					$from_node->module->name.".". $output->mae." to ".
					$trainer_node->name.".".$formal_input;
		}
	}
	$session->commitTransaction();
	
	
	# save new chain to disk
	my $chain_file = $new_chain->name().'.ome';
	$chain_file =~ s/ //g;
	$chain_file = $outdir. '/' . $chain_file;
	logdbg "debug", "Saving new chain to $chain_file";
	my $chainExport = OME::ImportExport::ChainExport->new();
	$chainExport->buildDOM ([$new_chain]);
	$chainExport->exportFile ($chain_file, compression => 0 );
}

# I'm putting this in a separate function because the implementation
# will probably change.
sub get_classifications_and_category_numbers {
	my ($proto, $features, $classification_mex) = @_;
	logdbg "debug", "collecting image classifications.";
	my $factory = OME::Session->instance()->Factory();
	my %classifications;
	my $category_group;
	foreach my $feature ( @$features ) {
		my $image = $feature->image;
		# If we were given a mex or list of mexes, then use it to find classifications
		my @classification_list = ( $classification_mex ?
			@{ OME::Tasks::ModuleExecutionManager->
				getAttributesForMEX( $classification_mex, "Classification",
					{image => $feature->image } 
				) } :
			$factory->findAttributes( 'Classification', image => $image )
		);
		if( scalar( @classification_list ) == 0 ) {
			print STDERR "Could not find a classification for image ".$image->name()." (".$image->id.")\n";
			$classifications{ $image->id } = undef;
			next;
		}
		die "More than one classification found for image id=".$image->id
			unless scalar( @classification_list ) eq 1;
		$category_group = $classification_list[0]->Category->CategoryGroup
			unless $category_group;
		die "Classification for image id=".$image->id." does not belong to the same category group as other images in this dataset."
			unless $category_group->id eq $classification_list[0]->Category->CategoryGroup->id;
		$classifications{ $image->id } = $classification_list[0];
	}
	# map categories to category numbers
	my @categories = $factory->findAttributes( "Category", CategoryGroup => $category_group );
	my %category_numbers;
	my @category_names;
	my $cn = 0;
	foreach( sort { $a->Name cmp $b->Name } @categories ) { 
		$cn++;
		$category_numbers{ $_->id } = $cn;
		push(@category_names, $_->Name);
	}
	return (\%classifications, \%category_numbers, \@category_names);
}

sub get_next_LSID {
	my ($self, $xml_src ) = @_;
	my $session = $self->getSession();
	my $factory = $session->Factory();
	my $high_id=7200;

	# check module LSIDs in the xml directory.
	if( $xml_src ) {
		# FIXME: use something besides backticks to get the next LSID from the xml source files.
		my @grep_results = `grep -r 'urn:lsid:openmicroscopy.org:Module:72' $xml_src/*`;
		foreach( @grep_results ) {
			if( m/urn:lsid:openmicroscopy.org:Module:(72\d\d)/ ) {
				$high_id = $1 if $1 gt $high_id;
			}
		}
	}
	
	# just for yucks, check against LSIDs from the DB
	my @LSIDs = $factory->findObjects( "OME::LSID",
		lsid => [ 'like', 'urn:lsid:openmicroscopy.org:Module:72%' ]
	);
	foreach( map( $_->lsid, @LSIDs) ) {
		if( m/urn:lsid:openmicroscopy.org:Module:(72\d\d)/ ) {
			$high_id = $1 if $1 gt $high_id;
		}		
	}

	return 'urn:lsid:openmicroscopy.org:Module:'.($high_id + 1);
}

1;
