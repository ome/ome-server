# OME/Tasks/AnalysisEngine.pm

# Copyright (C) 2002 Open Microscopy Environment, MIT
# Author:  Douglas Creager <dcreager@alum.mit.edu>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


package OME::Tasks::AnalysisEngine;

use strict;
our $VERSION = '1.0';

use OME::Factory;
use OME::DBObject;
use OME::Dataset;
use OME::Image;
use OME::Program;
use OME::Analysis;
use OME::AnalysisView;


# For now assume the module type is the Perl class of the
# module handler.

sub findModuleHandler {
    return shift;
}

sub executeAnalysisView {
    my ($session, $view, $input_parameters, $dataset) = @_;
    my $factory = $session->Factory();

    # all nodes
    my @nodes = $view->nodes();

    # the program objects for each node
    my %node_programs;

    # current state of each node
    use constant INPUT_STATE    => 1;
    use constant FINISHED_STATE => 2;
    my %node_states;

    # the outputs generated by each node
    # $dataset_outputs{$node}->{$formal_output} = $attribute 
    # $image_outputs{$node}->{$formal_output}->{$image} = $attribute
    # $feature_outputs{$node}->{$formal_output}->{$feature} = $attribute
    my (%dataset_outputs,%image_outputs,%feature_outputs);

    my %input_links;
    my %output_links;
    my %analyses;
    
    # initialize all of the nodes
    foreach my $node (@nodes) {
	my $program = $node->program();
	my $module_type = $program->module_type();
	my $location = $program->location();

	my $module = findModuleHandler($module_type)->new($location);
	$node_programs{$node} = $module;

	my @inputs = $node->input_links();
	foreach my $input (@inputs) {
	    my $attribute_type = $input->to_input()->
		column_type()->
		datatype()->
		attribute_type();
	    push @{$input_links{$node}->{$attribute_type}}, $input;
	}

	my @outputs = $node->output_links();
	foreach my $output (@outputs) {
	    my $attribute_type = $output->from_output()->
		column_type()->
		datatype()->
		attribute_type();
	    push @{$output_links{$node}->{$attribute_type}}, $output;
	}

	$node_states{$node} = INPUT_STATE;

	my $analysis_data = {
	    program      => $program,
	    dataset      => $dataset,
	    experimenter => $session->User(),
	    timestamp    => 'now',
	    status       => 'STARTED'
	};
	my $analysis = $factory->newObject("OME::Analysis",$analysis_data);
	$analyses{$node} = $analysis;
    }

    my $continue = 1;
    my $round = 0;

    while ($continue) {
	$continue = 0;
	$round++;
	print STDERR "Round $round...\n";

	# Look for input_nodes that are ready to run (i.e., whose
	# predecessor nodes have been completed).
	foreach my $node (@node) {
	    next if $node_states{$node} > INPUT_STATE;

	    my $ready = 1;

	    # If any of the predecessors has not finished, then this
	    # node is not ready to run.
	    my $inputs = $inputs_links{$node};
	    foreach my $input (@$inputs) {
		my $pred_node = $input->from_node();
		$ready = 0, last if ($node_states{$pred_node} < FINISHED_STATE);
	    }

	    next unless $ready;

	    # Execute away.
	    my $module = $node_programs{$node};
	    my $inputs = $input_links{$node};
	    my $outputs = $output_links{$node};

	    # Define some helper procedures
	    my $create_actual_input = sub {
		my ($input,$attribute) = @_;

		my $formal_input = $input->to_input();

		my $actual_input_data = {
		    analysis     => $analyses{$node},
		    formal_input => $formal_input,
		    attribute    => $attribute
		};
		my $actual_input = $factory->newObject("OME::Analysis::ActualInput",
						       $actual_input_data);
	    };

	    my $create_actual_output = sub {
		my ($output,$attributes) = @_;

		my $formal_output = $output->from_output();
		my $attribute = $attributes->{$formal_output};

		my $actual_output_data = {
		    analysis      => $analyses{$node},
		    formal_output => $formal_output,
		    attribute     => $attribute
		    };
		my $actual_output = $factory->newObject("OME::Analysis::ActualOutput",
							$actual_output_data);
	    };

	    $module->startDataset($dataset);

	    # Collect and present the dataset inputs
	    my $dataset_inputs = $inputs->{D};
	    my %dataset_hash;
	    foreach my $input (@$dataset_inputs) {
		my $formal_output = $input->from_output();
		my $attribute = $dataset_outputs{$node}->{$formal_output};
		&$create_actual_input($input,$attribute);

		$dataset_hash{$formal_input} = $attribute;
	    }
	    $module->datasetInputs(\%dataset_hash);

	    my $images = $dataset->images();
	    while (my $image = $images->next()) {
		# Collect and present the image inputs

		$module->startImage($image);

		my $image_inputs = $inputs->{I};
		my %image_hash;

		foreach my $input (@$image_inputs} {
		    my $formal_output = $input->from_output();
		    my $attribute = $image_outputs{$node}->{$formal_output}->{$image};
		    &$create_actual_input($input,$attribute);
		    
		    $image_hash{$formal_input} = $attribute;
		}

		$module->imageInputs(\%image_hash);

		my $features = $image->features();
		while (my $feature = $features->next()) {
		    # Collect and present the feature inputs.

		    $module->startFeature($feature);

		    my $feature_inputs = $inputs->{F};
		    my %feature_hash;

		    foreach my $input (@$feature_inputs} {
			my $formal_output = $input->from_output();
			my $attribute = $feature_outputs{$node}->{$formal_output}->
			    {$feature};
			&$create_actual_input($input,$attribute);

			$feature_hash{$formal_input} = $attribute;
		    }

		    $module->featureInputs(\%feature_hash);


		    # Collect and process the feature outputs

		    my $feature_attributes = $module->collectFeatureOutputs();
		    my $feature_outputs = $outputs->{F};

		    foreach my $output (@$feature_outputs) {
			&$create_actual_output($output,$feature_attributes);
			my $formal_output = $output->from_output();
			$feature_outputs{$node}->{$formal_output}->{$feature} = $attribute;
		    }

		    $module->finishFeature($feature);
		} # foreach $feature

		# Collect and process the image outputs

		my $image_attributes = $module->collectImageOutputs();
		my $image_outputs = $outputs->{F};
		
		foreach my $output (@$image_outputs) {
		    &$create_actual_output($output,$image_attributes);
		    my $formal_output = $output->from_output();
		    $image_outputs{$node}->{$formal_output}->{$image} = $attribute;
		}

		$module->finishImage($image);
	    } # foreach $image

	    # Collect and process the dataset outputs

	    my $dataset_attributes = $module->collectDatasetOutputs();
	    my $dataset_outputs = $outputs->{F};
	    
	    foreach my $output (@$dataset_outputs) {
		&$create_actual_output($output,$dataset_attributes);
		my $formal_output = $output->from_output();
		$dataset_outputs{$node}->{$formal_output} = $attribute;
	    }
	    
	    $module->finishDataset($dataset);

	    # Mark this node as finished, and flag that we need
	    # another fixed point iteration.

	    $node_states{$node} = FINISHED_STATE;
	    $continue = 1;
	} # foreach $node
    } # while ($continue)
}

__END__

=head1 NAME

  OME::Tasks::AnalysisEngine - OME anaylsis subsystem

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 AUTHOR

Douglas Creager <dcreager@alum.mit.edu>

Open Microscopy Environment, MIT 

=head1 SEE ALSO

L<OME>, http://www.openmicroscopy.org/

=cut
