# OME/Analysis/AnalysisEngine.pm

#-------------------------------------------------------------------------------
#
# Copyright (C) 2003 Open Microscopy Environment
#       Massachusetts Institute of Technology,
#       National Institutes of Health,
#       University of Dundee
#
#
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#-------------------------------------------------------------------------------




#-------------------------------------------------------------------------------
#
# Written by:    Douglas Creager <dcreager@alum.mit.edu>
#
#-------------------------------------------------------------------------------


package OME::Analysis::AnalysisEngine;

=head1 NAME

OME::Analysis::AnalysisEngine - OME analysis subsystem

=head1 SYNOPSIS

	use OME::Analysis::AnalysisEngine;
	my $engine = new OME::Analysis::AnalysisEngine();

	# login to OME, load/create an module_execution view and dataset
	$engine->executeAnalysisView($session,$view,$free_inputs,$dataset);

	# Voila, you're done.

=head1 DESCRIPTION

OME::Analysis::AnalysisEngine is implements the execution algorithm of
the OME analysis subsystem.  Given an analysis chain, which is a
directed acylic graph of analysis nodes, and a dataset, which is a
collection of OME images, the engine will execute each node in the
chain against the dataset, recording the results and all of the
appropriate metadata into the OME database.

=cut

use strict;
use OME;
our $VERSION = $OME::VERSION;

use Carp;
use Log::Agent;
use OME::Factory;
use OME::DBObject;
use OME::Dataset;
use OME::Image;
use OME::Module;
use OME::ModuleExecution;
use OME::AnalysisChain;
use OME::AnalysisPath;
use OME::AnalysisChainExecution;
use OME::SessionManager;
use OME::DBConnection;
use OME::Analysis::Engine::ForkedPerlExecutor;
use OME::Analysis::Engine::UnthreadedPerlExecutor;

use Benchmark qw(timediff timesum timestr);

use fields qw(_flags);

sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;

    my $self = {
                _flags => {
                           ReuseResults => 1,
                           DebugDefault => 1,
                           DebugTiming  => 1
                          },
               };
    return bless $self, $class;
}


sub Flag {
    my ($self,$flag,$value) = @_;

    return (defined $value)? 
        $self->{_flags}->{$flag} = $value:
        $self->{_flags}->{$flag};
}



# For now assume the module type is the Perl class of the
# module handler.

sub findModuleHandler {
    return shift;
}

{
    # We'll need several shared variables for these internal
    # functions.  They are defined here.

    # The instance of this class.
    my $self;

    # The user's database session.
    my $session;

    # The database factory used to create new database objects and to
    # find existing ones.
    my $factory;

    # The analysis chain being executed.
    my $analysis_chain;

    # The hash of the user-specified input parameters.
    my $input_parameters;

    # The hash of the analyses providing each set of user-specified
    # inputs.
    my %user_input_analyses;
    my %node_inputs;

    # The dataset the chain is being executed against.
    my $dataset;

    # A list of nodes in the analysis chain.
    my @nodes;

    # A hash of nodes keyed by node ID.
    my %nodes;

    # The current state of each node.
    use constant INPUT_STATE    => 1;
    use constant FINISHED_STATE => 2;
    my %node_states;

    # The input and output links for each node.
    # $input_links{$nodeID}->{$granularity} = $analysis_link
    # $output_links{$nodeID}->{$granularity} = $analysis_link
    #my %input_links;
    #my %output_links;

    # The analysis_chain_execution entry for this chain execution.
    my $analysis_chain_execution;

    # The dataset-dependence of each node.
    # $dependence{$nodeID} = [D,I]
    my %dependence;

    # The ANALYSES for each node.
    # $global_analysis{$nodeID} = $module_execution
    # $perdataset_analysis{$nodeID} = $module_execution
    # $perimage_analysis{$nodeID}->{$imageID} = $module_execution
    my (%global_analysis, %perdataset_analysis,%perimage_analysis);

    # The outputs generated by each node
    # $dataset_outputs{$nodeID}->
    #   {$formal_outputID} = $attribute
    # $image_outputs{$nodeID}->{$formal_outputID}->
    #   {$imageID} = $attribute
    # $feature_outputs{$nodeID}->{$formal_outputID}->
    #   {$imageID}->{$featureID} = $attribute
    #my (%dataset_outputs,%image_outputs,%feature_outputs);

    # Whether or not we need another round in the fixed-point loop.
    my $continue;

    # Which of those rounds we are in.
    my $round;

    # The node which was most recently executed.
    my $last_node;

    # The following variables are only valid within the per-node loop.
    # They refer to the module currently being examined/executed.
    my ($curr_node,$curr_nodeID,@curr_predecessorIDs);
    my ($curr_inputs,$curr_outputs);
    my (@curr_global_inputs,@curr_dataset_inputs,
        @curr_image_inputs,@curr_feature_inputs);
    my (@curr_global_outputs,@curr_dataset_outputs,
        @curr_image_outputs,@curr_feature_outputs);
    my ($curr_image,$curr_imageID);
    my ($curr_feature,$curr_featureID);

    # The list of data paths found.
    my @data_paths;

    # The data paths to which each node belongs.
    my %data_paths;

    # Timing benchmarks
    my $start_time;
    my $end_time;

    sub __clearEverything {
        $factory = undef;
        %user_input_analyses = ();
        %node_inputs = ();
        @nodes = ();
        %nodes = ();
        %node_states = ();
        $analysis_chain_execution = undef;
        %dependence = ();
        %global_analysis = ();
        %perdataset_analysis = ();
        %perimage_analysis = ();
        $continue = undef;
        $round = undef;
        $last_node = undef;
        $curr_node = undef;
        $curr_nodeID = undef;
        @curr_predecessorIDs = ();
        $curr_inputs = undef;
        $curr_outputs = undef;
        @curr_global_inputs = ();
        @curr_dataset_inputs = ();
        @curr_image_inputs = ();
        @curr_feature_inputs = ();
        @curr_global_outputs = ();
        @curr_dataset_outputs = ();
        @curr_image_outputs = ();
        @curr_feature_outputs = ();
        @data_paths = ();
        %data_paths = ();
        $start_time = undef;
        $end_time = undef;
    }

    # A debug routine
    sub __debug {
        my ($message,$group) = @_;
        $group = defined $group? $group: "Default";

        logtrc "notice", "$message" if $self->Flag("Debug$group");
    }

    # Some helpful database routines

    # Returns the first column of the first row of an executed DBI
    # statement handle.
    sub __fetchone {
        my ($sth) = @_;

        if (my $row = $sth->fetch()) {
            $sth->finish();
            return $row->[0];
        } else {
            return undef;
        }
    }

    # Returns the same as __fetchone, but assumes that the value is a
    # primary key for the specified class.  Instantiates the object
    # and returns it.
    sub __fetchobj {
        my ($class,$sth) = @_;

        if (my $row = $sth->fetch()) {
            $sth->finish();
            return $factory->loadObject($class,$row->[0]);
        } else {
            return undef;
        }
    }

    # Returns an array of the values in the first column of an
    # executed DBI statement handle.
    sub __fetchall {
        my ($sth) = @_;
        my (@results,$row);

        push @results, $row->[0]
          while ($row = $sth->fetch());
        return \@results;
    }

    # Returns the same of __fetchall, but assumes that the value is a
    # primary key for the specified class.  Instantiates an object for
    # each row.
    sub __fetchobjs {
        my ($class,$sth) = @_;
        my (@results,$row);

        push @results, $factory->loadObject($class,$row->[0])
          while ($row = $sth->fetch());
        return \@results;
    }

    # This routine prepares the all of the internal variables for each
    # node in the chain.  It loads in the appropriate module handler,
    # and initializes it with the module's location, and sets up the
    # [dataset,image,feature]_[inputs,outputs] hashes with the input
    # and output links of the module.  Currently, all outputs are
    # added to the hashes, regardless of whether or not they are
    # linked to anything.  However, only those inputs which are
    # connected are pushed into their hashes.
    sub __initializeNode {
        my $module = $curr_node->module();
        my $module_type = $module->module_type();
        my $location = $module->location();

        $nodes{$curr_nodeID} = $curr_node;

        __debug("  ".$module->name());

        $node_states{$curr_nodeID} = INPUT_STATE;
    }

    # Returns a list of successor nodes to a node.
    sub __successors {
        my ($nodeID) = @_;

        my @links = $factory->
          findObjects("OME::AnalysisChain::Link",
                      { from_node => $nodeID });
        my %to_nodes;
        $to_nodes{$_->to_node()->id()} = undef
          foreach @links;
        my @to_nodes = keys %to_nodes;
        return \@to_nodes;
    }

    # Verifies that every formal input has zero or one links feeding
    # it.  It a formal input has zero links feeding it, verifies that
    # the user input provided for the input (defaulting to null) is
    # valid, according to the input's optional and list specification.
    # Also verifies that each link is well-formed; i.e., that the
    # "from output" belongs to the "from node", the "to input" belongs
    # to the "to node", and that the types of the "from output" and
    # "to input" match.
    sub __checkInputs {
        __debug("    Sorting and checking links");
        foreach my $link ($analysis_chain->links()) {
            my $from_node = $link->from_node();
            my $from_output = $link->from_output();
            my $to_node = $link->to_node();
            my $to_input = $link->to_input();

            my $long_name =
              $from_node->module()->name().".".
              $from_output->name()." -> ".
              $to_node->module()->name().".".
              $to_input->name();
            my $short_name =
              $to_node->module()->name().".".
              $to_input->name();

            die
              "$long_name: 'From output' does not belong to 'from node'"
              if ($from_output->module()->id() ne
                  $from_node->module()->id());

            die
              "$long_name: 'To input' does not belong to 'to node'"
              if ($to_input->module()->id() ne
                  $to_node->module()->id());

            die
              "$long_name: Types don't match"
              unless (!defined $from_output->semantic_type())
                || ($from_output->semantic_type()->id() eq
                    $to_input->semantic_type()->id());

            die
              "$short_name: Two links cannot feed into the same input!"
              if (exists $node_inputs{$to_node->id()}->{$to_input->id()});

            $node_inputs{$to_node->id()}->{$to_input->id()} = $link;
        }

        # Contains the number of distinct user inputs of each
        # semantic type.
        my %input_types;
        my %input_analyses;
        my $max_input_analyses = 0;

        __debug("    Checking nodes");
        foreach my $node (@nodes) {
            __debug("      ".$node->module()->name());
            my @inputs = $node->module()->inputs();
            foreach my $input (@inputs) {
                # Okay if there's a link feeding this input
                my $nodeID = $node->id();
                my $inputID = $input->id();
                next if exists $node_inputs{$nodeID}->{$inputID};

                # Keep a count of the number of user inputs of this type
                my $semantic_type = $input->semantic_type();
                my $semantic_typeID = $semantic_type->id();
                $input_types{$semantic_typeID}++;

                # ...and keep track of the maximum of that count
                my $this_max = $input_types{$semantic_typeID};
                $input_analyses{$nodeID}->{$inputID} = $this_max;
                $max_input_analyses = $this_max
                  if $this_max > $max_input_analyses;

                # See if the user provided inputs
                my $user;
                if (exists $input_parameters->{$nodeID}->{$inputID}) {
                    $user = $input_parameters->{$nodeID}->{$inputID};
                    if (UNIVERSAL::isa($user,"OME::SemanticType::Superclass")) {
                        # If the user provided a single input, wrap it
                        # in an array ref
                        $user = [$user];
                    } elsif (ref($user) ne 'ARRAY') {
                        # Otherwise only accept the input if its an
                        # array ref
                        die
                          $node->module()->name().".".
                          $input->name().
                          ": User input must be an attribute ".
                          "or array of attributes";
                    }
                } else {
                    # User did not provide input, so treat this input
                    # as receiving an empty array
                    $user = [];
                }
                $input_parameters->{$nodeID}->{$inputID} = $user;

                # Check those inputs against the spec
                die "Input is not optional"
                  if (!$input->optional()) && (scalar(@$user) == 0);
                die "Input cannot accept a list"
                  if (!$input->list()) && (scalar(@$user) > 1);
            }
        }

        __debug("    Creating $max_input_analyses user input analyses");
        my @analyses;
        $analyses[$_] = $factory->
          newObject("OME::ModuleExecution",
                    {
                     module_id => undef,
                     dependence => 'D',
                     dataset_id => $dataset->id(),
                     timestamp  => 'now',
                     status     => 'FINISHED',
                    })
          foreach 0..$max_input_analyses-1;

        #print join("\n",@analyses),"\n";

        # Create a hash, recording which module_execution we will associate each
        # user input with.  We won't actually clone the user inputs
        # until it's time to execute the module.  (This prevents extra
        # user inputs from cluttering everything in case the chain
        # doesn't execute completely.)

        foreach my $nodeID (keys %input_analyses) {
            foreach my $inputID (keys %{$input_analyses{$nodeID}}) {
                my $index = $input_analyses{$nodeID}->{$inputID};
                __debug("      ${nodeID}.${inputID} = $index");
                $user_input_analyses{$nodeID}->{$inputID} =
                  $analyses[$index-1];
            }
        }
    }

    # Clones the user inputs for the current node.  The cloned
    # attributes are associated with the module_execution created by the
    # __checkInputs method.

    sub __cloneUserInputs {
        #print "      CLONE $curr_nodeID\n";
        foreach my $inputID (keys %{$user_input_analyses{$curr_nodeID}}) {
            my $inputs = $input_parameters->{$curr_nodeID}->{$inputID};
            my $module_execution = $user_input_analyses{$curr_nodeID}->{$inputID};
            #print "         $inputID - ",$module_execution->id(),"\n";

            foreach my $attribute (@$inputs) {
                my $type = $attribute->semantic_type();
                my $target = $attribute->target();
                my $hash = $attribute->getDataHash();

                my $clone = $factory->
                  newAttribute($type,$target,$module_execution,$hash);
                $session->commitTransaction();
                #print "          $clone\n";
            }
        }
    }

    # Builds the data paths for an module_execution chain.  Simultaneous
    # verifies that the graph is acyclic.
    sub __buildDataPaths {
        __debug("  Building data paths");

        # A data path is represented by a list of node ID's, starting
        # with a root node and ending with a leaf node.

        my $sth;

        # First, we create paths for each root node in the chain
        foreach my $node (@nodes) {
            my @links = $node->input_links();
            if (scalar(@links) == 0) {
                __debug("    Found root node ".$node->id());
                my $path = [$node->id()];
                push @data_paths, $path;
            }
        }

        # Then, we iteratively extend each path until it reaches a
        # leaf node.  If at any point, it branches, we create
        # duplicates so that there is one path per branch-point.
        my $continue = 1;
        while ($continue) {
            $continue = 0;
            my @new_paths;
            while (my $data_path = shift(@data_paths)) {
                my $end_nodeID = $data_path->[$#$data_path];
                my $successors = __successors($end_nodeID);
                my $num_successors = scalar(@$successors);

                if ($num_successors == 0) {
                    push @new_paths,$data_path;
                } elsif ($num_successors == 1) {
                    # Check for a cycle
                    foreach (@$data_path) {
                        die
                          "Cycle! ".join(':',@$data_path,$successors->[0])
                            if $_ eq $successors->[0];
                    }

                    __debug("    Extending ".
                      join(':',@$data_path)." with ".
                        $successors->[0]);
                    push @$data_path, $successors->[0];
                    push @new_paths,$data_path;
                    $continue = 1;
                } else {
                    foreach my $successor (@$successors) {
                        # Check for a cycle
                        foreach (@$data_path) {
                            die
                              "Cycle! ".join(':',@$data_path,$successors->[0])
                                if $_ eq $successors->[0];
                        }

                        # make a copy
                        my $new_path = [@$data_path];
                        __debug("    Extending ".
                          join(':',@$new_path)." with ".
                            $successor);
                        push @$new_path, $successor;
                        push @new_paths, $new_path;
                    }
                    $continue = 1;
                }
            }

            @data_paths = @new_paths;
        }

        foreach my $data_path_list (@data_paths) {
            my $data_path = $factory->
              newObject("OME::AnalysisPath",
                        {
                         path_length   => scalar(@$data_path_list),
                         analysis_chain => $analysis_chain
                        });
            my $data_pathID = $data_path->id();

            my $order = 0;
            foreach my $nodeID (@$data_path_list) {
                my $path_entry =
                  {
                   path               => $data_path,
                   path_order         => $order,
                   analysis_chain_node => $nodeID
                  };
                my $db_path_entry = $factory->
                  newObject("OME::AnalysisPath::Map",
                            $path_entry);
                push @{$data_paths{$nodeID}}, $db_path_entry;
                $order++;
            }
        }
    }

    # Loads the data paths for an analysis chain which has already had
    # them built.
    sub __loadDataPaths {
        __debug("  Loading data paths");

        my @db_paths = $analysis_chain->paths();
        foreach my $db_path (@db_paths) {
            my @db_path_entries = $db_path->path_nodes();
            foreach my $db_path_entry (@db_path_entries) {
                push
                  @{$data_paths{$db_path_entry->analysis_chain_node()->id()}},
                  $db_path_entry;
            }
        }
    }

    # Returns the correct module_execution entry for the given node.  Takes
    # into account the dataset-dependence of the node; if it is a
    # per-image node, it finds the module_execution entry for the current
    # image.
    sub __getAnalysis {
        my ($nodeID) = @_;

		# Dependence is calculated before analysis hashes are filled out.
		# This line prevents error msg: Use of uninitialized value in string eq at OME/Analysis/AnalysisEngine.pm line 629.
		return undef if not exists $dependence{$nodeID};

        if ($dependence{$nodeID} eq 'G') {
            return $global_analysis{$nodeID};
        } elsif ($dependence{$nodeID} eq 'D') {
            return $perdataset_analysis{$nodeID};
        } else {
            return $perimage_analysis{$nodeID}->{$curr_imageID};
        }
    }

    # If any of the predecessors has not finished, then this
    # node is not ready to run.
    sub __testModulePredecessors {
        my $ready = 1;

      TEST_PRED:
        foreach my $predID (@curr_predecessorIDs) {
            my $module_execution = __getAnalysis($predID);
            if (!defined $module_execution) {
                # This means we haven't even tried to execute this
                # predecessor, so we're not even close to being ready.
                $ready = 0;
                last TEST_PRED;
            }

            my $status = $module_execution->status();

            # If we already know it's finished (successfully or not),
            # don't bother re-reading from the database

            next TEST_PRED if $status eq 'FINISHED';

            if ($status eq 'ERROR') {
                $ready = 0;
                last TEST_PRED;
            }

            # Otherwise, we think the module is still running.  Once
            # it's done, its Executor will set the STATUS field of the
            # appropriate module execution to FINISHED or ERROR, but
            # we'll have to refresh the module execution from the
            # database to see any changes.

            $module_execution->refresh();
            $status = $module_execution->status();

            # If the predecessor has not finished successfully (i.e.,
            # it's still running, or it finished with an error), then
            # the current node cannot execute.

            if ($status ne 'FINISHED') {
                $ready = 0;
                last TEST_PRED;
            }
        }

        return $ready;
    }

    # Determines whether the current node is a global, per-dataset or
    # per-image module.  If a module outputs any global attributes
    # (which is only allowed if all of its inputs are global
    # attributes), then the module is global.  If a module takes in
    # any dataset inputs, or outputs any dataset outputs, or if any of
    # its immediate predecessors nodes are per-dataset, then it as
    # per-dataset.  Otherwise, it is per-image.  This notion of
    # dataset-dependency comes in to play later when determine whether
    # or not a module's results can be reused.
    sub __determineDependence {
        if ($factory->
            objectExists("OME::Module::FormalOutput",
                         {
                          module => $curr_node->module(),
                          'semantic_type.granularity' => 'G',
                         })) {
            $dependence{$curr_nodeID} = 'G';

            if ($factory->
                objectExists("OME::Module::FormalInput",
                             {
                              module => $curr_node->module(),
                              'semantic_type.granularity' =>
                              ['in',['D','I','F']],
                             })) {
                die "Node $curr_nodeID illegally generates global outputs";
            }

            return;
        }

        if ($factory->
            objectExists("OME::Module::FormalInput",
                         {
                          module => $curr_node->module(),
                          'semantic_type.granularity' => 'D',
                         })) {
            $dependence{$curr_nodeID} = 'D';
            return;
        }

        if ($factory->
            objectExists("OME::Module::FormalOutput",
                         {
                          module => $curr_node->module(),
                          'semantic_type.granularity' => 'D',
                         })) {
            $dependence{$curr_nodeID} = 'D';
            return;
        }

        foreach my $predID (@curr_predecessorIDs) {
            if ($dependence{$predID} eq 'D') {
                $dependence{$curr_nodeID} = 'D';
                return;
            }
        }

        $dependence{$curr_nodeID} = 'I';
    }

    # The following routines are used to check to see if we need to
    # execute the current module, or if it can be reused.
    #
    # We allow results to be reused if the "input tag" of the current
    # module's state is equal to the input tag of a previous execution
    # of the same module.  The input tag is a string that captures the
    # essence of a module's input.  It records: whether the module was
    # run in a per-dataset manner, or a per-image manner; which
    # dataset or image (respectively) it was run against; and the
    # attribute ID's presented to the module as input.

    # This routine calculates the input tag of the current module.
    # This routine will not get called unless a module is ready to be
    # executed, which means that the results of the predecessor
    # modules are available.  It is the attribute ID's of these
    # results that are encoded into the input tag.
    sub __calculateCurrentInputTag {
        my ($paramString);

        if ($dependence{$curr_nodeID} eq 'G') {
            $paramString = "G ";
        } elsif ($dependence{$curr_nodeID} eq 'D') {
            $paramString = "D ".$dataset->id()." ";
        } else {
            $paramString = "I ".$curr_imageID." ";
        }

        $paramString .= "g ";

        foreach my $formal_input (@curr_global_inputs) {
            my $formal_inputID = $formal_input->id();
            $paramString .= $formal_inputID."(";

            my $input_link = $factory->
              findObject("OME::AnalysisChain::Link",
                         { to_node => $curr_node, to_input => $formal_input });
            my ($pred_node,$pred_analysis);

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();
            #print "   $pred_analysisID\n";

            my $semantic_type = $formal_input->semantic_type();
            my @attributes = sort { $a <=> $b }
              $factory->
                findAttributes($semantic_type,
                               { module_execution => $pred_analysisID });

            $paramString .= $_->id()." "
                foreach @attributes;
            $paramString .= ") ";
        }

        $paramString .= "d ";

        foreach my $formal_input (@curr_dataset_inputs) {
            my $formal_inputID = $formal_input->id();
            $paramString .= $formal_inputID."(";

            my $input_link = $factory->
              findObject("OME::AnalysisChain::Link",
                         { to_node => $curr_node, to_input => $formal_input });
            my ($pred_node,$pred_analysis);

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();

            my $semantic_type = $formal_input->semantic_type();
            my @attributes = sort { $a <=> $b }
              $factory->
                findAttributes($semantic_type,
                               { module_execution => $pred_analysisID });

            $paramString .= $_->id()." "
                foreach @attributes;
            $paramString .= ") ";
        }

        $paramString .= "i ";

        foreach my $formal_input (@curr_image_inputs) {
            my $formal_inputID = $formal_input->id();
            $paramString .= $formal_inputID."(";

            my $input_link = $factory->
              findObject("OME::AnalysisChain::Link",
                         { to_node => $curr_node, to_input => $formal_input });
            my ($pred_node,$pred_analysis);

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();

            my $semantic_type = $formal_input->semantic_type();
            my @attributes;

            if ($dependence{$curr_nodeID} eq 'D') {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID });
            } else {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID,
                                     image => $curr_imageID });
            }

            $paramString .= $_->id()." "
                foreach @attributes;
            $paramString .= ") ";
        }

        $paramString .= "f ";

        foreach my $formal_input (@curr_feature_inputs) {
            my $formal_inputID = $formal_input->id();
            $paramString .= $formal_inputID."(";

            my $input_link = $factory->
              findObject("OME::AnalysisChain::Link",
                         { to_node => $curr_node, to_input => $formal_input });
            my ($pred_node,$pred_analysis);

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();

            my $semantic_type = $formal_input->semantic_type();
            my @attributes;

            if ($dependence{$curr_nodeID} eq 'D') {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID });
            } else {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID,
                                     'feature.image' => $curr_imageID });
            }

            $paramString .= $_->id()." "
                foreach @attributes;
            $paramString .= ") ";
        }

        return $paramString;
    }

    # This routine calculates the input tag of a previous module_execution.
    # All of the appropriate elements of the tag can be retrieved from
    # the ANALYSES and ACTUAL_INPUTS tables.
    sub __calculatePastInputTag {
        my ($past_analysis) = @_;
        my $past_analysisID = $past_analysis->id();
        my ($past_paramString);

        if ($past_analysis->dependence() eq 'G') {
            $past_paramString = "G ";
        } elsif ($past_analysis->dependence() eq 'D') {
            $past_paramString = "D ".$past_analysis->dataset()->id()." ";
        } else {
            $past_paramString = "I ".$curr_imageID." ";
        }

        my @formal_inputs;

        $past_paramString .= "g ";
        @formal_inputs = $factory->
          findObjects("OME::Module::FormalInput",
                      { module => $past_analysis->module(),
                        'semantic_type.granularity' => 'G' });

        foreach my $formal_input (@formal_inputs) {
            my $formal_inputID = $formal_input->id();
            $past_paramString .= $formal_inputID."(";

            my $actual_input = $factory->
              findObject("OME::ModuleExecution::ActualInput",
                         { module_execution => $past_analysis,
                           formal_input => $formal_input });
            my $input_module_execution =
              $actual_input->input_module_execution();
            my ($pred_node,$pred_analysis);
            my $input_link = $node_inputs{$curr_nodeID}->{$formal_inputID};

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();

            my $semantic_type = $formal_input->semantic_type();
            my @attributes = sort { $a <=> $b }
              $factory->
                findAttributes($semantic_type,
                               { module_execution => $pred_analysisID });

            $past_paramString .= $_->id()." "
                foreach @attributes;
            $past_paramString .= ") ";
        }

        $past_paramString .= "d ";
        @formal_inputs = $factory->
          findObjects("OME::Module::FormalInput",
                      { module => $past_analysis->module(),
                        'semantic_type.granularity' => 'D' });

        foreach my $formal_input (@formal_inputs) {
            my $formal_inputID = $formal_input->id();
            $past_paramString .= $formal_inputID."(";

            my $actual_input = $factory->
              findObject("OME::ModuleExecution::ActualInput",
                         { module_execution => $past_analysis,
                           formal_input => $formal_input });
            my $input_module_execution =
              $actual_input->input_module_execution();
            my ($pred_node,$pred_analysis);
            my $input_link = $node_inputs{$curr_nodeID}->{$formal_inputID};

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();

            my $semantic_type = $formal_input->semantic_type();
            my @attributes = sort { $a <=> $b }
              $factory->
                findAttributes($semantic_type,
                               { module_execution => $pred_analysisID });

            $past_paramString .= $_->id()." "
                foreach @attributes;
            $past_paramString .= ") ";
        }

        $past_paramString .= "i ";
        @formal_inputs = $factory->
          findObjects("OME::Module::FormalInput",
                      { module => $past_analysis->module(),
                        'semantic_type.granularity' => 'I' });

        foreach my $formal_input (@formal_inputs) {
            my $formal_inputID = $formal_input->id();
            $past_paramString .= $formal_inputID."(";

            my $actual_input = $factory->
              findObject("OME::ModuleExecution::ActualInput",
                         { module_execution => $past_analysis,
                           formal_input => $formal_input });
            my $input_module_execution =
              $actual_input->input_module_execution();
            my ($pred_node,$pred_analysis);
            my $input_link = $node_inputs{$curr_nodeID}->{$formal_inputID};

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();

            my $semantic_type = $formal_input->semantic_type();
            my @attributes;

            if ($dependence{$curr_nodeID} eq 'D') {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID });
            } else {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID,
                                     image => $curr_imageID });
            }

            $past_paramString .= $_->id()." "
                foreach @attributes;
            $past_paramString .= ") ";
        }

        $past_paramString .= "f ";
        @formal_inputs = $factory->
          findObjects("OME::Module::FormalInput",
                      { module => $past_analysis->module(),
                        'semantic_type.granularity' => 'F' });

        foreach my $formal_input (@formal_inputs) {
            my $formal_inputID = $formal_input->id();
            $past_paramString .= $formal_inputID."(";

            my $actual_input = $factory->
              findObject("OME::ModuleExecution::ActualInput",
                         { module_execution => $past_analysis,
                           formal_input => $formal_input });
            my $input_module_execution =
              $actual_input->input_module_execution();
            my ($pred_node,$pred_analysis);
            my $input_link = $node_inputs{$curr_nodeID}->{$formal_inputID};

            if (!defined $input_link) {
                $pred_analysis =
                  $user_input_analyses{$curr_nodeID}->{$formal_inputID};
            } else {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            }

            my $pred_analysisID = $pred_analysis->id();

            my $semantic_type = $formal_input->semantic_type();
            my @attributes;

            if ($dependence{$curr_nodeID} eq 'D') {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID });
            } else {
                @attributes = sort { $a <=> $b }
                  $factory->
                    findAttributes($semantic_type,
                                   { module_execution => $pred_analysisID,
                                     'feature.image' => $curr_imageID });
            }

            $past_paramString .= $_->id()." "
                foreach @attributes;
            $past_paramString .= ") ";
        }

        return $past_paramString;
    }

    sub __createInputHash {
        my ($node) = @_;
        my $nodeID = $node->id();
        my %inputs;

        my $module = $node->module();

        foreach my $formal_input ($module->inputs()) {
            my $inputID = $formal_input->id();
            my $input_link = $node_inputs{$nodeID}->{$inputID};

            my ($pred_node,$pred_analysis);

            if (defined $input_link) {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            } else {
                $pred_analysis =
                  $user_input_analyses{$nodeID}->{$inputID};
            }

            $inputs{$inputID} = $pred_analysis;
        }

        return \%inputs;
    }

    sub __createActualInputs {
        my ($node) = @_;
        my $nodeID = $node->id();
        my $module_execution = __getAnalysis($nodeID);

        #__debug("**** actual inputs");
        my $module = $module_execution->module();

        foreach my $formal_input ($module->inputs()) {
            my $inputID = $formal_input->id();
            my $input_link = $node_inputs{$nodeID}->{$inputID};

            #__debug("****   ".$formal_input->name());

            my ($pred_node,$pred_analysis);

            if (defined $input_link) {
                $pred_node = $input_link->from_node();
                $pred_analysis = __getAnalysis($pred_node->id());
            } else {
                $pred_analysis =
                  $user_input_analyses{$nodeID}->{$inputID};
            }

            #__debug("****   ".$pred_node->id());

            #__debug("****     $actual_outputID");

            my $actual_input = $factory->
              newObject("OME::ModuleExecution::ActualInput",
                        {
                         module_execution          => $module_execution->id(),
                         formal_input_id           => $inputID,
                         input_module_execution_id => $pred_analysis->id()
                        });

            #__debug("****     ".$actual_input->id());
        }
    }

    sub __addAnalysisToPaths {
        my ($module_execution) = @_;
        foreach my $db_data_path_entry (@{$data_paths{$curr_nodeID}}) {
            my $node_execution = $factory->
              newObject("OME::AnalysisChainExecution::NodeExecution",
                        {
                         analysis_chain_execution => $analysis_chain_execution,
                         analysis_chain_node      => $curr_nodeID,
                         module_execution         => $module_execution,
                        });
        }
    }

    # Updates the hash of module_execution entries.  Takes into account the
    # dataset-dependency of the current module.
    sub __assignAnalysis {
        my ($module_execution,$reused) = @_;

        if ($dependence{$curr_nodeID} eq 'G') {
            $global_analysis{$curr_nodeID} = $module_execution;
        } elsif ($dependence{$curr_nodeID} eq 'D') {
            $perdataset_analysis{$curr_nodeID} = $module_execution;
        } else {
            $perimage_analysis{$curr_nodeID}->{$curr_imageID} = $module_execution;
        }
        #$module_execution{$curr_nodeID} = $module_execution unless $reused;
    }

    # This routine performs the check that determines whether results
    # can be reused, using the methods described above.
    sub __checkPastResults {
        # Allow the user to skip analysis reuse.  This should really
        # only be used for testing.
        return 0 if (!$self->Flag('ReuseResults')
                     && $curr_node->module()->name() ne "Importer");

        my $paramString = __calculateCurrentInputTag();
        my $space = ($dependence{$curr_nodeID} eq 'I')? '  ': '';
        __debug("$space  Param $paramString");

        my $match = 0;
        my $matched_analysis;
        my @past_analyses = $factory->
          findObjects("OME::ModuleExecution",
                      {
                       module_id => $curr_node->module()->id(),
                       status => 'FINISHED',
                       dependence => $dependence{$curr_nodeID},
                      });
        my $this_analysis = __getAnalysis($curr_nodeID);
        my $this_analysisID;
        $this_analysisID = $this_analysis->id() if (defined $this_analysis);

      FIND_MATCH:
        foreach my $past_analysis (@past_analyses) {
            __debug("$space    Checking module execution ".$past_analysis->id()."...");
            if (defined $this_analysisID &&
                $past_analysis->id() eq $this_analysisID) {
                __debug("$space      current module execution.");
                next FIND_MATCH;
            }
            my $image_map = $factory->
                findObject("OME::Image::DatasetMap",
                           image_id   => $curr_imageID,
                           dataset_id => $past_analysis->dataset()->id());
            if (!defined $image_map) {
                __debug("$space      didn't execute against this image.");
                next FIND_MATCH;
            }

            my $past_paramString = __calculatePastInputTag($past_analysis);
            __debug("$space    Found $past_paramString ");

            if ($past_paramString eq $paramString) {
                $match = 1;
                $matched_analysis = $past_analysis;
                __debug("$space      match!");
                last FIND_MATCH;
            }

            __debug("$space      mismatch.");
        }

        if ($match) {
            __debug("$space    Found reusable module_execution ".$matched_analysis->id());
            __addAnalysisToPaths($matched_analysis);
            __assignAnalysis($matched_analysis,1);
        }

        return $match;
    }

    # The main body of the analysis engine.  Its purpose is to execute
    # a prebuilt analysis chain against a dataset, reusing results if
    # possible.
    sub executeAnalysisView {
        ($self, $session, $analysis_chain, $input_parameters, $dataset) = @_;

        __clearEverything();
        $session->commitTransaction();
        $factory = $session->Factory();

        $start_time = new Benchmark;

        # all nodes
        @nodes = $analysis_chain->nodes();

        __debug("Setup");

        __debug("  Validating chain");
        __checkInputs();

        __debug("  Locking the dataset");
        $dataset->locked('true');
        $dataset->storeObject();

        my $executor;
        if ($ENV{OME_THREADED}) {
            $executor = OME::Analysis::Engine::ForkedPerlExecutor->new();
        } else {
            $executor = OME::Analysis::Engine::UnthreadedPerlExecutor->new();
        }

        # Build the data paths.  Since data paths are now associated
        # with analysis chains, we only need to calculate them once.
        # Since the view is only locked when it is executed, we assume
        # that an unlocked view has not had paths calculated, whereas
        # a locked one has.
        if (!$analysis_chain->locked()) {
            __debug("  Chain has not been locked yet");

            __buildDataPaths();

            __debug("  Locking the chain");
            $analysis_chain->locked('true');
            $analysis_chain->storeObject();
        } else {
            __debug("  Chain has already been locked");

            __loadDataPaths();
        }

        __debug("  Creating ANALYSIS_CHAIN_EXECUTION table entry");

        $analysis_chain_execution = $factory->
          newObject("OME::AnalysisChainExecution",
                    {
                     analysis_chain => $analysis_chain,
                     dataset       => $dataset,
                     experimenter_id  => $session->User()->id()
                    });

        # initialize all of the nodes
        foreach my $node (@nodes) {
            $curr_node = $node;
            $curr_nodeID = $curr_node->id();
            __initializeNode();
        }

        $continue = 1;
        $round = 0;

        my $sth;

        $session->commitTransaction();

        while ($continue) {
            $continue = 0;
            $round++;
            __debug("Round $round...");

            # Look for input_nodes that are ready to run (i.e., whose
            # predecessor nodes have been completed).
          ANALYSIS_LOOP:
            foreach my $node (@nodes) {
                $curr_node = $node;
                $curr_nodeID = $curr_node->id();

                # Go ahead and skip if we've completed this module.
                if ($node_states{$curr_nodeID} > INPUT_STATE) {
                    __debug("  ".$curr_node->module()->
                            name()." already completed");
                    next ANALYSIS_LOOP;
                }

                {
                    my @links = $curr_node->input_links();
                    my %preds;
                    $preds{$_->from_node()->id()} = undef
                      foreach @links;
                    @curr_predecessorIDs = keys %preds;
                }

                if (!__testModulePredecessors()) {
                    __debug("  Skipping ".$curr_node->module()->
                            name());
                    next ANALYSIS_LOOP;
                } else {
                    __debug("  Executing ".$curr_node->module()->name());
                }

                my $debug = 1;

                @curr_global_inputs = $factory->
                  findObjects("OME::Module::FormalInput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'G' });

                @curr_dataset_inputs = $factory->
                  findObjects("OME::Module::FormalInput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'D' });

                @curr_image_inputs = $factory->
                  findObjects("OME::Module::FormalInput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'I' });

                @curr_feature_inputs = $factory->
                  findObjects("OME::Module::FormalInput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'F' });

                @curr_global_outputs = $factory->
                  findObjects("OME::Module::FormalOutput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'G' });

                @curr_dataset_outputs = $factory->
                  findObjects("OME::Module::FormalOutput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'D' });

                @curr_image_outputs = $factory->
                  findObjects("OME::Module::FormalOutput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'I' });

                @curr_feature_outputs = $factory->
                  findObjects("OME::Module::FormalOutput",
                              { module => $curr_node->module(),
                                'semantic_type.granularity' => 'F' });

                $last_node = $curr_node;

                __determineDependence();
                my $dependence = $dependence{$curr_nodeID};
                my $new_analysis;

                __debug("    Dependence: ".$dependence{$curr_nodeID});

                if ($dependence eq 'G') {
                    if (__checkPastResults()) {
                        __debug("    Marking state");
                        $node_states{$curr_nodeID} = FINISHED_STATE;
                        $continue = 1;
                        next ANALYSIS_LOOP;
                    }

                    __debug("    Start ".$curr_node->module()->
                            name()." (".$dependence{$curr_nodeID}.")");

                    __cloneUserInputs();

                    # Execute away.
                    __debug("    Creating MODULE_EXECUTION entry");
                    my $inputs = __createInputHash($curr_node);
                    $new_analysis = $executor->
                      executeModule($session,$analysis_chain_execution,
                                    $curr_node->module(),$curr_node,
                                    'G',undef,$inputs);
                    __assignAnalysis($new_analysis,0);
                    __addAnalysisToPaths($new_analysis);
                    #__debug(" (".$new_analysis->id().")");
                    __createActualInputs($curr_node);
                    #my $actual_outputs = __createActualOutputs($new_analysis);
                } elsif ($dependence eq 'D') {
                    if (__checkPastResults()) {
                        __debug("    Marking state");
                        $node_states{$curr_nodeID} = FINISHED_STATE;
                        $continue = 1;
                        next ANALYSIS_LOOP;
                    }

                    __debug("      Start ".$curr_node->module()->
                            name()." (".$dependence{$curr_nodeID}.")");

                    __cloneUserInputs();

                    # Execute away.
                    __debug("    Creating MODULE_EXECUTION entry");
                    my $inputs = __createInputHash($curr_node);
                    $new_analysis = $executor->
                      executeModule($session,$analysis_chain_execution,
                                    $curr_node->module(),$curr_node,
                                    'D',$dataset,$inputs);
                    __assignAnalysis($new_analysis,0);
                    __addAnalysisToPaths($new_analysis);
                    #__debug(" (".$new_analysis->id().")");
                    __createActualInputs($curr_node);
                    #my $actual_outputs = __createActualOutputs($new_analysis);
                } elsif ($dependence eq 'I') {
                    my @image_ids;

                    my $image_maps = $dataset->image_links();
                  IMAGE_LOOP:
                    while (my $image_map = $image_maps->next()) {
                                # Collect and present the image inputs
                        $curr_image = $image_map->image();
                        $curr_imageID = $curr_image->id();

                        __debug("    Image ".$curr_image->name());

                        if (__checkPastResults()) {
                            next IMAGE_LOOP;
                        } else {
                            __debug("      Adding to execution list");
                            push @image_ids, $curr_imageID;
                        }
                    }

                    if (scalar(@image_ids) > 0) {
                        __debug("    Start ".$curr_node->module()->
                                name()." (".$dependence{$curr_nodeID}.")");

                        __cloneUserInputs();

                                # Execute away.
                        __debug("    Creating MODULE_EXECUTION entry");
                        my $inputs = __createInputHash($curr_node);
                        $new_analysis = $executor->
                          executeModule($session,$analysis_chain_execution,
                                        $curr_node->module(),$curr_node,
                                        'I',\@image_ids,$inputs);
                        __assignAnalysis($new_analysis,0);
                        __addAnalysisToPaths($new_analysis);
                                #__debug(" (".$new_analysis->id().")");
                        __createActualInputs($curr_node);
                                #my $actual_outputs = __createActualOutputs($new_analysis);
                    } else {
                        __debug("    Skipping");
                        $node_states{$curr_nodeID} = FINISHED_STATE;
                        $continue = 1;
                        next ANALYSIS_LOOP;
                    }
                }

                # Mark this node as finished, and flag that we need
                # another fixed point iteration.

                __debug("    Committing transaction");
                $session->commitTransaction();

                __debug("    Marking FSM state");
                $node_states{$curr_nodeID} = FINISHED_STATE;
                $continue = 1;
            }                   # ANALYSIS_LOOP - foreach $curr_node

            $executor->waitForAnyModules();

            if (!$continue) {
                # No modules were executed this round, but if we're
                # using a multi-threaded Executor, there might be
                # modules that are still executing.  If so, we should
                # keep looping until all of the modules are done,
                # since their completing might make further nodes
                # eligible for execution.

                $continue = $executor->modulesExecuting();
            }
        }                       # while ($continue)

        $session->commitTransaction();

        $executor->waitForAllModules();

        $end_time = new Benchmark;

        my $total_time = timediff($end_time,$start_time);

        __debug("Timing - Total: ".timestr($total_time),'Timing');
        
        return $analysis_chain_execution;

    }
}

1;

__END__

=head1 AUTHOR

Douglas Creager <dcreager@alum.mit.edu>,
Open Microscopy Environment, MIT

=head1 SEE ALSO

L<OME>, http://www.openmicroscopy.org/

=cut

