# OME/Tasks/AnalysisEngine.pm

# Copyright (C) 2002 Open Microscopy Environment, MIT
# Author:  Douglas Creager <dcreager@alum.mit.edu>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.
#
#    You should have received a copy of the GNU Lesser General Public
#    License along with this library; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


package OME::Tasks::AnalysisEngine;

use strict;
our $VERSION = '1.0';

use OME::Factory;
use OME::DBObject;
use OME::Dataset;
use OME::Image;
use OME::Program;
use OME::Analysis;
use OME::AnalysisView;


# For now assume the module type is the Perl class of the
# module handler.

sub findModuleHandler {
    return shift;
}

sub executeAnalysisView {
    my ($session, $view, $input_parameters, $dataset) = @_;
    my $factory = $session->Factory();

    # all nodes
    my @nodes = $view->nodes();

    # the program objects for each node
    my %node_programs;

    # current state of each node
    use constant INPUT_STATE    => 1;
    use constant FINISHED_STATE => 2;
    my %node_states;

    # the outputs generated by each node
    # $dataset_outputs{$node}->{$formal_output} = $attribute 
    # $image_outputs{$node}->{$formal_output}->{$image} = $attribute
    # $feature_outputs{$node}->{$formal_output}->{$feature} = $attribute
    my (%dataset_outputs,%image_outputs,%feature_outputs);

    my %input_links;
    my %output_links;
    my %analyses;

    print STDERR "Setup\n";
    
    # initialize all of the nodes
    foreach my $node (@nodes) {
	my $nodeID = $node->id();
	my $program = $node->program();
	my $module_type = $program->module_type();
	my $location = $program->location();

	print STDERR "  ".$program->program_name()."\n";

	print STDERR "    Loading module $location via handler $module_type\n";
	my $handler = findModuleHandler($module_type);
	eval "require $handler";
	my $module = $handler->new($location,$factory);
	$node_programs{$nodeID} = $module;

	print STDERR "    Sorting input links by granularity\n";

	$input_links{$nodeID}->{D} = [];
	$input_links{$nodeID}->{I} = [];
	$input_links{$nodeID}->{F} = [];

	# this pushes only linked inputs
	my @inputs = $node->input_links();
	foreach my $input (@inputs) {
	    my $attribute_type = $input->to_input()->
		column_type()->
		datatype()->
		attribute_type();
	    push @{$input_links{$nodeID}->{$attribute_type}}, $input;
	    print "      $attribute_type ".$input->to_input()->name()."\n";
	}

	# where this pushes them all
	#my @inputs = $program->inputs();
	#foreach my $input (@inputs) {
	#    my $attribute_type = $input->
	#	column_type()->
	#	datatype()->
	#	attribute_type();
	#    push @{$input_links{$nodeID}->{$attribute_type}}, $input;
	#}

	print STDERR "    Sorting outputs by granularity\n";

	# ditto above
	#my @outputs = $node->output_links();
	#foreach my $output (@outputs) {
	#    my $attribute_type = $output->from_output()->
	#	column_type()->
	#	datatype()->
	#	attribute_type();
	#    push @{$output_links{$nodeID}->{$attribute_type}}, $output;
	#}

	my @outputs = $program->outputs();
	foreach my $output (@outputs) {
	    my $attribute_type = $output->
		column_type()->
		datatype()->
		attribute_type();
	    push @{$output_links{$nodeID}->{$attribute_type}}, $output;
	    print "      $attribute_type ".$output->name()."\n";
	}

	$node_states{$nodeID} = INPUT_STATE;

	print STDERR "    Creating ANALYSIS table entry\n";

	my $analysis_data = {
	    program      => $program,
	    dataset      => $dataset,
	    experimenter => $session->User()
	    #timestamp    => 'now',
	    #status       => 'STARTED'
	};
	my $analysis = $factory->newObject("OME::Analysis",$analysis_data);
	$analyses{$nodeID} = $analysis;
    }

    my $continue = 1;
    my $round = 0;

    # Define some helper procedures
    my $create_actual_input = sub {
	my ($node,$input,$attribute) = @_;
	my $nodeID = $node->id();
	
	my $formal_input = $input->to_input();

	my $actual_input_data = {
	    analysis     => $analyses{$nodeID},
	    formal_input => $formal_input,
	    attribute_id => $attribute->id()
	    };
	my $actual_input = $factory->newObject("OME::Analysis::ActualInput",
					       $actual_input_data);
    };
    
    my $create_actual_output = sub {
	my ($node,$output,$attributes) = @_;
	my $nodeID = $node->id();
	
	my $formal_output = $output;#->from_output();
	#print STDERR "      @@@@ ".$formal_output->name()."\n";
	my $attribute = $attributes->{$formal_output->name()};
	#print STDERR "      @@@@ ".$attribute."\n";
	
	my $actual_output_data = {
	    analysis      => $analyses{$nodeID},
	    formal_output => $formal_output,
	    attribute_id  => $attribute->id()
	    };
	my $actual_output = $factory->newObject("OME::Analysis::ActualOutput",
						$actual_output_data);
	#print STDERR "        Actual output created ".$actual_output->id()."\n";
    };

    my $last_node;

    while ($continue) {
	$continue = 0;
	$round++;
	print STDERR "Round $round...\n";

	# Look for input_nodes that are ready to run (i.e., whose
	# predecessor nodes have been completed).
	foreach my $node (@nodes) {
	    my $nodeID = $node->id();

	    next if $node_states{$nodeID} > INPUT_STATE;

	    my $ready = 1;

	    # If any of the predecessors has not finished, then this
	    # node is not ready to run.
	  TEST_PRED:
	    foreach my $granularity ('D','I','F') {
		my $inputs = $input_links{$nodeID}->{$granularity};
		foreach my $input (@$inputs) {
		    my $pred_node = $input->from_node();
		    if ($node_states{$pred_node->id()} < FINISHED_STATE)
		    {
			$ready = 0;
			last TEST_PRED;
		    }
		}
	    }
	    
	    unless ($ready) {
		print STDERR "  Skipping ".$node->program()->program_name()."\n";
		next;
	    }

	    print STDERR "  Executing ".$node->program()->program_name()."\n";
	    $last_node = $node;

	    # Execute away.
	    my $module = $node_programs{$nodeID};
	    my $inputs = $input_links{$nodeID};
	    my $outputs = $output_links{$nodeID};

	    print STDERR "    startDataset\n";
	    $module->startDataset($dataset);

	    # Collect and present the dataset inputs
	    my $dataset_inputs = $inputs->{D};
	    my %dataset_hash;
	    foreach my $input (@$dataset_inputs) {
		my $formal_input = $input->to_input();
		my $formal_output = $input->from_output();
		my $pred_node = $input->from_node();
		my $attribute = $dataset_outputs{$pred_node->id()}->{$formal_output->id()};
		print STDERR "      Actual input ".$formal_input->name()."\n";
		&$create_actual_input($node,$input,$attribute);

		$dataset_hash{$formal_input->name()} = $attribute;
	    }
	    $module->datasetInputs(\%dataset_hash);

	    print STDERR "    Precalculate dataset\n";
	    $module->precalculateDataset();

	    my $image_maps = $dataset->image_links();
	    while (my $image_map = $image_maps->next()) {
		# Collect and present the image inputs
		my $image = $image_map->image();

		print STDERR "    startImage ".$image->name()."\n";
		$module->startImage($image);

		my $image_inputs = $inputs->{I};
		my %image_hash;

		foreach my $input (@$image_inputs) {
		    my $formal_input = $input->to_input();
		    my $formal_output = $input->from_output();
		    my $pred_node = $input->from_node();
		    my $attribute = $image_outputs{$pred_node->id()}->{$formal_output->id()}->{$image->id()};
		    print STDERR "      Actual input ".$formal_input->name()."\n";
		    &$create_actual_input($node,$input,$attribute);
		    
		    $image_hash{$formal_input->name()} = $attribute;
		}

		$module->imageInputs(\%image_hash);

		print STDERR "    Precalculate image\n";
		$module->precalculateImage();

		my $features = $image->features();
		while (my $feature = $features->next()) {
		    # Collect and present the feature inputs.

		    print STDERR "    startFeature ".$feature->id()."\n";
		    $module->startFeature($feature);

		    my $feature_inputs = $inputs->{F};
		    my %feature_hash;

		    foreach my $input (@$feature_inputs) {
			my $formal_input = $input->to_input();
			my $formal_output = $input->from_output();
			my $pred_node = $input->from_node();
			my $attribute = $feature_outputs{$pred_node->id()}->{$formal_output->id()}->{$feature->id()};
			print STDERR "      Actual input ".$formal_input->name()."\n";
			&$create_actual_input($node,$input,$attribute);

			$feature_hash{$formal_input->name()} = $attribute;
		    }

		    $module->featureInputs(\%feature_hash);

		    print STDERR "    Calculate feature\n";
		    $module->calculateFeature();

		    # Collect and process the feature outputs

		    my $feature_attributes = $module->collectFeatureOutputs();
		    my $feature_outputs = $outputs->{F};

		    print STDERR "    Feature outputs\n";
		    foreach my $output (@$feature_outputs) {
			&$create_actual_output($node,$output,$feature_attributes);
			my $formal_output = $output;#->from_output();
			print STDERR "      Actual output ".$formal_output->name()."\n";
			$feature_outputs{$nodeID}->{$formal_output->id()}->{$feature->id()} = $feature_attributes->{$formal_output->name()};
		    }

		    $module->finishFeature($feature);
		} # foreach $feature

		# Collect and process the image outputs
		print STDERR "    Postcalculate image\n";
		$module->postcalculateImage();

		my $image_attributes = $module->collectImageOutputs();
		my $image_outputs = $outputs->{I};
		
		print STDERR "    Image outputs\n";
		foreach my $output (@$image_outputs) {
		    &$create_actual_output($node,$output,$image_attributes);
		    my $formal_output = $output;#->from_output();
		    print STDERR "      Actual output ".$formal_output->name()."\n";
		    $image_outputs{$nodeID}->{$formal_output->id()}->{$image->id()} = $image_attributes->{$formal_output->name()};
		}

		$module->finishImage($image);
	    } # foreach $image

	    # Collect and process the dataset outputs
	    print STDERR "    Postcalculate dataset\n";
	    $module->postcalculateDataset();

	    my $dataset_attributes = $module->collectDatasetOutputs();
	    my $dataset_outputs = $outputs->{D};
	    
	    print STDERR "    Dataset outputs\n";
	    foreach my $output (@$dataset_outputs) {
		&$create_actual_output($node,$output,$dataset_attributes);
		my $formal_output = $output->from_output();
		print STDERR "      Actual output ".$formal_output->name()."\n";
		$dataset_outputs{$nodeID}->{$formal_output->id()} = $dataset_attributes->{$formal_output->name()};
	    }
	    
	    $module->finishDataset($dataset);

	    # Mark this node as finished, and flag that we need
	    # another fixed point iteration.
	    
	    print STDERR "    Marking state\n";
	    $node_states{$nodeID} = FINISHED_STATE;
	    $continue = 1;
	} # foreach $node
    } # while ($continue)

    $last_node->dbi_commit();
}

__END__

=head1 NAME

  OME::Tasks::AnalysisEngine - OME analysis subsystem

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 AUTHOR

Douglas Creager <dcreager@alum.mit.edu>

Open Microscopy Environment, MIT 

=head1 SEE ALSO

L<OME>, http://www.openmicroscopy.org/

=cut
