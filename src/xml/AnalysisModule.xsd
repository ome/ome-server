<?xml version = "1.0" encoding = "UTF-8"?>
<!--Generated by Turbo XML 2.3.1.100. Conforms to w3c http://www.w3.org/2001/XMLSchema-->
<xsd:schema xmlns:xsd = "http://www.w3.org/2001/XMLSchema"
	 elementFormDefault = "qualified">
	<xsd:group name = "inputRecordModel">
		<xsd:choice>
			<xsd:element ref = "Input" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "XYPlaneFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "XYPlaneFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeT" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeW" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeX" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeY" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeZ" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "BPP" minOccurs = "0" maxOccurs = "unbounded"/>
		</xsd:choice>
	</xsd:group>
	<xsd:group name = "outputRecordModel">
		<xsd:choice>
			<xsd:element ref = "Output" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "XYPlaneFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "XYPlaneFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeT" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeW" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeX" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeY" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeZ" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "BPP" minOccurs = "0" maxOccurs = "unbounded"/>
		</xsd:choice>
	</xsd:group>
	<xsd:element name = "Declaration">
		<xsd:annotation>
			<xsd:documentation>States module requirements.
Formal Inputs are optional because input requirements may be specified by guaranteed image attributes. For example, OME_Image_XYZ_stats requires a path to the OME repository file, and Dimensions.
These are given by &lt;RawImageFilePath>, &lt;sizeX>, &lt;sizeY>, &lt;sizeZ>, &lt;sizeT>, and &lt;sizeW>.
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "FormalInput" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "FormalOutput" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalInput" abstract = "true">
		<xsd:annotation>
			<xsd:documentation>Specifies an input requirement for a module. Image dimensions and image file locations (repository or other format) should not be specified with this. Image dimensions are intrisic to an image. They do not represent a special requirement. Image file locations and contents are specified by other elements. Specifically, RawImageFile, RawImageFilePath, XYPlaneFile, and XYPlaneFilePath.

			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Datatype"/>
				<xsd:element ref = "LookupTable" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "UserDefined" default = "F" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>OME interprets this as a recommendation rather than a requirement.

Tied to DB. Table FORMAL_INPUTS Column USER_DEFINED
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used for reference purposes in for Command Line programs. Accordingly, each FormalInput needs a unique ID. This is not enforced in the schema, so watch your back.</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Column_SQL" type = "Column_Type_SQL">
				<xsd:annotation>
					<xsd:documentation>Don't mess with this unless you know what you are doing.
If it is necessary to generate a table and/or column in the Database, it will be necessary to tell the database a datatype. This value should be in SQL format.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalOutput">
		<xsd:annotation>
			<xsd:documentation>Specifies an output element of a module.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Datatype"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "FormalOutputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used for reference purposes in Command Line programs. Accordingly, each FormalOutput needs to be unique. This is not enforced in the schema, so watch your back.

					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Column_SQL" type = "Column_Type_SQL">
				<xsd:annotation>
					<xsd:documentation>Don't mess with this unless you know what you are doing.
If it is necessary to generate a table and/or column in the Database, it will be necessary to tell the database a datatype. This value should be in SQL format.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Datatype">
		<xsd:annotation>
			<xsd:documentation>Defines a location in the database by either table or column &amp; table.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "AttributeType" use = "required">
				<xsd:annotation>
					<xsd:documentation>This may be D, I, or F. These represent Dataset, Image, and Feature, respectively. In deciding which of these to use, refer to the table and column to which this datatype maps.

Tied to DB. Table DATATYPES Column ATTRIBUTE_TYPE
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "D"/>
						<xsd:enumeration value = "I"/>
						<xsd:enumeration value = "F"/>
						<xsd:length value = "1"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "TableName" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPES Column TABLE_NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ColumnName">
				<xsd:annotation>
					<xsd:documentation>If specified, the datatype will map to a specific column in a table (i.e. a cell). If not specified, the datatype will map across all columns of a table (i.e. a row).

Tied to DB. Table DATATYPE_COLUMNS Column COLUMN_NAME
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ReferenceType">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table DATATYPE_COLUMNS Column REFERENCE_TYPE
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPES Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTable">
		<xsd:annotation>
			<xsd:documentation>Describes valid values for an input. Think enumerations, (a list of valid values).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "LookupTableEntries" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLES Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLES Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTableEntries">
		<xsd:complexType>
			<xsd:attribute name = "Value" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLE_ENTRIES Column VALUE</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Label">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLE_ENTRIES Column LABEL</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "AnalysisModuleLibrary">
		<xsd:annotation>
			<xsd:documentation>An analysis module is defined by two things: 
1) A program
2) An interface
A single program may have multiple interfaces. Why do you need multiple interfaces?
Pretend you have a program that calculates simple statistics on the pixels of an image. You can specify which statistics you want via parameters.

Typing
./stats -mean -sigma image1

will ouput
Image | mean | sigma
image1 12.4 1

Typing
./stats -geomean -mean image1

will output
Image | geomean | mean
image1 12.2 12.4

The outputs are completely different. You need to specify an interface for each of these behaviors. 
Or pretend you have a powerful program that can do 10 unrelated tasks, each of which outputs an image. While the outputs are the same type and format, they represent 10 completely different things. In this case, it might make sense to define 10 corrosponding AnalysisModule to represent the 10 logical functions.

In any case, use AnalysisModule to define an interface and Program to store installation software for a program.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "AnalysisModule" maxOccurs = "unbounded"/>
				<xsd:element ref = "Program" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "ExecutionInstructions">
		<xsd:annotation>
			<xsd:documentation>Specifies execution instructions. Perl packages do not need this element because they internally specify execution instructions by overriding functions from a base class. Command Line programs need to use this.
The schema does not check the need for this against ModuleType, so it may not report errors the installation logic will detect.

The location does not yet exist in the DB. The contents of this element (in XML format) will be stored in the DB.

Tied to DB. Table PROGRAMS Column EXECUTION
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:choice>
				<xsd:element ref = "CommandLine" minOccurs = "0"/>
				<xsd:element ref = "STDIN" minOccurs = "0"/>
				<xsd:element ref = "STDOUT" minOccurs = "0"/>
				<xsd:element ref = "InfileText" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "OutfileText" minOccurs = "0" maxOccurs = "unbounded"/>
			</xsd:choice>
			<xsd:attribute name = "ExecutionPoint" use = "required">
				<xsd:annotation>
					<xsd:documentation>Assigns a execution point for the analysis.
This needs to be mulled over again after Doug finalizes analysis engine &amp; use scenarios for modules dealing with datasets, images, &amp; features are constructed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "precalculateDataset"/>
						<xsd:enumeration value = "precalculateImage"/>
						<xsd:enumeration value = "calculateFeature"/>
						<xsd:enumeration value = "postcalculateImage"/>
						<xsd:enumeration value = "postcalculateDataset"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "CommandLine">
		<xsd:annotation>
			<xsd:documentation>This describes the string that will be passed to a command line program via command line parameters. The command line handler will perform basic variable substitution on sub elements of this.
Example:
when you use the program, you type: /OME/bin/OME_Image_XYZ_stats Path=[path to file] Dims=[X],[Y],[Z],[W],[T],[BytesPerPix]
XML specification of the command line parameters is:
&lt;CommandLine>
	Path=&lt;PlaneFilePath/> Dims=&lt;sizeX/>,&lt;sizeY/>,&lt;sizeZ/>,&lt;sizeW/>,&lt;sizeT/>,&lt;BPP/>
&lt;/CommandLine>

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "inputRecordModel"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "STDIN">
		<xsd:annotation>
			<xsd:documentation>This specifies what and how to write content the analysis module will read from STDIN.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "STDOUT">
		<xsd:annotation>
			<xsd:documentation>This specifies what and how to read content the analysis module prints to STDOUT.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "OutputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "InfileText">
		<xsd:annotation>
			<xsd:documentation>If the analysis module reads input from a file, this is the place to describe the format of the file so it can automatically be generated.
There is not currently a use scenario for this, so it is not supported. If you have a module that needs to read input from a text file, contact OME developers.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "InfileID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "OutfileText">
		<xsd:annotation>
			<xsd:documentation>If the analysis module reads output from a file, this is the place to describe the format of the file so it can automatically read into the DB.
There is not currently a use scenario for this, so it is not supported. If you have a module that needs to read input from a text file, contact OME developers.

			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "OutputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "OutfileID" use = "required" type = "xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Input">
		<xsd:annotation>
			<xsd:documentation>References FormalInput. Used for variable substitution.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Output">
		<xsd:annotation>
			<xsd:documentation>References FormalOutput. Used for variable substitution.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "FormalOutputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalOutput Element. It should corrospond to a FormalOutputID specified in a FormalOutput Element.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "AnalysisModule">
		<xsd:annotation>
			<xsd:documentation>Describes an interface to use with a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Declaration"/>
				<xsd:element ref = "ExecutionInstructions" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "ModuleName" use = "required">
				<xsd:annotation>
					<xsd:documentation>PROGRAM_NAME in the database is a misnomer. It really should be changed to NAME.

Tied to DB. Table PROGRAMS Column PROGRAM_NAME
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Category">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table PROGRAMS Column CATEGORY

					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "32"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "VisualDesign" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table PROGRAMS Column VISUAL_DESIGN
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table PROGRAMS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "isStreamAlgorithm" default = "F" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>This is a stub for future development. The database location doesn't even exist yet.

If the output of the analysis will be the same when pixel positions are scrambled, the analysis is a stream algorithm. 
Examples of stream algorithms are:
	A statistics module that produces mean, geometric mean, standard deviation, etc. for pixel intensities.
	A module to cross correlate pixel intensities across wavelengths.
Example of an algorithms that is not a stream algorithm is:
	FindSpots. (It's a module to find blobs in an image.)

If a module is a stream algorithm, it can function across the x, y, z, and time dimensions.

Tied to DB. Table PROGRAMS Column IS_STREAM_ALGORITHM
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "ModuleType" use = "required">
				<xsd:annotation>
					<xsd:documentation>As more handlers, are added, this part of the schema needs to be changed

Tied to DB. Table PROGRAMS Column MODULE_TYPE
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "OME::Analysis::PerlHandler"/>
						<xsd:enumeration value = "OME::Analysis::CLIHandler"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ProgramID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a Program Element. It should corrospond to a ProgramID specified in a Program Element.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Program">
		<xsd:annotation>
			<xsd:documentation>Stores an installation package and installation script for a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InstallationScript"/>
				<xsd:element ref = "InstallationFile"/>
			</xsd:sequence>
			<xsd:attribute name = "ProgramID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Referenced by AnalysisModule elements. Accordingly, each FormalOutput needs to be unique. This is not enforced in the schema, so watch your back.

					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Name">
				<xsd:annotation>
					<xsd:documentation>Program name. Does not have to be the name of the program's file.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Version" type = "xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinaryFile">
		<xsd:annotation>
			<xsd:documentation>Describes a binary file.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "External"/>
				<xsd:element ref = "BinData"/>
			</xsd:sequence>
			<xsd:attribute name = "FileName">
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "External">
		<xsd:annotation>
			<xsd:documentation>Describes a file location.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "href" use = "required" type = "xsd:anyURI">
				<xsd:annotation>
					<xsd:documentation>file location</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Offset" type = "xsd:integer"/>
			<xsd:attribute name = "SHA1" use = "required" type = "Hex40"/>
			<xsd:attribute name = "Compression">
				<xsd:annotation>
					<xsd:documentation>Only necessary if file is compressed.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "gzip"/>
						<xsd:enumeration value = "bzip2"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinData" type = "xsd:base64Binary"/>
	<xsd:simpleType name = "Hex40">
		<xsd:restriction base = "xsd:hexBinary">
			<xsd:length value = "20"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name = "Column_Type_SQL">
		<xsd:annotation>
			<xsd:documentation>Don't mess with this unless you know what you are doing.

ex.
VARCHAR(256) NOT NULL
or
TEXT

			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base = "xsd:string"/>
	</xsd:simpleType>
	<xsd:element name = "theZ">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "theW">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "theT">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "XYPlaneFilePath">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with a dynamically generated plane. Currently that means a TIFF.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "theZ"/>
				<xsd:element ref = "theT"/>
				<xsd:element ref = "theW"/>
			</xsd:sequence>
			<xsd:attribute name = "BPP">
				<xsd:annotation>
					<xsd:documentation>Specifies bits per pixel (BPP) the module is expecting. If the program can deal with both 8 and 16 bit images, leave this out and the BPP of the image will be used. That is, if the image is 8 bits, the module will get an 8 bits per pixel. If the image is 16 bits, the module will get 16 bits per pixel.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:integer">
						<xsd:enumeration value = "8"/>
						<xsd:enumeration value = "16"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Format">
				<xsd:annotation>
					<xsd:documentation>Specifies the expected format of the plane.
RAW corrosponds to OME repository format of pixel dump.
TIFF corrosponds to TIFF files.
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "RAW"/>
						<xsd:enumeration value = "TIFF"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "XYPlaneFile">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with pixel contents of the plane. If the plane is of format TIFF, this will return the contents of the TIFF file. If this plane is of type RAW, this will return a pixel dump.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "theZ"/>
				<xsd:element ref = "theT"/>
				<xsd:element ref = "theW"/>
			</xsd:sequence>
			<xsd:attribute name = "BPP">
				<xsd:annotation>
					<xsd:documentation>Specifies bits per pixel (BPP) the module is expecting. If the program can deal with both 8 and 16 bit images, leave this out and the BPP of the image will be used. That is, if the image is 8 bits, the module will get an 8 bits per pixel. If the image is 16 bits, the module will get 16 bits per pixel.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:integer">
						<xsd:enumeration value = "8"/>
						<xsd:enumeration value = "16"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Format">
				<xsd:annotation>
					<xsd:documentation>Specifies the expected format of the plane.
RAW corrosponds to OME repository format of pixel dump.
TIFF corrosponds to TIFF files.
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "RAW"/>
						<xsd:enumeration value = "TIFF"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "sizeX">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the X dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeY">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the Y dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeZ">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the Z dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeT">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the T dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeW">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the W dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "RawImageFilePath">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with the path and file of the raw pixel dump image file.
e.g. /OME/repository/1-tinyTest.ori
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "RawImageFile">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with the binary contents of the raw pixel dump image file.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "InputRecord">
		<xsd:annotation>
			<xsd:documentation>Groups a set of inputs into records.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "inputRecordModel"/>
			</xsd:sequence>
			<xsd:attribute name = "RepeatCount" type = "xsd:positiveInteger">
				<xsd:annotation>
					<xsd:documentation>RepeatCount specifies how many times to write a record. If it is not specified, writing will continue until it runs out of things to write.

					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "OutputRecord">
		<xsd:annotation>
			<xsd:documentation>Groups a set of outputs into records.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "outputRecordModel"/>
			</xsd:sequence>
			<xsd:attribute name = "RepeatCount" type = "xsd:positiveInteger">
				<xsd:annotation>
					<xsd:documentation>RepeatCount specifies how many times to read a record. If it is not specified, reading will continue until it reaches the end of the output stream.
If used in conjuction with TerminateAt, reading will stop after RepeatCount or TerminateAt, whichever comes first.
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "TerminateAt" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>TerminateAt specifies a regular expression. When a match to this is found, reading will stop.
If used in conjuction with RepeatCount, reading will stop after RepeatCount or TerminateAt, whichever comes first.
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BPP">
		<xsd:annotation>
			<xsd:documentation>Used for variable substitution. This is substituted for bytes per pixel. </xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "InstallationScript">
		<xsd:annotation>
			<xsd:documentation>The script should interface with the OME API to find all information it needs. (i.e. installation path) It also needs to set the location of the program after the program is installed. The location should be set through the API, but it will propogate to the LOCATION column of the PROGRAMS table.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "BinaryFile"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "InstallationFile">
		<xsd:annotation>
			<xsd:documentation>Contains a packaged or zipped installation files (binaries or source code).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "BinaryFile"/>
			</xsd:sequence>
			<xsd:attribute name = "Format" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>This is a stub for future development. Don't bother with it unless you know more about it.

Specifies the packaging and/or compression format of the Installation file.
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
</xsd:schema>