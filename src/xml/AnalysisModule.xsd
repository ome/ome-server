<?xml version = "1.0" encoding = "UTF-8"?>
<!--Generated by Turbo XML 2.3.1.100. Conforms to w3c http://www.w3.org/2001/XMLSchema-->
<xsd:schema xmlns:xsd = "http://www.w3.org/2001/XMLSchema"
	 elementFormDefault = "qualified">
	<xsd:group name = "inputRecordModel">
		<xsd:choice>
			<xsd:element ref = "Input" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "PlaneFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "PlaneFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeT" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeW" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeX" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeY" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeZ" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "BPP" minOccurs = "0" maxOccurs = "unbounded"/>
		</xsd:choice>
	</xsd:group>
	<xsd:group name = "outputRecordModel">
		<xsd:choice>
			<xsd:element ref = "Output" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "PlaneFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "PlaneFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeT" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeW" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeX" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeY" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeZ" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "BPP" minOccurs = "0" maxOccurs = "unbounded"/>
		</xsd:choice>
	</xsd:group>
	<xsd:element name = "Declaration">
		<xsd:annotation>
			<xsd:documentation>States module requirements. This includes inputs, outputs, and 2D planes (i.e. TIFF images).
Formal Inputs are optional because input requirements may be specified by guaranteed image attributes. For example, OME_Image_XYZ_stats requires a path to the OME repository file, and Dimensions.
These are given by &lt;RawImageFilePath>, &lt;sizeX>, &lt;sizeY>, &lt;sizeZ>, &lt;sizeT>, and &lt;sizeW>.
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "FormalInput" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "FormalOutput" maxOccurs = "unbounded"/>
				<xsd:element ref = "XYPlane" minOccurs = "0" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalInput" abstract = "true">
		<xsd:annotation>
			<xsd:documentation>Specifies an input requirement for a module. Image dimensions and image file locations (repository or other format) should not be specified with this. Image dimensions are intrisic to an image. They do not represent a special requirement. Image file locations and contents are specified by other elements. Specifically, RawImageFile, RawImageFilePath, PlaneFile, and PlaneFilePath.

			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Datatype"/>
				<xsd:element ref = "LookupTable" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "UserDefined" default = "F" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>This offers recommendation only. It may be overridden in an execution plan. But it is noticed and referenced. Proper attention is paid to it. Don't leave it out.

Tied to DB. Table FORMAL_INPUTS Column USER_DEFINED
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used for reference purposes in for Command Line programs. Accordingly, each FormalInput needs a unique ID. This is not enforced in the schema, so watch your back.</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Column_SQL" type = "Column_Type_SQL">
				<xsd:annotation>
					<xsd:documentation>Don't mess with this unless you know what you are doing.
If it is necessary to generate a table and/or column in the Database, it will be necessary to tell the database a datatype. This value should be in SQL format.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalOutput">
		<xsd:annotation>
			<xsd:documentation>Specifies an output of a module.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Datatype"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "FormalOutputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used for reference purposes in Command Line programs. Accordingly, each FormalOutput needs to be unique. This is not enforced in the schema, so watch your back.

					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Column_SQL" type = "Column_Type_SQL">
				<xsd:annotation>
					<xsd:documentation>Don't mess with this unless you know what you are doing.
If it is necessary to generate a table and/or column in the Database, it will be necessary to tell the database a datatype. This value should be in SQL format.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Datatype">
		<xsd:annotation>
			<xsd:documentation>Defines a location in the database by either table or column &amp; table.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "AttributeType" use = "required">
				<xsd:annotation>
					<xsd:documentation>This may be D, I, or F. These represent Dataset, Image, and Feature, respectively. In deciding which of these to use, refer to the table and column to which this datatype maps.

Tied to DB. Table DATATYPES Column ATTRIBUTE_TYPE
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "D"/>
						<xsd:enumeration value = "I"/>
						<xsd:enumeration value = "F"/>
						<xsd:length value = "1"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "TableName" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPES Column TABLE_NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ColumnName">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPE_COLUMNS Column COLUMN_NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ReferenceType">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table DATATYPE_COLUMNS Column REFERENCE_TYPE
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPES Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTable">
		<xsd:annotation>
			<xsd:documentation>Describes valid values for an input. Think enumerations, (a list of valid values).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "LookupTableEntries" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLES Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLES Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTableEntries">
		<xsd:complexType>
			<xsd:attribute name = "Value" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLE_ENTRIES Column VALUE</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Label">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLE_ENTRIES Column LABEL</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "AnalysisModuleProgram">
		<xsd:annotation>
			<xsd:documentation>An analysis module is defined by two things: 
1) A program or script &lt;Program>
2) An interface &lt;Interface>
A single program may have multiple interfaces. Each interface describes one behavior of a program.
For example, the correlation program can optionally use an image mask. It would have two interfaces, one using the mask, the other not. Different input requirements would be specified for each.
To deal with this, module information (name, description, etc.) is specified in interface.
In technical terms, there is a one to one corrospondence between an Interface and an AnalysisModule. That is the only one to one corrospondence AnalysisModule has. So information goes there.
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Interface" maxOccurs = "unbounded"/>
				<xsd:element ref = "Program"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "ExecutionInstructions">
		<xsd:annotation>
			<xsd:documentation>Specifies execution instructions. Perl packages do not need this element because they internally specify execution instructions by overriding functions from a base class. Command Line programs need to use this.
The schema does not check the need for this against ModuleType, so it may not report errors the installation logic will detect.
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:choice>
				<xsd:element ref = "CommandLine" minOccurs = "0"/>
				<xsd:element ref = "STDIN" minOccurs = "0"/>
				<xsd:element ref = "STDOUT" minOccurs = "0"/>
				<xsd:element ref = "InfileText" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "OutfileText" minOccurs = "0" maxOccurs = "unbounded"/>
			</xsd:choice>
			<xsd:attribute name = "ExecutionPoint" use = "required">
				<xsd:annotation>
					<xsd:documentation>Assigns a execution point for the analysis.
This needs to be mulled over again after Doug finalizes analysis engine &amp; use scenarios for modules dealing with datasets, images, &amp; features are constructed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "precalculateDataset"/>
						<xsd:enumeration value = "precalculateImage"/>
						<xsd:enumeration value = "calculateFeature"/>
						<xsd:enumeration value = "postcalculateImage"/>
						<xsd:enumeration value = "postcalculateDataset"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "CommandLine">
		<xsd:annotation>
			<xsd:documentation>This describes the string that will be passed to a command line program via command line parameters. The command line handler will perform basic variable substitution on sub elements of this.
Example:
when you use the program, you type: /OME/bin/OME_Image_XYZ_stats Path=[path to file] Dims=[X],[Y],[Z],[W],[T],[BytesPerPix]
XML specification of the command line parameters is:
&lt;CommandLine>
	Path=&lt;PlaneFilePath/> Dims=&lt;sizeX/>,&lt;sizeY/>,&lt;sizeZ/>,&lt;sizeW/>,&lt;sizeT/>,&lt;BPP/>
&lt;/CommandLine>

There is not currently a location in the database set up to deal with this. 
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "inputRecordModel"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "STDIN">
		<xsd:annotation>
			<xsd:documentation>This specifies what and how to write content the analysis module will read from STDIN.

There is not currently a location in the database set up to deal with this. 
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "STDOUT">
		<xsd:annotation>
			<xsd:documentation>This specifies what and how to read content the analysis module prints to STDOUT.

There is not currently a location in the database set up to deal with this. 
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "OutputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "InfileText">
		<xsd:annotation>
			<xsd:documentation>If the analysis module reads input from a file, this is the place to describe the format of the file so it can automatically be generated.
There is not currently a use scenario for this, so it is not supported. If you have a module that needs to read input from a text file, contact OME developers.

There is not currently a location in the database set up to deal with this. 
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "InfileID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "OutfileText">
		<xsd:annotation>
			<xsd:documentation>If the analysis module reads output from a file, this is the place to describe the format of the file so it can automatically read into the DB.
There is not currently a use scenario for this, so it is not supported. If you have a module that needs to read input from a text file, contact OME developers.

There is not currently a location in the database set up to deal with this. 
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "OutputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "OutfileID" use = "required" type = "xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Input">
		<xsd:annotation>
			<xsd:documentation>References FormalInput. Used for variable substitution.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you screw up and make a typo here, the error won't be detected until your file is processed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Output">
		<xsd:annotation>
			<xsd:documentation>References FormalOutput. Used for variable substitution.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "FormalOutputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalOutput Element. It should corrospond to a FormalOutputID specified in a FormalOutput Element.
Referential integrity is not enforced by this schema. That is, if you screw up and make a typo here, the error won't be detected until your file is processed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Interface">
		<xsd:annotation>
			<xsd:documentation>Describes an interface to use with a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Declaration"/>
				<xsd:element ref = "ExecutionInstructions" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "ModuleName" use = "required">
				<xsd:annotation>
					<xsd:documentation>PROGRAM_NAME in the database is a misnomer. It really should be changed to MODULE_NAME or just NAME.

Tied to DB. Table PROGRAMS Column PROGRAM_NAME
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Category">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table PROGRAMS Column CATEGORY

					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "32"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "VisualDesign" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table PROGRAMS Column VISUAL_DESIGN
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table PROGRAMS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "isStreamAlgorithm" default = "F" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>If the output of the analysis will be the same when pixel positions are scrambled, the analysis is a stream algorithm. 
Examples of stream algorithms are:
	A statistics module that produces mean, geometric mean, standard deviation, etc. for pixel intensities.
	A module to cross correlate pixel intensities across wavelengths.
Example of an algorithms that is not a stream algorithm is:
	FindSpots. It's a module to find blobs in an image.

If a module is a stream algorithm, it can function across the x, y, z, and time dimensions.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Program">
		<xsd:annotation>
			<xsd:documentation>A program may be specified by either source code or executable file(s).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:choice>
				<xsd:element ref = "SourceCode"/>
				<xsd:element ref = "Executable"/>
			</xsd:choice>
			<xsd:attribute name = "ModuleType" use = "required">
				<xsd:annotation>
					<xsd:documentation>As more handlers, are added, this part of the schema needs to be changed

Tied to DB. Table PROGRAMS Column MODULE_TYPE
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "OME::Analysis::PerlHandler"/>
						<xsd:enumeration value = "OME::Analysis::CLIHandler"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "SourceCode">
		<xsd:annotation>
			<xsd:documentation>Source code requires a Makefile and source files. Source files should be stored in TextFiles. </xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "MakeFile"/>
				<xsd:element ref = "TextFile" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Executable">
		<xsd:annotation>
			<xsd:documentation>Contains binary files for a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "BinaryFile" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinaryFile">
		<xsd:annotation>
			<xsd:documentation>Describes a binary file.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "External"/>
				<xsd:element ref = "BinData"/>
			</xsd:sequence>
			<xsd:attribute name = "FileName">
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "MakeFile">
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "TextFile"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "External">
		<xsd:annotation>
			<xsd:documentation>Describes a file location.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "href" use = "required" type = "xsd:anyURI">
				<xsd:annotation>
					<xsd:documentation>file location</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Offset" type = "xsd:integer"/>
			<xsd:attribute name = "SHA1" use = "required" type = "Hex40"/>
			<xsd:attribute name = "Compression">
				<xsd:annotation>
					<xsd:documentation>Only necessary if file is compressed.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "gzip"/>
						<xsd:enumeration value = "bzip2"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinData" type = "xsd:base64Binary"/>
	<xsd:simpleType name = "Hex40">
		<xsd:restriction base = "xsd:hexBinary">
			<xsd:length value = "20"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:simpleType name = "Column_Type_SQL">
		<xsd:annotation>
			<xsd:documentation>Don't mess with this unless you know what you are doing.

ex.
VARCHAR(256) NOT NULL
or
TEXT

			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base = "xsd:string"/>
	</xsd:simpleType>
	<xsd:element name = "TextFile">
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "External"/>
				<xsd:element ref = "TextData"/>
			</xsd:sequence>
			<xsd:attribute name = "FileName" use = "required">
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "TextData" type = "xsd:string"/>
	<xsd:element name = "XYPlane">
		<xsd:annotation>
			<xsd:documentation>If the analysis operates on a plane (i.e. reads a TIFF file), specify the plane using this element.
An XY plane is defined by theZ, theT, and theW. Consequently, these needed to be specified as formal inputs.

			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "theZ"/>
				<xsd:element ref = "theT"/>
				<xsd:element ref = "theW"/>
			</xsd:sequence>
			<xsd:attribute name = "PlaneID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used for reference purposes in Command Line programs. Accordingly, each PlaneID needs to be unique. This is not enforced in the schema, so watch your back.</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Format">
				<xsd:annotation>
					<xsd:documentation>Specifies the expected format of the image plane.
RAW corrosponds to OME repository format of pixel dump.
TIFF corrosponds to TIFF files.
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "RAW"/>
						<xsd:enumeration value = "TIFF"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "BPP" default = "8">
				<xsd:annotation>
					<xsd:documentation>Specifies bits per pixel the module is expecting. Currently, most programs only work with 8 bit image. If you have a niftly new program that deals with 16 bit images, override this.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:integer">
						<xsd:enumeration value = "8"/>
						<xsd:enumeration value = "16"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "theZ">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you screw up and make a typo here, the error won't be detected until your file is processed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "theW">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you screw up and make a typo here, the error won't be detected until your file is processed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "theT">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalInput Element. It should corrospond to a FormalInputID specified in a FormalInput Element.
Referential integrity is not enforced by this schema. That is, if you screw up and make a typo here, the error won't be detected until your file is processed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "PlaneFilePath">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with a dynamically generated plane. Currently that means a TIFF.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "PlaneID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a Plane Element. It should corrospond to a PlaneID specified in a Plane Element.
Referential integrity is not enforced by this schema. That is, if you screw up and make a typo here, the error won't be detected until your file is processed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "PlaneFile">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with pixel contents of the plane. If the plane is of format TIFF, this will return the contents of the TIFF file. If this plane is of type RAW, this will return a pixel dump.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "PlaneID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a Plane Element. It should corrospond to a PlaneID specified in a Plane Element.
Referential integrity is not enforced by this schema. That is, if you screw up and make a typo here, the error won't be detected until your file is processed.
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "sizeX">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the X dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeY">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the Y dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeZ">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the Z dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeT">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the T dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeW">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the W dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "RawImageFilePath">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with the path and file of the raw pixel dump image file.
e.g. /OME/repository/1-tinyTest.ori
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "RawImageFile">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with the binary contents of the raw pixel dump image file.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "InputRecord">
		<xsd:annotation>
			<xsd:documentation>Groups a set of inputs into records.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "inputRecordModel"/>
			</xsd:sequence>
			<xsd:attribute name = "RepeatCount" type = "xsd:positiveInteger">
				<xsd:annotation>
					<xsd:documentation>RepeatCount specifies how many times to write a record. If it is not specified, writing will continue until it runs out of things to write.

					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "OutputRecord">
		<xsd:annotation>
			<xsd:documentation>Groups a set of outputs into records.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "outputRecordModel"/>
			</xsd:sequence>
			<xsd:attribute name = "RepeatCount" type = "xsd:positiveInteger">
				<xsd:annotation>
					<xsd:documentation>RepeatCount specifies how many times to read a record. If it is not specified, reading will continue until it reaches the end of the output stream.
If used in conjuction with TerminateAt, reading will stop after RepeatCount or TerminateAt, whichever comes first.
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "TerminateAt" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>TerminateAt specifies a regular expression. When a match to this is found, reading will stop.
If used in conjuction with RepeatCount, reading will stop after RepeatCount or TerminateAt, whichever comes first.
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BPP">
		<xsd:annotation>
			<xsd:documentation>Used for variable substitution. This is substituted for bytes per pixel. </xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
</xsd:schema>