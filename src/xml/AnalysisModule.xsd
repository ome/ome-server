<?xml version = "1.0" encoding = "UTF-8"?>
<!--Generated by Turbo XML 2.3.1.100. Conforms to w3c http://www.w3.org/2001/XMLSchema-->
<xsd:schema xmlns:xsd = "http://www.w3.org/2001/XMLSchema"
	 elementFormDefault = "qualified">
	<xsd:group name = "inputRecordModel">
		<xsd:choice>
			<xsd:element ref = "Input" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "XYPlaneFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "XYPlaneFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFile" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "RawImageFilePath" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeT" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeW" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeX" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeY" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "sizeZ" minOccurs = "0" maxOccurs = "unbounded"/>
			<xsd:element ref = "BitsPerPixel" minOccurs = "0" maxOccurs = "unbounded"/>
		</xsd:choice>
	</xsd:group>
	<xsd:element name = "Declaration">
		<xsd:annotation>
			<xsd:documentation>States module requirements.
Formal Inputs are optional because input requirements may be specified by guaranteed image attributes. For example, OME_Image_XYZ_stats requires a path to the OME repository file, and Dimensions.
These are given by &lt;RawImageFilePath>, &lt;sizeX>, &lt;sizeY>, &lt;sizeZ>, &lt;sizeT>, and &lt;sizeW>.
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "FormalInput" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "FormalOutput" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "TableDefinition" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalInput" abstract = "true">
		<xsd:annotation>
			<xsd:documentation>Specifies an input requirement for a module. Image dimensions and image file locations (repository or other format) should not be specified with this. Image dimensions are intrisic to an image. They do not represent a special requirement. Image file locations and contents are specified by other elements. Specifically, RawImageFile, RawImageFilePath, XYPlaneFile, and XYPlaneFilePath.
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "DBLocation"/>
				<xsd:element ref = "LookupTable" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "UserDefined" default = "false" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>OME interprets this as a recommendation rather than a requirement.

Tied to DB. Table FORMAL_INPUTS Column USER_DEFINED
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_INPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "FormalInputID" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Referenced by elements such as Input, theZ, theT, etc. to map formal inputs to actual inputs. These elements are used by STDIN, CommandLine, and other elements under ExecutionInstructions.</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "FormalOutput">
		<xsd:annotation>
			<xsd:documentation>Specifies an output element of a module.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "DBLocation"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table FORMAL_OUTPUTS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "IBelongTo">
				<xsd:annotation>
					<xsd:documentation>Concerning MakeNewFeature attribute of ExecutionInstructions, if a new feature type is made, then there are two possible places a formal output attribute can be stored: It can be stored as an attribute of the FeatureIterator, or it can be stored as an attribute of the new Feature.
This tag is supposed to specify which. Can be left blank if module does not make new iterator.

Tied to DB. Table FORMAL_OUTPUTS Column FEATURE_TAG
Processed before storage to DB
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "[Feature]"/>
						<xsd:enumeration value = "[Iterator]"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "FormalOutputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Referenced by the element Output to map formal outputs to actual outputs. Output is used by STDOUT and other elements under ExecutionInstructions.</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "TableDefinition">
		<xsd:annotation>
			<xsd:documentation>Declares a table in the DB.
Maps to table DATATYPES during module import.

			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "AttributeType" use = "required">
				<xsd:annotation>
					<xsd:documentation>This may be D, I, or F. These represent Dataset, Image, and Feature, respectively. In deciding which of these to use, refer to the table and column to which this datatype maps.

Tied to DB. Table DATATYPES Column ATTRIBUTE_TYPE
				
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "D"/>
						<xsd:enumeration value = "I"/>
						<xsd:enumeration value = "F"/>
						<xsd:length value = "1"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "TableName" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPES Column TABLE_NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPES Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "TableID" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Referenced by TableID attribute of DBLocation element.</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTable">
		<xsd:annotation>
			<xsd:documentation>Describes valid values for an input. Think enumerations, (a list of valid values).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "LookupTableEntry" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "Name" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLES Column NAME</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLES Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "LookupTableEntry">
		<xsd:complexType>
			<xsd:attribute name = "Value" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLE_ENTRIES Column VALUE</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Label">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table LOOKUP_TABLE_ENTRIES Column LABEL</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "AnalysisModuleLibrary">
		<xsd:annotation>
			<xsd:documentation>An analysis module is defined by two things: 
1) A program
2) An interface
A single program may have multiple interfaces. Why do you need multiple interfaces?
Pretend you have a program that calculates simple statistics on the pixels of an image. You can specify which statistics you want via parameters.

Typing
./stats -mean -sigma image1

will ouput
Image | mean | sigma
image1 12.4 1

Typing
./stats -geomean -mean image1

will output
Image | geomean | mean
image1 12.2 12.4

The outputs are completely different. You need to specify an interface for each of these behaviors. 
Or pretend you have a powerful program that can do 10 unrelated tasks, each of which outputs an image. While the outputs are the same type and format, they represent 10 completely different things. In this case, it might make sense to define 10 corrosponding AnalysisModule to represent the 10 logical functions.

In any case, use AnalysisModule to define an interface and Program to store installation software for a program.
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "AnalysisModule" maxOccurs = "unbounded"/>
				<xsd:element ref = "Program" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "ExecutionInstructions">
		<xsd:annotation>
			<xsd:documentation>Specifies execution instructions. Perl packages do not need this element because they internally specify execution instructions by overriding functions from a base class. Command Line programs need to use this.
The schema does not check the need for this against ModuleType, so it may not report errors the installation logic will detect.

The location does not yet exist in the DB. The contents of this element (in XML format) will be stored in the DB.

Tied to DB. Table PROGRAMS Column EXECUTION
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:choice>
				<xsd:element ref = "CommandLine" minOccurs = "0"/>
				<xsd:element ref = "STDIN" minOccurs = "0"/>
				<xsd:element ref = "STDOUT" minOccurs = "0"/>
				<xsd:element ref = "InfileText" minOccurs = "0" maxOccurs = "unbounded"/>
				<xsd:element ref = "OutfileText" minOccurs = "0" maxOccurs = "unbounded"/>
			</xsd:choice>
			<xsd:attribute name = "ExecutionPoint" use = "required">
				<xsd:annotation>
					<xsd:documentation>Assigns a execution point for the analysis.
This needs to be mulled over again after Doug finalizes analysis engine &amp; use scenarios for modules dealing with datasets, images, &amp; features are constructed.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "precalculateDataset"/>
						<xsd:enumeration value = "precalculateImage"/>
						<xsd:enumeration value = "calculateFeature"/>
						<xsd:enumeration value = "postcalculateImage"/>
						<xsd:enumeration value = "postcalculateDataset"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "CommandLine">
		<xsd:annotation>
			<xsd:documentation>This describes the string that will be passed to a command line program via command line parameters. The command line handler will perform basic variable substitution on sub elements of this.
Example:
when you use the program, you type: /OME/bin/OME_Image_XYZ_stats Path=[path to file] Dims=[X],[Y],[Z],[W],[T],[BytesPerPix]
XML specification of the command line parameters is:
&lt;CommandLine>
	Path=&lt;PlaneFilePath/> Dims=&lt;sizeX/>,&lt;sizeY/>,&lt;sizeZ/>,&lt;sizeW/>,&lt;sizeT/>,&lt;BPP/>
&lt;/CommandLine>
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "inputRecordModel"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "STDIN">
		<xsd:annotation>
			<xsd:documentation>This specifies what and how to write content the analysis module will read from STDIN.
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "STDOUT">
		<xsd:annotation>
			<xsd:documentation>This specifies what and how to read content the analysis module prints to STDOUT.
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "OutputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "InfileText">
		<xsd:annotation>
			<xsd:documentation>If the analysis module reads input from a file, this is the place to describe the format of the file so it can automatically be generated.
There is not currently a use scenario for this, so it is not supported. If you have a module that needs to read input from a text file, contact OME developers.
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "InfileID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "OutfileText">
		<xsd:annotation>
			<xsd:documentation>If the analysis module reads output from a file, this is the place to describe the format of the file so it can automatically read into the DB.
There is not currently a use scenario for this, so it is not supported. If you have a module that needs to read input from a text file, contact OME developers.
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "OutputRecord" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "OutfileID" use = "required" type = "xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Input">
		<xsd:annotation>
			<xsd:documentation>References FormalInput. Used for variable substitution.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a InputDatatypeColumn Element. It should corrospond to an InputID specified in one of those.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Output">
		<xsd:annotation>
			<xsd:documentation>References FormalOutput. Used for variable substitution.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "FormalOutputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a FormalOutput Element. It should corrospond to an FormalOutputID specified in one of those.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "AccessBy" use = "required" type = "xsd:integer">
				<xsd:annotation>
					<xsd:documentation>Describes how to access information extracted using a regular expression. Examples are $1, $2, ...</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "AnalysisModule">
		<xsd:annotation>
			<xsd:documentation>Describes an interface to use with a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "Declaration"/>
				<xsd:element ref = "ExecutionInstructions" minOccurs = "0"/>
			</xsd:sequence>
			<xsd:attribute name = "ModuleName" use = "required">
				<xsd:annotation>
					<xsd:documentation>PROGRAM_NAME in the database is a misnomer. It really should be changed to NAME.

Tied to DB. Table PROGRAMS Column PROGRAM_NAME
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Category">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table PROGRAMS Column CATEGORY
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "32"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "VisualDesign" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table PROGRAMS Column VISUAL_DESIGN
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table PROGRAMS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "isStreamAlgorithm" default = "false" type = "xsd:boolean">
				<xsd:annotation>
					<xsd:documentation>This is a stub for future development. The database location doesn't even exist yet.

If the output of the analysis will be the same when pixel positions are scrambled, the analysis is a stream algorithm. 
Examples of stream algorithms are:
	A statistics module that produces mean, geometric mean, standard deviation, etc. for pixel intensities.
	A module to cross correlate pixel intensities across wavelengths.
Example of an algorithms that is not a stream algorithm is:
	FindSpots. (It's a module to find blobs in an image.)

If a module is a stream algorithm, it can function across the x, y, z, and time dimensions.

Tied to DB. Table PROGRAMS Column IS_STREAM_ALGORITHM
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "ModuleType" use = "required">
				<xsd:annotation>
					<xsd:documentation>As more handlers, are added, this part of the schema needs to be changed

Tied to DB. Table PROGRAMS Column MODULE_TYPE
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "OME::Analysis::PerlHandler"/>
						<xsd:enumeration value = "OME::Analysis::CLIHandler"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ProgramID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a Program Element. It should corrospond to a ProgramID specified in a Program Element.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "FeatureIterator">
				<xsd:annotation>
					<xsd:documentation>If the module iterates over a feature, specify the iterator here. It will reference a feature via the TAG column of the FEATURES table.
An example of a module that does not iterate over a feature is Find Cells. It examines one image at a time, hence it iterates over an image, not a feature. It produces zero or more features (Ã‡ell) per image. These Cell features belong to an image.
This module would not get a FeatureIterator attribute.
An example of a module that iterates over a feature is Find Golgi. It examines one CELL at a time. A cell is a feature, hence the module iterates over features, not images or datasets. It produces zero or more Golgi features per Cell feature. These Golgi features belong to a Cell feature.
This module would get a FeatureIterator attribute of "CELL".

Tied to DB. Table PROGRAMS Column DEFAULT_ITERATOR
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "128"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "NewFeatureName">
				<xsd:annotation>
					<xsd:documentation>If this module makes new features, then the new Feature's name needs to be specified here.
If the module does not make new features, do not specify a value for this attribute.

Tied to DB. Table PROGRAMS Column NEW_FEATURE_TAG
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "128"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "Program">
		<xsd:annotation>
			<xsd:documentation>Stores an installation package and installation script for a program.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "InstallationScript"/>
				<xsd:element ref = "InstallationFile"/>
			</xsd:sequence>
			<xsd:attribute name = "ProgramID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Referenced by AnalysisModule elements. Accordingly, each FormalOutput needs to be unique. This is not enforced in the schema, so watch your back.

					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Name">
				<xsd:annotation>
					<xsd:documentation>Program name. Does not have to be the name of the program's file.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Version" type = "xsd:string"/>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinaryFile">
		<xsd:annotation>
			<xsd:documentation>Describes a binary file.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "External"/>
				<xsd:element ref = "BinData"/>
			</xsd:sequence>
			<xsd:attribute name = "FileName">
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "64"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "External">
		<xsd:annotation>
			<xsd:documentation>Describes a file location.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "href" use = "required" type = "xsd:anyURI">
				<xsd:annotation>
					<xsd:documentation>file location</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "Offset" type = "xsd:integer"/>
			<xsd:attribute name = "SHA1" use = "required" type = "Hex40"/>
			<xsd:attribute name = "Compression">
				<xsd:annotation>
					<xsd:documentation>Only necessary if file is compressed.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "gzip"/>
						<xsd:enumeration value = "bzip2"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BinData" type = "xsd:base64Binary"/>
	<xsd:simpleType name = "Hex40">
		<xsd:restriction base = "xsd:hexBinary">
			<xsd:length value = "20"/>
		</xsd:restriction>
	</xsd:simpleType>
	<xsd:element name = "theZ">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a InputDatatypeColumn Element. It should corrospond to an InputID specified in one of those.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "theW">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a InputDatatypeColumn Element. It should corrospond to an InputID specified in one of those.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "theT">
		<xsd:complexType>
			<xsd:attribute name = "FormalInputID" use = "required" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Used to reference a InputDatatypeColumn Element. It should corrospond to an InputID specified in one of those.
Referential integrity is not enforced by this schema. That is, if you make a typo here, the error won't be detected until this module is installed.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "XYPlaneFilePath">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with a dynamically generated plane. Currently that means a TIFF.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "theZ"/>
				<xsd:element ref = "theT"/>
				<xsd:element ref = "theW"/>
			</xsd:sequence>
			<xsd:attribute name = "BPP">
				<xsd:annotation>
					<xsd:documentation>Specifies bits per pixel (BPP) the module is expecting. If the program can deal with both 8 and 16 bit images, leave this out and the BPP of the image will be used. That is, if the image is 8 bits, the module will get an 8 bits per pixel. If the image is 16 bits, the module will get 16 bits per pixel.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:integer">
						<xsd:enumeration value = "8"/>
						<xsd:enumeration value = "16"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Format">
				<xsd:annotation>
					<xsd:documentation>Specifies the expected format of the plane.
RAW corrosponds to OME repository format of pixel dump.
TIFF corrosponds to TIFF files.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "RAW"/>
						<xsd:enumeration value = "TIFF"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "XYPlaneFile">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with pixel contents of the plane. If the plane is of format TIFF, this will return the contents of the TIFF file. If this plane is of type RAW, this will return a pixel dump.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "theZ"/>
				<xsd:element ref = "theT"/>
				<xsd:element ref = "theW"/>
			</xsd:sequence>
			<xsd:attribute name = "BPP">
				<xsd:annotation>
					<xsd:documentation>Specifies bits per pixel (BPP) the module is expecting. If the program can deal with both 8 and 16 bit images, leave this out and the BPP of the image will be used. That is, if the image is 8 bits, the module will get an 8 bits per pixel. If the image is 16 bits, the module will get 16 bits per pixel.</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:integer">
						<xsd:enumeration value = "8"/>
						<xsd:enumeration value = "16"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Format">
				<xsd:annotation>
					<xsd:documentation>Specifies the expected format of the plane.
RAW corrosponds to OME repository format of pixel dump.
TIFF corrosponds to TIFF format
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "RAW"/>
						<xsd:enumeration value = "TIFF"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "sizeX">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the X dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeY">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the Y dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeZ">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the Z dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeT">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the T dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "sizeW">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This is substituted for the W dimension of the image.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "RawImageFilePath">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with the path and file of the raw pixel dump image file.
e.g. /OME/repository/1-tinyTest.ori
			
			
			
			
			
			
			</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "RawImageFile">
		<xsd:annotation>
			<xsd:documentation>Used with variable substitution. This will be substituted with the binary contents of the raw pixel dump image file.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "InputRecord">
		<xsd:annotation>
			<xsd:documentation>Groups a set of inputs into records.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:group ref = "inputRecordModel"/>
			</xsd:sequence>
			<xsd:attribute name = "RepeatCount" type = "xsd:positiveInteger">
				<xsd:annotation>
					<xsd:documentation>RepeatCount specifies how many times to write a record. If it is not specified, writing will continue until it runs out of things to write.

					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "OutputRecord">
		<xsd:annotation>
			<xsd:documentation>Groups a set of outputs into records.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType mixed = "true">
			<xsd:sequence>
				<xsd:element ref = "pat"/>
				<xsd:element ref = "Output" minOccurs = "0" maxOccurs = "unbounded"/>
			</xsd:sequence>
			<xsd:attribute name = "RepeatCount" type = "xsd:positiveInteger">
				<xsd:annotation>
					<xsd:documentation>RepeatCount specifies how many times to read a record. If it is not specified, reading will continue until it reaches the end of the output stream.
If used in conjuction with TerminateAt, reading will stop after RepeatCount or TerminateAt, whichever comes first.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "TerminateAt" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>TerminateAt specifies a regular expression. When a match to this is found, reading will stop.
If used in conjuction with RepeatCount, reading will stop after RepeatCount or TerminateAt, whichever comes first.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "BitsPerPixel">
		<xsd:annotation>
			<xsd:documentation>Used for variable substitution. This is substituted for bits per pixel. </xsd:documentation>
		</xsd:annotation>
		<xsd:complexType/>
	</xsd:element>
	<xsd:element name = "InstallationScript">
		<xsd:annotation>
			<xsd:documentation>The script should interface with the OME API to find all information it needs. (i.e. installation path) It also needs to set the location of the program after the program is installed. The location should be set through the API, but it will propogate to the LOCATION column of the PROGRAMS table.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "BinaryFile"/>
			</xsd:sequence>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "InstallationFile">
		<xsd:annotation>
			<xsd:documentation>Contains a packaged or zipped installation files (binaries or source code).</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:sequence>
				<xsd:element ref = "BinaryFile"/>
			</xsd:sequence>
			<xsd:attribute name = "Format" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>This is a stub for future development. Don't bother with it unless you know more about it.

Specifies the packaging and/or compression format of the Installation file.
					
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "DBLocation">
		<xsd:annotation>
			<xsd:documentation>Describes a location in the database by table and column.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexType>
			<xsd:attribute name = "ColumnName" use = "required">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPE_COLUMNS Column COLUMN_NAME
				
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "Description" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>Tied to DB. Table DATATYPE_COLUMNS Column DESCRIPTION</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
			<xsd:attribute name = "SQL_DataType">
				<xsd:annotation>
					<xsd:documentation>Don't mess with this unless you know what you are doing.
If it is necessary to generate a table and/or column in the Database, it will be necessary to tell the database a datatype. Not all SQL datatypes are supported currently.
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:enumeration value = "integer"/>
						<xsd:enumeration value = "double"/>
						<xsd:enumeration value = "float"/>
						<xsd:enumeration value = "boolean"/>
						<xsd:enumeration value = "string"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "ReferenceType">
				<xsd:annotation>
					<xsd:documentation>Stub for future development. Don't bother with it unless you know more about it.

Tied to DB. Table DATATYPE_COLUMNS Column REFERENCE_TYPE
				
					
					
					
					
					
					</xsd:documentation>
				</xsd:annotation>
				<xsd:simpleType>
					<xsd:restriction base = "xsd:string">
						<xsd:maxLength value = "256"/>
					</xsd:restriction>
				</xsd:simpleType>
			</xsd:attribute>
			<xsd:attribute name = "TableID" type = "xsd:string">
				<xsd:annotation>
					<xsd:documentation>References TableID attribute of TableDefinition element</xsd:documentation>
				</xsd:annotation>
			</xsd:attribute>
		</xsd:complexType>
	</xsd:element>
	<xsd:element name = "pat" type = "xsd:string">
		<xsd:annotation>
			<xsd:documentation>Contains a regular expression.</xsd:documentation>
		</xsd:annotation>
	</xsd:element>
</xsd:schema>