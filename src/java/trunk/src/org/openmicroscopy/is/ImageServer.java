/*
 * org.openmicroscopy.is.ImageServer
 *
 *------------------------------------------------------------------------------
 *
 *  Copyright (C) 2003 Open Microscopy Environment
 *      Massachusetts Institute of Technology,
 *      National Institutes of Health,
 *      University of Dundee
 *
 *
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *------------------------------------------------------------------------------
 */




/*------------------------------------------------------------------------------
 *
 * Written by:    Douglas Creager <dcreager@alum.mit.edu>
 *
 *------------------------------------------------------------------------------
 */




package org.openmicroscopy.is;

import java.io.File;
import java.io.FileNotFoundException;

/**
 * <p>Defines methods for interacting with an OME image server.  There
 * are currently two ways to connect to an image server:</p>
 *
 * <ol>
 *
 * <li><b>HTTP</b> - This is the usual connection mechanism.  All
 * calls to the image server are sent via HTTP.  The details of the
 * method to be called are sent as URL parameters.  The result of the
 * method called is parsed out of the HTTP response.</li>
 *
 * <li><b>CLI</b> - If the image server is on the same machine as the
 * client code (the code using this interface), it is possible to
 * execute the image server directly as a command-line program.  This
 * gives a slight performance increase over the HTTP interface.
 * However, in most production environments, the client code and image
 * server reside on separate machines, rendering this connection
 * mechanism unusable.</li>
 *
 * </ol>
 */

public abstract class ImageServer
{
    public static ImageServer getDefaultImageServer()
    {
        String uri = System.
            getProperty("org.openmicroscopy.is.url",
                        "http://localhost/cgi-bin/omeis");

        return getHTTPImageServer(uri);
    }

    public static ImageServer getHTTPImageServer(String location)
    {
        return new HttpImageServer(location);
    }

    protected ImageServer()
    {
        super();
    }

    /**
     * <p>Creates a new pixels file on the image server.  The
     * dimensions of the pixels must be known beforehand, and must be
     * specified to this method.  All of the dimensions must be
     * positive integers.</p>
     *
     * <p>Each pixel in the new file must have the same storage type.
     * This type is specified by the <code>bytesPerPixel</code>,
     * <code>isSigned</code>, and <code>isFloat</code> parameters.</p>
     *
     * <p>This method returns the pixels ID generated by the image
     * server.  Note that this is not the same as the attribute ID of
     * a Pixels attribute.  The pixels ID can be used in the
     * <code>get*</code>, <code>set*</code>, and <code>convert*</code>
     * methods (among others) to perform pixel I/O with the image
     * server.</p>
     *
     * <p>The new pixels file will be created in write-only mode.  The
     * <code>set*</code> and <code>convert*</code> methods should be
     * used to populate the pixel array.  Once the array is fully
     * populated, the <code>finishPixels</code> method should be used
     * to place the file in read-only mode.  At this point, the
     * <code>get*</code> methods can be called to retrieve the
     * pixels.</p>
     *
     * @param sizeX the size (in pixels) of the image's X dimension
     * @param sizeY the size (in pixels) of the image's Y dimension
     * @param sizeZ the size (in pixels) of the image's Z dimension
     * @param sizeC the size (in pixels) of the image's C dimension
     * @param sizeT the size (in pixels) of the image's T dimension
     * @param bytesPerPixel the number of bytes used to store a single
     * pixel
     * @param isSigned whether the value of each pixel is signed or
     * not
     * @param isFloat whether the value of each pixel is a float or an
     * integer
     * @return the pixel ID of the new pixels file
     * @throws ImageServerException if there was an error connecting
     * to the image server or creating the pixels file
     */
    public abstract long newPixels(int sizeX,
                                   int sizeY,
                                   int sizeZ,
                                   int sizeC,
                                   int sizeT,
                                   int bytesPerPixel,
                                   boolean isSigned,
                                   boolean isFloat)
        throws ImageServerException;

    /**
     * <p>Creates a new pixels file on the image server.  The
     * dimensions of the pixels must be known beforehand, and must be
     * specified to this method.  All of the dimensions must be
     * positive integers.  Each pixel in the new file must have the
     * same storage type.  This information is specified by the
     * <code>pixelsFileFormat</code> parameter.</p>
     *
     * <p>This method returns the pixels ID generated by the image
     * server.  Note that this is not the same as the attribute ID of
     * a Pixels attribute.  The pixels ID can be used in the
     * <code>get*</code>, <code>set*</code>, and <code>convert*</code>
     * methods (among others) to perform pixel I/O with the image
     * server.</p>
     *
     * <p>The new pixels file will be created in write-only mode.  The
     * <code>set*</code> and <code>convert*</code> methods should be
     * used to populate the pixel array.  Once the array is fully
     * populated, the <code>finishPixels</code> method should be used
     * to place the file in read-only mode.  At this point, the
     * <code>get*</code> methods can be called to retrieve the
     * pixels.</p>
     *
     * @param pixelsFileFormat the format of the new pixels file
     * @return the pixel ID of the new pixels file
     * @throws ImageServerException if there was an error connecting
     * to the image server or creating the pixels file
     */
    public long newPixels(final PixelsFileFormat format)
        throws ImageServerException
    {
        return newPixels(format.getSizeX(),
                         format.getSizeY(),
                         format.getSizeZ(),
                         format.getSizeC(),
                         format.getSizeT(),
                         format.getBytesPerPixel(),
                         format.isSigned(),
                         format.isFloat());
    }

    /**
     * Returns the properties of a previously created pixels file.
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @return a {@link PixelsFileFormat} object encoding the
     * properties of the pixels file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist
     */
    public abstract PixelsFileFormat getPixelsInfo(long pixelsID)
        throws ImageServerException;

    /**
     * Returns the SHA-1 digest of a previously created pixels file.
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @return the SHA-1 digest of the pixels file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist
     */
    public abstract String getPixelsSHA1(long pixelsID)
        throws ImageServerException;

    /**
     * Returns the location of the specified pixels file in the image
     * server's filesystem.
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @return the image-server-local path to the pixels file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist
     */
    public abstract String getPixelsServerPath(long pixelsID)
        throws ImageServerException;

    /**
     * Returns whether the <code>finishPixels</code> method has been
     * called on the specified pixels file.
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @return whether the <code>finishPixels</code> method has been
     * called on the specified pixels file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist
     */
    public abstract boolean isPixelsFinished(long pixelsID)
        throws ImageServerException;

    /**
     * <p>This method returns the entire pixel file for the given
     * pixel ID.  Be very careful, these can easily be friggin-huge in
     * size.  You probably don't ever want to call this method, unless
     * you've made the appropriate checks on the dimensions of the
     * pixels to ensure that it won't be too large.</p>
     *
     * <p>You must also specify whether you want to receive a
     * big-endian or little-endian pixel array.  The image server will
     * take care of performing the appropriate conversion for you.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @result an array of pixels for the specified file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * readable
     */
    public abstract byte[] getPixels(long pixelsID,
                                     boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method returns a pixel array of the specified stack.
     * The stack is specified by its C and T coordinates, which have
     * 0-based indices.  While this method is less likely to be a
     * memory hog as the {@link getPixels} method, it is still
     * possible for large images with few timepoints to cause
     * problems.  As usual when dealing with large images, care must
     * be taken to use your computational resources appropriately.</p>
     *
     * <p>You must also specify whether you want to receive a
     * big-endian or little-endian pixel array.  The image server will
     * take care of performing the appropriate conversion for you.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theC the C parameter of the desired stack
     * @param theT the T parameter of the desired stack
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @result an array of pixels for the specified stack
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * readable
     */
    public abstract byte[] getStack(long pixelsID,
                                    int theC, int theT,
                                    boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method returns a pixel array of the specified plane.
     * The plane is specified by its Z, C and T coordinates, which
     * have 0-based indices.  While this method is the least likely to
     * be a memory hog, care must still be taken to use your
     * computational resources appropriately.</p>
     *
     * <p>You must also specify whether you want to receive a
     * big-endian or little-endian pixel array.  The image server will
     * take care of performing the appropriate conversion for you.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theZ the C parameter of the desired plane
     * @param theC the C parameter of the desired plane
     * @param theT the T parameter of the desired plane
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @result an array of pixels for the specified plane
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * readable
     */
    public abstract byte[] getPlane(long pixelsID,
                                    int theZ, int theC, int theT,
                                    boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method returns a pixel array of an arbitrary
     * hyper-rectangular region of an image.  The region is specified
     * by two coordinate vectors, which have 0-based indices.  The
     * region boundaries must be well formed, and are inclusive.
     * (Each coordinate must be within the range of valid values for
     * that dimension, and each "0" coordinate must be less than or
     * equal to the respective "1" coordinate.)</p>
     *
     * <p>You must also specify whether you want to receive a
     * big-endian or little-endian pixel array.  The image server will
     * take care of performing the appropriate conversion for you.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @result an array of pixels for the specified region
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * readable
     */
    public abstract byte[] getROI(long pixelsID,
                                  int x0,int y0,int z0,int c0,int t0,
                                  int x1,int y1,int z1,int c1,int t1,
                                  boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method sends an entire array of pixels for the given
     * pixels ID.  The pixels are specified by a byte array, which
     * should be a raw pixel dump.  The endian-ness of the pixels
     * should be specified.</p>
     *
     * <p>It is up to the caller to ensure that the byte array is of
     * the correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param buf an array of pixels
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     */
    public abstract void setPixels(long pixelsID,
                                   byte[] buf,
                                   boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method sends an entire array of pixels for the given
     * pixels ID.  The pixels are specified by a local file, which
     * should be a raw pixel dump.  The endian-ness of the pixels
     * should be specified.</p>
     *
     * <p>It is up to the caller to ensure that the file is of the
     * correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param file a file containing a pixel dump
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     * @throws FileNotFoundException if the specified file cannot be
     * read
     */
    public abstract void setPixels(long pixelsID,
                                   File file,
                                   boolean bigEndian)
        throws ImageServerException, FileNotFoundException;

    /**
     * <p>This method sends a stack of pixels for the given pixels ID.
     * The pixels are specified by a byte array, which should be a raw
     * pixel dump.  The endian-ness of the pixels should be
     * specified.</p>
     *
     * <p>It is up to the caller to ensure that the byte array is of
     * the correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theC the C parameter of the desired stack
     * @param theT the T parameter of the desired stack
     * @param buf an array of pixels
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     */
    public abstract void setStack(long pixelsID,
                                  int theC, int theT,
                                  byte[] buf,
                                  boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method sends a stack of pixels for the given pixels ID.
     * The pixels are specified by a local file, which should be a raw
     * pixel dump.  The endian-ness of the pixels should be
     * specified.</p>
     *
     * <p>It is up to the caller to ensure that the file is of the
     * correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theC the C parameter of the desired stack
     * @param theT the T parameter of the desired stack
     * @param file a file containing a pixel dump
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     * @throws FileNotFoundException if the specified file cannot be
     * read
     */
    public abstract void setStack(long pixelsID,
                                  int theC, int theT,
                                  File file,
                                  boolean bigEndian)
        throws ImageServerException, FileNotFoundException;

    /**
     * <p>This method sends a plane of pixels for the given pixels ID.
     * The pixels are specified by a byte array, which should be a raw
     * pixel dump.  The endian-ness of the pixels should be
     * specified.</p>
     *
     * <p>It is up to the caller to ensure that the byte array is of
     * the correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theZ the Z parameter of the desired plane
     * @param theC the C parameter of the desired plane
     * @param theT the T parameter of the desired plane
     * @param buf an array of pixels
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     */
    public abstract void setPlane(long pixelsID,
                                  int theZ, int theC, int theT,
                                  byte[] buf,
                                  boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method sends a plane of pixels for the given pixels ID.
     * The pixels are specified by a local file, which should be a raw
     * pixel dump.  The endian-ness of the pixels should be
     * specified.</p>
     *
     * <p>It is up to the caller to ensure that the file is of the
     * correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theZ the Z parameter of the desired plane
     * @param theC the C parameter of the desired plane
     * @param theT the T parameter of the desired plane
     * @param file a file containing a pixel dump
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     * @throws FileNotFoundException if the specified file cannot be
     * read
     */
    public abstract void setPlane(long pixelsID,
                                  int theZ, int theC, int theT,
                                  File file,
                                  boolean bigEndian)
        throws ImageServerException, FileNotFoundException;

    /**
     * <p>This method sends an arbitrary region of pixels for the
     * given pixels ID.  The pixels are specified by a byte array,
     * which should be a raw pixel dump.  The endian-ness of the
     * pixels should be specified.</p>
     *
     * <p>It is up to the caller to ensure that the byte array is of
     * the correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param buf an array of pixels
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     */
    public abstract void setROI(long pixelsID,
                                int x0,int y0,int z0,int c0,int t0,
                                int x1,int y1,int z1,int c1,int t1,
                                byte[] buf,
                                boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>This method sends an arbitrary region of pixels for the
     * given pixels ID.  The pixels are specified by a local file,
     * which should be a raw pixel dump.  The endian-ness of the
     * pixels should be specified.</p>
     *
     * <p>It is up to the caller to ensure that the file is of the
     * correct size.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param file a file containing a pixel dump
     * @param bigEndian whether the returns pixels should be in
     * big-endian order
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     * @throws FileNotFoundException if the specified file cannot be
     * read
     */
    public abstract void setROI(long pixelsID,
                                int x0,int y0,int z0,int c0,int t0,
                                int x1,int y1,int z1,int c1,int t1,
                                File file,
                                boolean bigEndian)
        throws ImageServerException, FileNotFoundException;

    /**
     * <p>This method ends the writable phase of the life of a pixels
     * file in the image server.</p>
     *
     * <p>Pixels files in the image server can only be written to
     * immediately after they are created.  Once the pixels file is
     * fully populated, it is marked as being completed (via this
     * method).  As this point, all of the writing methods
     * (<code>set*</code>, <code>convert*</code>) become unavailable
     * for the pixels file, and the reading methods
     * (<code>get*</code>) become available.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the pixels ID does not exist or is not
     * writeable
     */
    public abstract void finishPixels(long pixelsID)
        throws ImageServerException;

    /**
     * <p>Transfers the specified file to the image server, returning
     * a file ID.  This ID can then be used in calls to the
     * <code>convert*</code> methods, allowing a new pixels file to be
     * created from the contents of the original file.</p>
     *
     * @param file the file to upload
     * @return the ID of the uploaded file
     * @throws ImageServerException if there was an error contacting
     * the image server or uploading the file
     * @throws FileNotFoundException if the specified file cannot be
     * read
     */
    public abstract long uploadFile(File file)
        throws ImageServerException, FileNotFoundException;

    /**
     * Returns the original filename and length of a previously
     * uploaded file.
     *
     * @param fileID the ID of the previously uploaded file
     * @return a {@link FileInfo} object describing the file
     * @throws ImageServerException if there was an error contacting
     * the image server or retrieving the file
     */
    public abstract FileInfo getFileInfo(long fileID)
        throws ImageServerException;

    /**
     * Returns the SHA-1 digest of a previously uploaded file.
     * @param fileID the ID of the previously uploaded file
     * @return the SHA-1 digest of the pixels file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the file ID does not exist
     */
    public abstract String getFileSHA1(long FileID)
        throws ImageServerException;

    /**
     * Returns the location of the specified file in the image
     * server's filesystem.
     * @param fileID the ID of the previously uploaded file
     * @return the image-server-local path to the file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the file ID does not exist
     */
    public abstract String getFileServerPath(long fileID)
        throws ImageServerException;

    /**
     * Reads a portion of an uploaded file, without using any caching.
     * This is usually not the method you should use to read from an
     * image server file; the {@link readFile} method implements a
     * limited form of caching and can be much more efficient.
     *
     * @see readFile
     * @param fileID the ID of the previously uploaded file
     * @param offset the offset into the file to start reading from
     * @param length the number of bytes to read from the file
     * @return the data read from the file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the file ID does not exist
     */
    public abstract byte[] readFileWithoutCaching(long fileID,
                                                  long offset,
                                                  int  length)
        throws ImageServerException;

    /**
     * The largest file read request that will still cause the {@link
     * readData} method to use the cache.
     * @see readData
     */
    public static int MAXIMUM_READ_TO_USE_CACHE = 2048;

    /**
     * The size of the cache used by the {@link readData} method.
     * @see readData
     */
    public static int CACHE_SIZE = 4096;

    protected boolean  cacheFilled = false;
    protected byte[]   cache;
    protected long     cachedFileID;
    protected FileInfo cachedFileInfo;
    protected long     cacheStart;
    protected int      cacheLength;

    /**
     * <p>Reads a portion of an uploaded file.  The method implements
     * a limited form of caching, so that client code can read small,
     * spatially related portions of the file without generating too
     * many I/O calls to the image server.</p>
     *
     * <p>The caching is only used if the <code>length</code>
     * parameter is less than the value of the {@link
     * MAXIMUM_READ_TO_USE_CACHE} field.  If it is, the actual
     * <code>ReadFile</code> call sent to the image server will read a
     * full block of {@link CACHE_SIZE} bytes, centered around the
     * region requested.  Subsequent calls which request data fully
     * enclosed within the full region will return that data without
     * generating another image server call.  If the data requested by
     * the subsequent call does not fall within the cached region, a
     * new block is read, and the existing one is thrown away.  Note
     * that this means that interleaving reads from two separate files
     * will eliminate the benefit of the cache.</p>
     *
     * <p>If the requested length is 2K or more, the caching mechanism
     * will be completely bypassed.  Any previously cached data will
     * not be modified.</p>
     *
     * <p><b>This method is not thread-safe</b>; it is up to the
     * caller to perform any necessary synchronization.  If multiple
     * threads try to call this method simultaneously, Bad Things
     * could happen.</p>
     *
     * @param fileID the ID of the previously uploaded file
     * @param offset the offset into the file to start reading from
     * @param length the number of bytes to read from the file
     * @return the data read from the file
     * @throws ImageServerException if there was an error contacting
     * the image server or if the file ID does not exist
     */
    public byte[] readFile(final long fileID, 
                           final long offset, final int length)
        throws ImageServerException
    {
        if (length <= MAXIMUM_READ_TO_USE_CACHE)
        {
            if (!cacheFilled ||
                cachedFileID != fileID ||
                offset < cacheStart ||
                offset+length >= cacheStart+cacheLength)
            {
                // This is a cache miss, or the cache has not been
                // filled yet.

                // If the current cache is also from this file,
                // there's no need to re-read its length.
                if (!cacheFilled || cachedFileID != fileID)
                {
                    cachedFileInfo = getFileInfo(fileID);
                }

                // Calculate the bounds of an appropriate cache block,
                // centered on the requested region.  Ensure that it
                // does not go past the end of the file.
                long fileSize = cachedFileInfo.getLength();
                int extra = CACHE_SIZE-length;
                long realOffset = offset - (extra/2);
                if (realOffset < 0) realOffset = 0;
                long realEnd = realOffset + CACHE_SIZE;
                if (realEnd > fileSize) realEnd = fileSize;
                // This should not overflow, since it should have a
                // maxmimum value of CACHE_SIZE, which is an int.
                int realSize = (int) (realEnd-realOffset);

                cacheFilled = true;
                cache = readFileWithoutCaching(fileID,realOffset,realSize);
                cachedFileID = fileID;
                cacheStart = realOffset;
                cacheLength = realSize;
            }

            // We have either just loaded in an appropriate cache, or
            // the cache was already filled correctly.  Return the
            // requested data.

            final byte[] result = new byte[length];
            for (int i = 0, j = (int) (offset-cacheStart); 
                 i < length; 
                 i++, j++)
                result[i] = cache[j];

            return result;
        } else {
            return readFileWithoutCaching(fileID,offset,length);
        }
    }

    /**
     * <p>Copies pixels from an original file into a new pixels file.
     * The original file should have been previously uploaded via the
     * {@link uploadFile} method.  The pixels file should have been
     * previously created via the {@link newPixels} method.  The
     * server will start reading the pixels from the specified offset,
     * which should be expressed as bytes from the beginning of the
     * file.</p>
     *
     * <p>This method copies a single XYZ stack of pixels.  The pixels
     * in the original file should be in XYZ order, and should match
     * the storage type declared for the new pixels file.  The stack
     * is specified by its C and T coordinates, which have 0-based
     * indices.  The endian-ness of the uploaded file should be
     * specified; if this differs from the endian-ness of the new
     * pixels file, byte swapping will be performed by the server.</p>
     *
     * <p>If the specified pixel file isn't in write-only mode on the
     * image server, an error will be thrown.</p>
     *
     * <p>The number of pixels successfully written by the image
     * server will be returned.  This value can be used as an
     * additional error check by client code.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theC the C index of the desired stack
     * @param theT the T index of the desired stack
     * @param fileID the ID of the previously uploaded file
     * @param offset the offset into the file to start reading from
     * @param bigEndian the endianness of the pixels in the uploaded
     * file
     */
    public abstract long convertStack(long pixelsID,
                                      int theC, int theT,
                                      long fileID, long offset,
                                      boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>Copies pixels from an original file into a new pixels file.
     * The original file should have been previously uploaded via the
     * {@link uploadFile} method.  The pixels file should have been
     * previously created via the {@link newPixels} method.  The
     * server will start reading the pixels from the specified offset,
     * which should be expressed as bytes from the beginning of the
     * file.</p>
     *
     * <p>This method copies a single XY plane of pixels.  The pixels
     * in the original file should be in XY order, and should match
     * the storage type declared for the new pixels file.  The plane
     * is specified by its Z, C and T coordinates, which have 0-based
     * indices.  The endian-ness of the uploaded file should be
     * specified; if this differs from the endian-ness of the new
     * pixels file, byte swapping will be performed by the server.</p>
     *
     * <p>If the specified pixel file isn't in write-only mode on the
     * image server, an error will be thrown.</p>
     *
     * <p>The number of pixels successfully written by the image
     * server will be returned.  This value can be used as an
     * additional error check by client code.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theZ the Z index of the desired plane
     * @param theC the C index of the desired plane
     * @param theT the T index of the desired plane
     * @param fileID the ID of the previously uploaded file
     * @param offset the offset into the file to start reading from
     * @param bigEndian the endianness of the pixels in the uploaded
     * file
     */
    public abstract long convertPlane(long pixelsID,
                                      int theZ, int theC, int theT,
                                      long fileID, long offset,
                                      boolean bigEndian)
        throws ImageServerException;

    /**
     * <p>Copies pixels from an original file into a new pixels file.
     * The original file should have been previously uploaded via the
     * {@link uploadFile} method.  The pixels file should have been
     * previously created via the {@link newPixels} method.  The
     * server will start reading the pixels from the specified offset,
     * which should be expressed as bytes from the beginning of the
     * file.</p>
     *
     * <p>This method copies a subset of rows of a single plane of
     * pixels.  The pixels in the original file should be in XY order,
     * and should match the storage type declared for the new pixels
     * file.  The rows are specified by their Z, C and T coordinates,
     * and by an initial Y coordinate and number of rows to copy.  All
     * of the coordinates have 0-based indices.  The endian-ness of
     * the uploaded file should be specified; if this differs from the
     * endian-ness of the new pixels file, byte swapping will be
     * performed by the server.</p>
     *
     * <p>If the specified pixel file isn't in write-only mode on the
     * image server, an error will be thrown.</p>
     *
     * <p>The number of pixels successfully written by the image
     * server will be returned.  This value can be used as an
     * additional error check by client code.</p>
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     * @param theY the first row of the desired region
     * @param numRows the number of rows in the desired region
     * @param theZ the Z index of the desired region
     * @param theC the C index of the desired region
     * @param theT the T index of the desired region
     * @param fileID the ID of the previously uploaded file
     * @param offset the offset into the file to start reading from
     * @param bigEndian the endianness of the pixels in the uploaded
     * file
     */
    public abstract long convertRows(long pixelsID,
                                     int theY, int numRows,
                                     int theZ, int theC, int theT,
                                     long fileID, long offset,
                                     boolean bigEndian)
        throws ImageServerException;

    /**
     * Returns a {@link PlaneStatistics} object containing basic pixel
     * statistics for each plane in the specified pixels file.
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     */
    public abstract PlaneStatistics getPlaneStatistics(long pixelsID)
        throws ImageServerException;

    /**
     * Returns a {@link StackStatistics} object containing basic pixel
     * statistics for each stack in the specified pixels file.
     *
     * @param pixelsID the pixels ID of a previously created pixels
     * file
     */
    public abstract StackStatistics getStackStatistics(long pixelsID)
        throws ImageServerException;
}